<!DOCTYPE html>
<html lang="zh-cn">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>FXXS</title>
  <link rel="canonical" href="http://fxxs.github.io/index.html">
  <meta name="author" content="ted423" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="FXXS" />
  
  <meta property="og:type" content="website">
<meta property="og:title" content="FXXS">
<meta property="og:url" content="http://fxxs.github.io/index.html">
<meta property="og:site_name" content="FXXS">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ted423">
<meta property="article:tag" content="FXXS">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FXXS" type="application/atom+xml">
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kr-core.min.css" media="all"></link>
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/highlight.js/night-eighties.min.css" media="all"></link>
  
  <link rel="stylesheet" id="theme-light-css" href="/css/kr-theme/light.min.css" media="all"></link>
  <link rel="stylesheet" id="theme-dark-css" href="/css/kr-theme/dark.min.css" media="(prefers-color-scheme: dark)"></link>
  <script src="/js/kr-theme.min.js"></script>
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></link>
  
    <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></link>
  
  
    <link rel="stylesheet" href="/vendors/viewerjs@1.11.6/dist/viewer.min.css"></link>
  
  <!-- 不得不预先加载的一些JS文件 -->
  
    <script src="/vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js"></script>
  
  <!-- 自定义站点横幅和背景 -->
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('');
      }
      html[data-theme="dark"] .kratos-cover.kratos-cover-2 {
        background-image: url('');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('');
        }
        html[data-theme="dark"] body.custom-background {
          background-image: url('');
        }
      }
    
    
      .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
      html[data-theme="dark"] .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
    
  </style>

  <!-- 额外的追加注入项 -->
  
<meta name="generator" content="Hexo 7.3.0"></head>

    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">FXXS</a></div>
                    <div id="kratos-nav-toggle-wrapper" class="nav-toggle">
                        <a id="kratos-nav-toggle" class="kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>FXXS</h2> <br />
                        <span>FXXS</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">


        

            

            <section class="kr-main-col col-md-8">

        

            <!-- Breadcrumb for tag & category page -->



    
    
        <article class="kratos-hentry clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-entry-border clearfix">
        
            <div class="pin-top wrapper">
                <div class="pin-top inner"></div>
            </div>
        
        <div class="kratos-entry-post-main">
            
            
            <div class="kratos-entry-post-inner">
                <header class="kratos-entry-header">
                        <a class="label-link" href="/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a>
                    <h2 class="kratos-entry-title"><a href="/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" itemprop="mainEntityOfPage"><span itemprop="name headline">基本概念</span></a>
                </header>
                <div class="kratos-entry-content">
                    <p itemProp="description">
                        
                            视频格式本文大部分参考以及直接引用http:&#x2F;&#x2F;vcb-s.com&#x2F;archives&#x2F;2726
https:&#x2F;&#x2F;help.aliyun.com&#x2F;document_detail&#x2F;99380.html
视频的基础参数分辨率视频是由连续的图...
                        
                    </p>
                </div>
            </div>
        </div>
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2022-10-24T10:51:15.761Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2022-10-24</a>
                </time>
                <a>
                    
                </a>
                
                
            </span>
            <span class="pull-right">
                <a class="read-more" href="/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
            </span>
        </footer>
    </div>
</article>
    

    
    
        <article class="kratos-hentry clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-entry-border clearfix">
        
            <div class="pin-top wrapper">
                <div class="pin-top inner"></div>
            </div>
        
        <div class="kratos-entry-post-main">
            
            
            <div class="kratos-entry-post-inner">
                <header class="kratos-entry-header">
                        <a class="label-link" href="/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a>
                    <h2 class="kratos-entry-title"><a href="/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E3%80%81%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/" itemprop="mainEntityOfPage"><span itemprop="name headline">封装格式(MP4/MKV…)、编码格式(H.264/H.265/AC3/AAC…)、编码器(x265/x264/SVT-AV1)</span></a>
                </header>
                <div class="kratos-entry-content">
                    <p itemProp="description">
                        
                            参考

http:&#x2F;&#x2F;vcb-s.com&#x2F;archives&#x2F;2726
https:&#x2F;&#x2F;help.aliyun.com&#x2F;document_detail&#x2F;99380.html

容器(Container)又名封装格式，或者格式(Forma...
                        
                    </p>
                </div>
            </div>
        </div>
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2022-10-24T10:51:14.892Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2022-10-24</a>
                </time>
                <a>
                    
                </a>
                
                
            </span>
            <span class="pull-right">
                <a class="read-more" href="/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E3%80%81%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
            </span>
        </footer>
    </div>
</article>
    

    
    
        <article class="kratos-hentry clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-entry-border clearfix">
        
        <div class="kratos-entry-post-main">
            
            
            <div class="kratos-entry-post-inner">
                <header class="kratos-entry-header">
                        <a class="label-link" href="/categories/Issue/">Issue</a>
                    <h2 class="kratos-entry-title"><a href="/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" itemprop="mainEntityOfPage"><span itemprop="name headline">常见报错</span></a>
                </header>
                <div class="kratos-entry-content">
                    <p itemProp="description">
                        
                            x265 crash123456[2022-01-07][21:18:15] WARNING: Input process exited with error (code: 1), your encode might be *inco...
                        
                    </p>
                </div>
            </div>
        </div>
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2024-08-28T12:36:37.847Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2024-08-28</a>
                </time>
                <a>
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/Issue/" rel="tag">Issue</a>
                    
                </a>
                
                
            </span>
            <span class="pull-right">
                <a class="read-more" href="/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
            </span>
        </footer>
    </div>
</article>
    

    
    
        <article class="kratos-hentry kratos-entry-border clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-status">
        
            <i class="fa fa-refresh"></i>
        
        <div class="kratos-status-inner">
            <div class="kratos-status-content" itemprop="articleBody">
                
                    <h1 id="压制基础教程（FXXS出品）"><a href="#压制基础教程（FXXS出品）" class="headerlink" title="压制基础教程（FXXS出品）"></a>压制基础教程（FXXS出品）</h1><h3 id="源、编码、透明度对比"><a href="#源、编码、透明度对比" class="headerlink" title="源、编码、透明度对比"></a>源、编码、透明度对比</h3><p><strong>源</strong>：源是指高质量可以用于进行压制编码的视频，一般包括蓝光圆盘、高质量的Web（一般4K的SDR）等。压片时应采用 <strong>最优质的源</strong> 进行压制，提高压制质量。</p>
<p>随着很多老片的BD推出，很多蓝光源是从低分辨率拉到高分辨率，被称为 Upscaled，在压制时应注意复原为原版的分辨率，不要压制过高的分辨率。关于WEB源应谨慎使用，尤其1080p的web-dl一般都为低质量不可以进行二次压制源，如非必要请勿压制，4k的SDR web源目前评价较好，往往好于1080p的BD来源，对于压制1080p的视频可以进行比较使用。</p>
<p><strong>！！！对于已经编码过的视频禁止二次编码！！！</strong> (通常而言，二次编码违反选择最优质源进行压制的原则。)</p>
<p><strong>编码</strong>：编码是指对于高质量来源进行压缩编码，进一步节约体积。编码过程种主要进行片源处理，修复源较为明显常见问题，通常包括脏边、色带、碎块、颜色偏差、伽马矫正等；切除黑边，去除源中16：9比例下的黑色边框；压制空间，主要将源采用更高的压缩方式进行重新编码，通常为有损方式。</p>
<p><strong>透明度对比</strong>：透明度是评价源于编码之间的相似程度的指标。良好的透明度是指在有经验的编码人员下都不能较为明显区分压制作品与源之间的差距。</p>
<p>根据I、P、B帧的功能，在编码过程中，编码器一般会尊重I帧内容，哪怕再劣质的压制，都不会对其进行明显的转换；而针对p帧，编码器可以转化为B帧进行编码节约空间，对于B帧进行重新编码。因此透明度应该从源与压制中P-&gt;B以及B-&gt;B的转换质量对比评判的压制质量。</p>
<p><strong>Bloating</strong>：称为臃肿，是指实现在相同透明度情况下，码率较高。根据压制较为广泛接受的规则，当压制作品太过接近源的码率也被认为Bloating，数值如下表：(x265建议更小的比例)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>1080p</th>
<th>720p</th>
<th>576p</th>
<th>480p</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原盘码率比例</td>
<td>75%</td>
<td>50%</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="x264-与-x265"><a href="#x264-与-x265" class="headerlink" title="x264 与 x265"></a>x264 与 x265</h3><p>在安装比 VapourSynth 更容易找到的 x264 和 x265 编码器前，你也可以选择使用它们的修改版。 最主流 x264 的修改版是 tmod 。值得注意的改进包括 <strong>淡化补偿(fade-compensate)</strong> ，在 <strong>宏块树(mbtree)</strong> 开启的情况下对淡入淡出进行编码，以及更多的 <strong>自适应量化(aq-mode)</strong> 选项。除非你不使用这些选项（但现在几乎没有人这么做），那么你可以直接使用 vanilla x264 代替。而如果你希望在转码时更加精确地控制，毫无疑问你应该尝试使用 tmod 并捆绑使用它提供的<code>aq-mode </code>，这样你就能够从中榨取出更高的质量，从而在保护噪点的同时不至于破坏线条。</p>
<p>最主流的 x265 修改版则是 yukki ，相比 x264 的修改版它却没有那么让人印象深刻。所有这一切都包括一些外观上的变化，比如更准确的预计完成时间。</p>
<h4 id="x264参数-1080p"><a href="#x264参数-1080p" class="headerlink" title="x264参数(1080p)"></a>x264参数(1080p)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--crf * --preset placebo --profile high --level <span class="number">4.1</span> --no-fast-pskip --threads auto --deblock -<span class="number">3</span>,-<span class="number">3</span> --me umh --subme <span class="number">10</span> --vbv-bufsize <span class="number">78125</span> --vbv-maxrate <span class="number">62500</span> --colormatrix bt709 --colorprim bt709 --merange <span class="number">48</span> --rc-lookahead <span class="number">60</span> --aq-mode <span class="number">2</span> --no-mbtree  --no-dct-decimate --<span class="built_in">min</span>-keyint <span class="number">24</span>  --ipratio <span class="number">1.3</span> --pbratio <span class="number">1.2</span> --aq-strength <span class="number">0.8</span> --qcomp <span class="number">0.65</span> --psy-rd <span class="number">1.05</span>:<span class="number">0.00</span> --bframes <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>(crf可以用18)<br>ref说明</p>
<ul>
<li>480p ref&#x3D;16</li>
<li>576p ref&#x3D;14</li>
<li>720p ref&#x3D;9(-12)</li>
<li>1080p ref&#x3D;5</li>
</ul>
<p>ref开太高的话，ptp会提示 DXVA: Incompatible</p>
<p>请注意ref的计算，分辨率切黑边会导致 ref 可设置值下降，留空会自动计算</p>
<p>ref计算方法(机翻)：<br>对于 –level 4.1，根据 H.264 标准，最大 DPB（解码图片缓冲区）大小为 12,288 千字节。</p>
<p>由于每个帧都以 YV12 格式存储，即每像素 1.5 字节，因此 1920x1088 帧为</p>
<p>1920 × 1088 × 1.5 &#x3D; 3133440 字节 &#x3D; 3060 千字节。</p>
<p>12,288 ÷ 3060 千字节 &#x3D; 4.01568627，因此您最多可以使用 4 个参考帧。</p>
<p>请记住，在进行计算时，将两个维度向上舍入为 mod16 值，即使您没有对 mod16 进行编码！让我们对 1920x800 进行计算。<br>1920 × 800 × 1.5 &#x3D; 2304000 字节 &#x3D; 2250 千字节。12,288 ÷ 2250 千字节 &#x3D; 5.45777778，因此最多可 以使用 5 个参考帧。请注意，这些转换使用基数 2，<br>1 千字节 &#x3D;&#x3D; 1024 字节。如果计算错误，也没关系 - 如果使用太多，x264 将显示警告，你会知道是否需要更改它。</p>
<h4 id="x265非HDR参数-仅供参考"><a href="#x265非HDR参数-仅供参考" class="headerlink" title="x265非HDR参数(仅供参考)"></a>x265非HDR参数(仅供参考)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D 10 --preset veryslower --level-idc 5.1 --ctu 32 --rd 4 --subme 7 --ref 5 --pmode --no-rect --no-amp --rskip 0 --tu-intra-depth 4 --tu-inter-depth 4 --range limited --no-open-gop --no-sao --rc-lookahead 100 --no-cutree --bframes 8 --vbv-bufsize 160000 --vbv-maxrate 160000 --colorprim bt709 --transfer bt709 --colormatrix bt709 --deblock -3:-3  --no-strong-intra-smoothing --ipratio 1.3 --pbratio 1.2 --qcomp 0.6 --aq-mode 2 --aq-strength 1.0 --psy-rd 1.00 --psy-rdoq 1.00</span><br></pre></td></tr></table></figure>

<h4 id="x265的HDR参数-仅供参考-HDR参数需要计算，不能直接使用"><a href="#x265的HDR参数-仅供参考-HDR参数需要计算，不能直接使用" class="headerlink" title="x265的HDR参数(仅供参考,HDR参数需要计算，不能直接使用)"></a>x265的HDR参数(仅供参考,HDR参数需要计算，不能直接使用)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D <span class="number">10</span> --crf * --preset slower --level-idc <span class="number">5.1</span> --bframes <span class="number">8</span> --rd <span class="number">4</span> --me <span class="number">3</span> --subme <span class="number">7</span> --ref <span class="number">5</span> --merange <span class="number">57</span> --ipratio <span class="number">1.3</span> --pbratio <span class="number">1.2</span> --aq-mode <span class="number">2</span> --aq-strength <span class="number">1.00</span> --qcomp <span class="number">0.60</span> --psy-rd <span class="number">1.5</span> --psy-rdoq <span class="number">1.00</span> --ctu <span class="number">64</span> --rc-lookahead <span class="number">100</span> --deblock -<span class="number">3</span>:-<span class="number">3</span> --no-strong-intra-smoothing --cbqpoffs <span class="number">0</span> --crqpoffs <span class="number">0</span> --qg-size <span class="number">8</span> --<span class="built_in">range</span> limited --no-frame-dup --selective-sao <span class="number">0</span> --no-cutree --tu-intra-depth <span class="number">4</span> --no-<span class="built_in">open</span>-gop --tu-inter-depth <span class="number">4</span> --rskip <span class="number">0</span> --no-tskip --no-early-skip --<span class="built_in">min</span>-keyint=<span class="number">1</span> --no-rect --no-amp --vbv-bufsize <span class="number">160000</span> --vbv-maxrate <span class="number">160000</span> --no-sao --aud --repeat-headers --hrd --hdr-opt --colorprim bt2020 --colormatrix bt2020nc --transfer smpte2084 --chromaloc <span class="number">2</span> --pmode --master-display <span class="string">&quot;G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(40000000,50)&quot;</span> --<span class="built_in">max</span>-cll=<span class="number">577</span>,<span class="number">512</span></span><br></pre></td></tr></table></figure>

<p><strong>其中的HDR参数应根据源进行计算设置</strong></p>
<h2 id="压制环境构建"><a href="#压制环境构建" class="headerlink" title="压制环境构建"></a>压制环境构建</h2><p>全套软件打包(请联系相关人员获取)</p>
<p>便携版压制软件带集成环境</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ted423/Simple-x264-x265-Launcher-with-vapoursynth-protable">https://github.com/ted423/Simple-x264-x265-Launcher-with-vapoursynth-protable</a></p>
<p>VS集成环境(其他人维护，脚本可能不太全，ffms2等版本存在已知issue)</p>
<p><a target="_blank" rel="noopener" href="https://github.com/theChaosCoder/vapoursynth-portable-FATPACK">https://github.com/theChaosCoder/vapoursynth-portable-FATPACK</a></p>
<h4 id="基础软件"><a href="#基础软件" class="headerlink" title="基础软件"></a>基础软件</h4><ul>
<li><strong><a target="_blank" rel="noopener" href="https://mediaarea.net/en/MediaInfo/Download/Windows">Mediainfo</a></strong> &#x3D;:媒体信息检查软件，查看片源以及压制信息使用。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.fosshub.com/MKVToolNix.html">MKVToolNix</a></strong>: mkv混流软件，也能实现以下基本的视频分割。</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/SubtitleEdit/subtitleedit/releases">SubtitleEdit</a></strong>: 字幕编辑软，可以实现ORC等功能。</li>
<li><strong><a target="_blank" rel="noopener" href="http://rationalqm.us/dgdemux/dgdemux.html">DGDemux</a></strong>: Demux 软件，目前作为默认标准的Demux软件</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.videohelp.com/software/eac3to">eac3to</a></strong>: <strong><a target="_blank" rel="noopener" href="https://github.com/ted423/FXXS-Encode-Guide/issues/14">存在已知Issue</a><strong>音轨转码编辑软件，也可实现Demux等功能。推荐使用</strong>eac3to with UsEac3to</strong>版本，并应包含一些对应的其他转换格式插件。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.videohelp.com/software/BDInfo">BDinfo</a></strong>: 蓝光原盘信息检测分析软件。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.videolan.org/index.zh.html">VLC</a></strong>: 能播放蓝光菜单，辅助确认音轨字幕章节信息</li>
</ul>
<p>基础部分软件直接使用或者安装即可。<br>AVS和VS为两种方向，推荐选VS</p>
<p>AVS相关教程Archive</p>
<h4 id="VapourSynth环境"><a href="#VapourSynth环境" class="headerlink" title="VapourSynth环境"></a>VapourSynth环境</h4><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.vapoursynth.com/doc/">官方文档</a></p>
</blockquote>
<p>VapourSynth是基于python编写新一代的视频处理工具，解决了许多AVS遗留的问题，显著提高了运行速度。</p>
<p>**<a target="_blank" rel="noopener" href="https://www.python.org/">Python</a>**：安装VS之前必须装好Python环境，不同VS版本要求的Python版本不同，下载安装前请先看好所需要的Python版本。安装时候必须选择 <em>Add Python to PATH</em> !!</p>
<p>**<a target="_blank" rel="noopener" href="http://www.vapoursynth.com/">VapourSynth</a>**：VapourSynth的主体安装程序，安装过程推荐安装所有推荐内容。除了安装位置外推荐使用默认设置。安装完后只包括主程序，以及官方的自带的插件，VS使用过程需要大量的插件以及脚本：主要分为 <strong>Script(.py)脚本</strong> 和 <strong>Plugins(.dll)插件</strong> 两个部分。安装插件脚本，需要将对应文件放入对应目录，目录在官方文档内有详细介绍。在Windows下官方提供了方便的下载管理。下文对于使用到部分将会介绍。</p>
<p>请注意脚本主要是 Python 环境，Python 版本兼容，通过 import 加载，而dll加载与VS本身，是需要考虑系统兼容，通过 core.XXX 加载，很多插件没有 Release Linux 版本，所以 Linux 环境可能会有部分插件需要自己想办法编译或者没法编译。</p>
<p><strong>口语环境里，很多人会把脚本也叫成插件，但自己注意区分，以免造成混淆</strong></p>
<p>VapourSynth 文档中列出了放置插件的路径。</p>
<p>Windows 的推荐路径<code>&lt;AppData&gt;\VapourSynth\plugins32</code> 或 <code>&lt;AppData&gt;\VapourSynth\plugins64</code>。Unix 用户可以创建一个配置文件来指定路径。</p>
<p>VapourSynth的Python脚本应该放在你的Python site-packages文件夹中。在 Arch Linux上，位于 <code>/usr/lib64/Python3.*/sitepackages/</code>。Windows 用户可以在本地AppData文件夹【译者注：即<code>C:\Users\&lt;用户名&gt;\AppData\Local</code>】中找到这个文件夹。</p>
<p><strong>需要注意的是 Python 自身也会有个 site-packages 文件夹，注意不要放错位置或者混放，可能会造成不知道加载了什么东西的问题</strong></p>
<p>**<a target="_blank" rel="noopener" href="https://github.com/theChaosCoder/VSRepoGUI/releases">VSRepoGUI</a>**：官方提供了方便的下载管理插件以及脚本的GUI界面，下载解压后点开后即可使用，推荐放在VS的安装目录内。</p>
<img src="/Picture/VSRepoGUI.png" alt="image-20200209025555494" style="zoom:80%;" />

<p>通过软件可以查看对应的VS安装信息和脚本插件的所在位置，同时可以实现对插件的脚本安装、更新和卸载，软件插件安装位置，再右上角可以快速点开。在Windows下推荐本软件进行维护插件和脚本。</p>
<p>VapourSynth 编辑器</p>
<ul>
<li>VapourSynth Editor <a target="_blank" rel="noopener" href="https://github.com/YomikoR/VapourSynth-Editor/releases/tag/r19-mod-5.1">推荐用YomikoR的mod版本</a></li>
<li>Yuuno</li>
<li>VapourSynth Preview</li>
<li>AvsPmod(长期不更新)</li>
</ul>
<p><strong>VapourSynth Editor</strong>：VS Editor是目前较为广泛使用的VS编辑器(目前会使用Mod版本)。下载后，直接解压即可使用。第一次使用时候，需要配置VapourSynth文件的位置。VS plugins paths 可以是用VSRepoGUI中的路径进行查看。</p>
<img src="/Picture/VS Editor.png" alt="image-20200210015648555" style="zoom: 88%;" />

<p><strong>独立版本</strong></p>
<p><strong>Yuuno</strong> 是 Jupyter 记事本的一个扩展，允许你编辑和导出 VapourSynth 脚本。你可以通过以下代码来安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install yuuno</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yuuno jupyter install</span></span><br></pre></td></tr></table></figure>

<p>注意你需要安装 Jupyter 或 Jupyter Lab。</p>
<p><strong>VapourSynth Preview</strong> 需要一个单独的文本编辑器或 IDE 来编写脚本，这使得它对那些不喜欢 VSEdit 中内置编辑器的人来说非常有用。<br>AvsPmod是用于 AviSynth 的编辑器，但它也支持 VapourSynth。 </p>
<p>它们都有各自的优点和缺点，但对于新手来说，我更推荐 VSEdit 进行本地编辑，而希望在服务器上也能够写脚本的用户，更推荐 Yuuno。这是因为 Jupyter 只需要少量配置就可以远程使用。建议 Yuuno 用户试试使用 Jupyter Lab 替代 Jupyter。</p>
<p>此处举例两者最大的差别：</p>
<p>VSEdit</p>
<ul>
<li>不需要保持浏览器开启</li>
<li>内置基准和编码工具</li>
<li>通过CTRL + SHIFT + 方向键轻松浏览视频</li>
<li>更稳定</li>
<li>几乎无需二次开发</li>
<li>大多数PT用户在使用它，因此它可能更容易获得帮助与支持</li>
<li>VapourSynth 特有的语法高亮及输入建议</li>
<li>允许你存储片段和模板</li>
</ul>
<p>Yuuno</p>
<ul>
<li>非常易于远程使用</li>
<li>可以通过 iPython magic 轻松导出</li>
<li>更好的比较工具，通过使用<code>%%vspreview clipa --diff clipb</code> ⇒ 实现鼠标悬停即可预览更改效果</li>
<li>程序不太成熟，因此更可能发生崩溃</li>
<li>允许你在一个 Jupyter 编辑器中处理和导出多个脚本</li>
</ul>
<h4 id="压制工具"><a href="#压制工具" class="headerlink" title="压制工具"></a>压制工具</h4><p>使用压制工具大部分核心都是x264和x265(x265如无必要不在重复)。本人推荐压制软件功能越为简单越好，推荐2个使用，适合新手的**<a target="_blank" rel="noopener" href="https://github.com/lordmulder/Simple-x264-Launcher">Simple x264&#x2F;x265 Launcher</a><strong>以及适合有经验的纯命令行（CLI）的</strong><a target="_blank" rel="noopener" href="https://www.videohelp.com/software/x264-Encoder">x264.exe</a>和<a target="_blank" rel="noopener" href="https://www.videohelp.com/software/x265-Encoder">x265.exe</a>**。Simple下载安装即可使用，本教程将以此为基础进行讲解。工具需要简单的设置，推荐log文件保存等设置，根据个人习惯修改。</p>
<p><img src="/Picture/Simple.png" alt="image-20200210024626480"></p>
<blockquote>
<p>大部分压制组要求，压制工具要求及时更新，使用最新版的压制工具。</p>
</blockquote>
<h2 id="压制步骤"><a href="#压制步骤" class="headerlink" title="压制步骤"></a>压制步骤</h2><h3 id="1-压制源分析"><a href="#1-压制源分析" class="headerlink" title="1.压制源分析"></a>1.压制源分析</h3><p>要想做一个较为高质量作品，应采用最好的来源进行压制。HDR电影来源较为单一，4k的原盘和Remux资源为主，版本较少能选择不多。SDR目前可用压制版本较多，各个发行商的在不同时期也发行过不同蓝光版本，随着web的兴起，AZ和NF也都发布了较高码率的4k的sdr版本，所以在SDR压制时，需要对于来源进行对比，选取最为高质量的来源进行压制。对于蓝光原盘与remux两者相同时候，推荐使用Remux的更为方便。</p>
<p>对于原盘使用 <strong>BDInfo</strong> 检查原盘信息，查看原盘主要视频对应播放列表。对于复杂原盘，可能出现多版本混合的情况，需要确定所需要版本对应的MPLS，并确定原盘的主要码率 。在压制前推荐进行分离提取(Demux)后再进行压制。</p>
<img src="/Picture/BDInfo.png" alt="BDInfo" style="zoom:95%;" />

<h3 id="2-分离提取-Demux-与音频转换"><a href="#2-分离提取-Demux-与音频转换" class="headerlink" title="2.分离提取(Demux)与音频转换"></a>2.分离提取(Demux)与音频转换</h3><p>见<a target="_blank" rel="noopener" href="https://github.com/ted423/FXXS-Encode-Guide/blob/main/2.%20Tools/1.%20Demux%26Remux.md">Demux&amp;Remux</a>以及<a target="_blank" rel="noopener" href="https://github.com/ted423/FXXS-Encode-Guide/tree/main/3.%20Audio">Audio</a></p>
<h3 id="3-输入脚本编写"><a href="#3-输入脚本编写" class="headerlink" title="3.输入脚本编写"></a>3.输入脚本编写</h3><p>压制前一般需要对片源就行处理，一般包括去除黑边、修复脏边脏线、去除片源的一些问题等，并且在压制时一般需要进行部分压制测试，也需使用脚本进行实现。本节将对介绍压制中的最基本脚本的编写，分为VS和AVS两个部分。编写脚本使用对应的编辑器较为方便。以及基础例子如下</p>
<h5 id="1-AVS例子"><a href="#1-AVS例子" class="headerlink" title="1).AVS例子"></a>1).AVS例子</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FFVideoSource(<span class="string">&quot;J:\BluryBD\After.the.Storm.2016.BluRay.Remux.1080p.AVC.TrueHD.5.1-HiFi.mkv&quot;</span>)</span><br><span class="line">Crop(<span class="number">0</span>, <span class="number">20</span>, -<span class="number">0</span>, -<span class="number">22</span>)</span><br><span class="line">FillBorder(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">bbmod(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">128</span>,<span class="number">21</span>)</span><br><span class="line">Z_Spline36Resize(<span class="number">1280</span>, <span class="number">692</span>,dither=<span class="string">&quot;error_diffusion&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="2-VS例子"><a href="#2-VS例子" class="headerlink" title="2).VS例子"></a>2).VS例子</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vapoursynth <span class="keyword">as</span> vs</span><br><span class="line"><span class="comment">#import kagefunc as kgf</span></span><br><span class="line"><span class="keyword">import</span> fvsfunc <span class="keyword">as</span> fvf</span><br><span class="line"><span class="keyword">import</span> havsfunc <span class="keyword">as</span> haf</span><br><span class="line"><span class="keyword">import</span> vsTAAmbk <span class="keyword">as</span> taa</span><br><span class="line"><span class="comment">#import mvsfunc as mvf</span></span><br><span class="line"><span class="comment">#import muvsfunc as muf</span></span><br><span class="line"><span class="comment">#import nnedi3_resample as nnrs</span></span><br><span class="line"><span class="comment">#import nnedi3_rpow2 as nnrp</span></span><br><span class="line"><span class="keyword">import</span> awsmfunc <span class="keyword">as</span> awf</span><br><span class="line"><span class="comment">#import vsscale</span></span><br><span class="line"><span class="keyword">import</span> vsutil</span><br><span class="line"><span class="comment">#导入相关函数(上面导入的很多范例脚本中没有使用，不过去交错那用到了haf),awsmfunc早期包没包含，故先注释掉</span></span><br><span class="line"><span class="comment">#core = vs.core 在R55 API4及之后版本使用，早期版本可以使用vs.get_core()</span></span><br><span class="line"><span class="comment">#core = vs.get_core()</span></span><br><span class="line">core = vs.core</span><br><span class="line"><span class="comment">#请依据自己内存调整(单位MB)</span></span><br><span class="line">core.max_cache_size = <span class="number">27384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载片源输入即为16bit色深</span></span><br><span class="line">src = core.lsmas.LWLibavSource(source=<span class="string">r&quot;J:\BluryBD\After.the.Storm.2016.BluRay.Remux.1080p.AVC.TrueHD.5.1-HiFi.mkv&quot;</span>,<span class="built_in">format</span>=<span class="string">&quot;yuv420p16&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种加载片源</span></span><br><span class="line"><span class="comment">#src = core.ffms2.Source(source=r&#x27;J:\BluryBD\After.the.Storm.2016.BluRay.Remux.1080p.AVC.TrueHD.5.1-HiFi.mkv&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通常来说，有些比较特殊的片源可能在ffms2或lsmas下会有不正常的表现或者报错，故有时候需要更换使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#处理前调整为16bit色深，可以降低运算带来的损失，lsmas不需要这个步骤</span></span><br><span class="line"><span class="comment">#src = fvf.Depth(src, 16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切边</span></span><br><span class="line">src=core.std.Crop(src, left=<span class="number">0</span>, right=<span class="number">0</span>, top=<span class="number">20</span>, bottom=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#脏边处理相关</span></span><br><span class="line"><span class="comment">#FillBorders基本是复制一条或几条线，作为填充，在任何情况下都不建议超过一条使用</span></span><br><span class="line"><span class="comment">#src = core.fb.FillBorders(src, 0, 1, 0, 0, mode=&quot;fillmargins&quot;)</span></span><br><span class="line"><span class="comment">#src = core.edgefixer.Continuity(src,left=4, right=4, top=0, bottom=0)</span></span><br><span class="line"><span class="comment">#src = awf.fb(src, top=1,bottom=1)</span></span><br><span class="line"><span class="comment">#如果边缘呈灰色，awf.fb 可以填充 luma&amp;chroma</span></span><br><span class="line"><span class="comment">#src = awf.bbmod(src,left=3, right=6, top=10, bottom=4, thresh=30, blur=20)</span></span><br><span class="line"><span class="comment">#对于边缘本身不是正常画面的，可以接一下bbmode，但请注意，严禁乱用，具体参数请看Pro mit 翻译的AHD压制指南(Others里)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#AutoDeblock(请在指导下使用)</span></span><br><span class="line"><span class="comment">#src = fvf.AutoDeblock(src)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将分辨率（压制为720p）</span></span><br><span class="line"><span class="comment">#src=core.resize.Spline36(src, 1280, 692)</span></span><br><span class="line"><span class="comment">#另一种缩小算法,gamma是HDR才需要开启</span></span><br><span class="line"><span class="comment">#src = muf.SSIM_downsample(src, 1280, 692, use_fmtc=False,gamma=True)</span></span><br><span class="line"><span class="comment">#src =vsscale.scale.ssim_downsample(src, width=None, height=720)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#去交错(正常不需要使用)</span></span><br><span class="line"><span class="comment">#src  = haf.QTGMC(src, Preset=&quot;slow&quot;, TFF=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去锯齿</span></span><br><span class="line"><span class="comment">#src = taa.TAAmbk(src, aatype=-3, preaa=-1, strength=0, mtype=2, opencl=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#转为10bit再输出，x265一般压制为10bit,x264为8bit</span></span><br><span class="line"><span class="comment">#之前得降bit函数</span></span><br><span class="line"><span class="comment">#src = fvf.Depth(src, 10)</span></span><br><span class="line"></span><br><span class="line">src = vsutil.depth(src, <span class="number">10</span>, dither_type=<span class="string">&#x27;error_diffusion&#x27;</span>)</span><br><span class="line">src.set_output()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips：</p>
<p>1.修复脏边脏线以及去色带等属于进阶部分，将单独介绍</p>
</blockquote>
<p>VS由C++编写的核心库和允许创建视频脚本的Python模块组成,脚本部分作为Python模块实现，因此脚本完全使用Python语法</p>
<p>看这里以便于理解vpy写法以及含义</p>
<p>Python 文档<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/reference/index.html">https://docs.python.org/zh-cn/3.9/reference/index.html</a></p>
<p>VS文档<a target="_blank" rel="noopener" href="http://www.vapoursynth.com/doc/pythonreference.html">http://www.vapoursynth.com/doc/pythonreference.html</a></p>
<p>其中最前面的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import vapoursynth as vs</span><br><span class="line">import kagefunc as kgf</span><br><span class="line">import fvsfunc as fvf</span><br><span class="line">import havsfunc as haf</span><br><span class="line">import vsTAAmbk as taa</span><br><span class="line">import mvsfunc as mvf</span><br><span class="line">import muvsfunc as muf</span><br><span class="line">import nnedi3_resample as nnrs</span><br><span class="line">import nnedi3_rpow2 as nnrp</span><br><span class="line">#import awsmfunc as awf</span><br></pre></td></tr></table></figure>

<p>就是 python 的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/tutorial/modules.html">模块&#x2F;modules</a> 的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/reference/import.html">导入&#x2F;import</a></p>
<h4 id="1-片源载入"><a href="#1-片源载入" class="headerlink" title="(1).片源载入"></a>(1).片源载入</h4><p>载入片源需要使用对应的解码器，<strong>ffm2</strong>(ffmpeg)是目前脚本广泛使用的解码器，支持格式较为广发，其第一次载入时需要进行全片的检索。</p>
<h5 id="1-AVS语法"><a href="#1-AVS语法" class="headerlink" title="1).AVS语法"></a>1).AVS语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FFVideoSource(<span class="built_in">str</span> filePath) <span class="comment">#指定文件的路径</span></span><br></pre></td></tr></table></figure>

<h5 id="2-VS语法"><a href="#2-VS语法" class="headerlink" title="2).VS语法"></a>2).VS语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src = core.ffms2.Source(<span class="built_in">str</span> source) <span class="comment">#指定文件的路径</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:</p>
<p>1.右键可以直接选择插入文件完整路径。</p>
<p>2.首次执行载入预览会卡死，需要等待一定时间。</p>
<ol start="3">
<li></li>
</ol>
</blockquote>
<h4 id="2-切除边缘"><a href="#2-切除边缘" class="headerlink" title="(2).切除边缘"></a>(2).切除边缘</h4><h5 id="1-avs语法"><a href="#1-avs语法" class="headerlink" title="1).avs语法"></a>1).avs语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crop(clip, <span class="built_in">int</span> left=<span class="number">0</span>,<span class="built_in">int</span> top=<span class="number">0</span>,<span class="built_in">int</span> -right=<span class="number">0</span>,<span class="built_in">int</span> -bottom=<span class="number">0</span>) <span class="comment">#切割必须为偶数，right与bottom为负数</span></span><br></pre></td></tr></table></figure>

<h5 id="2-VS语法-1"><a href="#2-VS语法-1" class="headerlink" title="2).VS语法"></a>2).VS语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip=core.std.Crop(clip, <span class="built_in">int</span> left=<span class="number">0</span>, <span class="built_in">int</span> right=<span class="number">0</span>, <span class="built_in">int</span> top=<span class="number">0</span>, <span class="built_in">int</span> bottom=<span class="number">0</span>) <span class="comment">#切割必须为偶数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:</p>
<p>1.Crop切割方式只能以偶数方式切割，奇数切割属于进阶内容</p>
<p>2.切割奇数边需要使用下节介绍的resize方法</p>
</blockquote>
<h4 id="3-变换大小"><a href="#3-变换大小" class="headerlink" title="(3).变换大小"></a>(3).变换大小</h4><p>$$<br>w<br>$$</p>
<h5 id="1-AVS语法-1"><a href="#1-AVS语法-1" class="headerlink" title="1).AVS语法"></a>1).AVS语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z_Spline36Resize(<span class="built_in">int</span> Width, <span class="built_in">int</span> height, <span class="built_in">int</span> src_left=?, <span class="built_in">int</span> src_top, <span class="built_in">int</span> src_width, <span class="built_in">int</span> src_height, <span class="built_in">str</span> dither) <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h5 id="2-VS语法-2"><a href="#2-VS语法-2" class="headerlink" title="2).VS语法"></a>2).VS语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip = core.resize.Spline36(clip clip, <span class="built_in">int</span> Width, <span class="built_in">int</span> height) <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h4 id="4-抽取测试"><a href="#4-抽取测试" class="headerlink" title="(4).抽取测试"></a>(4).抽取测试</h4><p>压制前使用脚本一般间断抽取共约5k~10K帧进行参数测试，需要在脚本进行抽取。</p>
<h5 id="1-AVS语法-2"><a href="#1-AVS语法-2" class="headerlink" title="1).AVS语法"></a>1).AVS语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectRangeEvery(<span class="built_in">int</span> every, <span class="built_in">int</span> length, <span class="built_in">int</span> offset) <span class="comment">#every为间隔，length为长度，offset为启示帧数</span></span><br></pre></td></tr></table></figure>

<h5 id="2-VS语法-3"><a href="#2-VS语法-3" class="headerlink" title="2).VS语法"></a>2).VS语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select=core.std.SelectEvery(clip[<span class="number">8000</span>:-<span class="number">8000</span>],cycle=<span class="number">4000</span>, offsets=<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">clip= core.std.AssumeFPS(select, fpsnum=clip.fps.numerator, fpsden=clip.fps.denominator)</span><br></pre></td></tr></table></figure>

<h3 id="4-压制测试"><a href="#4-压制测试" class="headerlink" title="4.压制测试"></a>4.压制测试</h3><p>在压制前应该进行参数测试，以便获取较高的压制质量，一般需要确定合理<strong>码率大小(crf)<strong>以及对于</strong>码率分配参数(ap-mode、ap-s、qcomp)<strong>以及</strong>psy</strong>等重要参数进行测试。使用抽取测试代码，大约抽取6k帧进行参数测试，送入<strong>Simple-x264</strong>进行测试。</p>
<h4 id="1-压制参数配置"><a href="#1-压制参数配置" class="headerlink" title="(1).压制参数配置"></a>(1).压制参数配置</h4><p>使用Simple进行压制，其设置如下所示。<strong>在设置界面记得开始log自动保存！！！</strong></p>
<p><img src="/Picture/simplex264.png" alt="image-20200220003824403"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--level <span class="number">4.1</span> --threads <span class="keyword">auto</span> --vbv-bufsize <span class="number">78125</span> --vbv-maxrate <span class="number">62500</span> --colormatrix bt709 --colorprim bt709 --no-mbtree --no-dct-decimate --min-keyint <span class="number">24</span> --me umh --merange <span class="number">48</span> --deblock=<span class="number">-3</span>,<span class="number">-3</span> --ipratio <span class="number">1.3</span> --pbratio <span class="number">1.2</span> --qcomp <span class="number">0.6</span> --aq-mode <span class="number">1</span> --aq-strength <span class="number">0.8</span> --psy-rd <span class="number">1.00</span>:<span class="number">0.00</span></span><br></pre></td></tr></table></figure>

<h4 id="2-CRF测试"><a href="#2-CRF测试" class="headerlink" title="(2).CRF测试"></a>(2).CRF测试</h4><p>CRF测试主要确定合适码率，根据压制目标，确定合理的码率。推荐测试起始CRF为17，根据范围码率以0.5步进进行CRF测试。</p>
<h5 id="合理码率评判方式"><a href="#合理码率评判方式" class="headerlink" title="合理码率评判方式"></a>合理码率评判方式</h5><h6 id="1-追求体积"><a href="#1-追求体积" class="headerlink" title="1.追求体积"></a>1.追求体积</h6><p>压制效果受码率影响很大，在追求体积时，很容易造成欠码的问题。所以要设置合理的码率范围，防止出现因为码率不足导致的质量问题。需要主要检查需要码率较高的场景，例如，复杂的场景和暗的场景。</p>
<p>主要辨别问题有：</p>
<ul>
<li>是否新产生了新的block</li>
<li>复杂的场景的细节是否丢失</li>
<li>是否压出明显的色带</li>
</ul>
<h6 id="2-保证与原盘相似透明度"><a href="#2-保证与原盘相似透明度" class="headerlink" title="2.保证与原盘相似透明度"></a>2.保证与原盘相似透明度</h6><p>前景无损失，背景没有明显损失</p>
<h4 id="3-其他参数"><a href="#3-其他参数" class="headerlink" title="(3).其他参数"></a>(3).其他参数</h4><blockquote>
<p>本部分十分建议进行，但是对于一些压制组不是强制要求。可以编写脚本进行批量测试</p>
</blockquote>
<p>确定合理的码率后，切换2-pass方式使用预计码率，采用单一变量方式进行参数测试，每次测试只改变一个参数，每个参数推荐测试范围如下：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">真人类型</th>
<th align="center">步进</th>
</tr>
</thead>
<tbody><tr>
<td align="center">qcomp</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="4-最终CRF测试"><a href="#4-最终CRF测试" class="headerlink" title="(4).最终CRF测试"></a>(4).最终CRF测试</h4><p>在新参数下，进行最终使用的crf测试。</p>
<h4 id="5-压制对比脚本编写"><a href="#5-压制对比脚本编写" class="headerlink" title="(5).压制对比脚本编写"></a>(5).压制对比脚本编写</h4><h5 id="1-avs语法-1"><a href="#1-avs语法-1" class="headerlink" title="1).avs语法"></a>1).avs语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入压制使用的脚本文件，并添加帧信息与名字</span></span><br><span class="line">a=<span class="keyword">import</span>(<span class="string">&quot;C:\Path\To\source.avs&quot;</span>).subtitle(<span class="string">&quot;Source&quot;</span>, align=<span class="number">9</span>).ffinfo(framenum=true,frametype=true,cfrtime=false,vfrtime=false,version=false,cropping=false,colorrange=false,colorspace=false,sar=false) </span><br><span class="line"><span class="comment"># 导入压制后的对比的视频文件</span></span><br><span class="line">b=ffvideosource(<span class="string">&quot;C:\Path\To\b.mkv&quot;</span>).subtitle(<span class="string">&quot;b&quot;</span>, align=<span class="number">9</span>).ffinfo(framenum=true,frametype=true,cfrtime=false,vfrtime=false,version=false,cropping=false,colorrange=false,colorspace=false,sar=false)</span><br><span class="line"><span class="comment"># 其他的压制文件</span></span><br><span class="line">c=ffvideosource(<span class="string">&quot;C:\Path\To\c.mkv&quot;</span>).subtitle(<span class="string">&quot;c&quot;</span>, align=<span class="number">9</span>).ffinfo(framenum=true,frametype=true,cfrtime=false,vfrtime=false,version=false,cropping=false,colorrange=false,colorspace=false,sar=false)</span><br><span class="line"><span class="comment"># 交错视频文件</span></span><br><span class="line">interleave(a,b)</span><br></pre></td></tr></table></figure>

<h5 id="2-VS语法-4"><a href="#2-VS语法-4" class="headerlink" title="2).VS语法"></a>2).VS语法</h5><p><strong>下面的代码大部分已经不能在最新的VS里使用，仅作参考，请使用 awf 以及 Scrips 里的 snap</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vapoursynth <span class="keyword">as</span> vs</span><br><span class="line">core = vs.get_core()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成帧信息，并打入标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FrameInfo</span>(<span class="params">clip, title,</span></span><br><span class="line"><span class="params">              style=<span class="string">&quot;sans-serif,20,&amp;H00FFFFFF,&amp;H000000FF,&amp;H00000000,&amp;H00000000,0,0,0,0,100,100,0,0,1,2,0,7,10,10,10,1&quot;</span></span>):</span><br><span class="line">    <span class="keyword">import</span> functools</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FrameProps</span>(<span class="params">n, clip</span>):</span><br><span class="line">        clip = core.sub.Subtitle(clip, <span class="string">&quot;Frame &quot;</span> + <span class="built_in">str</span>(n) + <span class="string">&quot; of &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">            clip.num_frames) + <span class="string">&quot;\nPicture type: &quot;</span> + clip.get_frame(n).props._PictType.decode(), style=style)</span><br><span class="line">        <span class="keyword">return</span> clip</span><br><span class="line"></span><br><span class="line">    clip = core.std.FrameEval(clip, functools.partial(FrameProps, clip=clip))</span><br><span class="line">    clip = core.sub.Subtitle(clip, [<span class="string">&#x27;\n \n \n&#x27;</span> + title], style=style)</span><br><span class="line">    <span class="keyword">return</span> clip</span><br><span class="line"></span><br><span class="line"><span class="comment"># VS editor输出显示bug，对于压制后的文件需要进行，进行处理。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outfix</span>(<span class="params">clip</span>):</span><br><span class="line">	encode = core.std.SetFrameProp(clip,prop=<span class="string">&quot;_Matrix&quot;</span>,delete=<span class="literal">True</span>)</span><br><span class="line">	encode = core.std.SetFrameProp(encode,prop=<span class="string">&quot;_Transfer&quot;</span>,delete=<span class="literal">True</span>)</span><br><span class="line">	encode = core.std.SetFrameProp(encode,prop=<span class="string">&quot;_Primaries&quot;</span>,delete=<span class="literal">True</span>)</span><br><span class="line">	<span class="keyword">return</span> encode</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------用于压制脚本的滤镜部分（例子）----------------#</span></span><br><span class="line"><span class="comment">#复制自己脚本出了导入，和输出部分内容</span></span><br><span class="line">video = core.ffms2.Source(source=<span class="string">r&#x27;/Users/hujingyu/Encode/Paris.Texas.1984.1080p.BluRay.Remux.AVC.DTS-HD.MA.5.1-PmP.mkv&#x27;</span>)</span><br><span class="line">video=core.std.Crop(video,<span class="number">64</span>,<span class="number">64</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">select=core.std.SelectEvery(video[<span class="number">8000</span>:-<span class="number">8000</span>],cycle=<span class="number">4000</span>, offsets=<span class="built_in">range</span>(<span class="number">80</span>))</span><br><span class="line">video= core.std.AssumeFPS(select, fpsnum=video.fps.numerator, fpsden=video.fps.denominator)</span><br><span class="line"><span class="comment">#-------------用于压制脚本的滤镜部分----------------#</span></span><br><span class="line">video=FrameInfo(video,<span class="string">&quot;source&quot;</span>)<span class="comment"># 标记信息</span></span><br><span class="line"><span class="comment">#-------------encode文件-------------------------#</span></span><br><span class="line">encode=core.ffms2.Source(source=<span class="string">r&quot;/whalehu/Encode/encode.mkv&quot;</span>) <span class="comment"># 载入视频</span></span><br><span class="line">encode=FrameInfo(encode,<span class="string">&quot;encode&quot;</span>) <span class="comment"># 标记信息</span></span><br><span class="line">encode=outfix(encode)<span class="comment"># 输入修复</span></span><br><span class="line"></span><br><span class="line">out = core.std.Interleave([video,encode]) <span class="comment"># 交叉帧</span></span><br><span class="line">out.set_output()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-正式压制"><a href="#5-正式压制" class="headerlink" title="5.正式压制"></a>5.正式压制</h3><p>将压制脚本中的测试抽帧代码注释掉，进行正式压制。</p>
<blockquote>
<p>清晰度越高需要的时间越长，推荐使用较低的分辨率入门</p>
</blockquote>
<h3 id="6-封装"><a href="#6-封装" class="headerlink" title="6.封装"></a>6.封装</h3><p>封装是将所有素材合成一个mkv的视频文件，封装是一个很简单的工作，没有技术难点，但是封装的好坏会对压制作品评价很为重要，封装主要是认真。这里主要介绍被广泛接受的封装细节，不同压制组对这个有具体的细节要求。</p>
<p>一般封装主要注意以及下内容：</p>
<ul>
<li><p>视频、音轨和字幕是否匹配</p>
</li>
<li><p>音轨和字幕是否设置了正确的语言标签</p>
</li>
<li><p>需要标准命名的音轨是否正确</p>
</li>
<li><p>章节信息和标题是否添加并正确命名</p>
</li>
<li><p>正确命名文件标题</p>
</li>
</ul>
<blockquote>
<p>文件标题并不是文件名！！！一般主要为IMDB的英文标题并可以添加小组信息</p>
<p>原盘若没有章节信息，推荐5-10min间隔生成章节点</p>
</blockquote>

                
            </div>
        </div>
    </div>
    
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2024-08-14T10:57:48.315Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2024-08-14</a>
                </time>
                
                
                
            </span>
            
            
                <span class="pull-right">
                    <a class="read-more" href="/%E5%8E%8B%E5%88%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="评论">评论<i class="fa fa-chevron-circle-right"></i></a>
                </span>
            

        </footer>
    
</article>

    

    
    
        <article class="kratos-hentry kratos-entry-border clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-status">
        
            <i class="fa fa-refresh"></i>
        
        <div class="kratos-status-inner">
            <div class="kratos-status-content" itemprop="articleBody">
                
                    <h1 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a>Linux工具</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a target="_blank" rel="noopener" href="https://github.com/gzycode39/docker-vapoursynth-yuuno/">https://github.com/gzycode39/docker-vapoursynth-yuuno/</a></p>
<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><h3 id="BDInfoCLI-ng"><a href="#BDInfoCLI-ng" class="headerlink" title="BDInfoCLI-ng"></a>BDInfoCLI-ng</h3><p><a target="_blank" rel="noopener" href="https://github.com/zoffline/BDInfoCLI-ng">https://github.com/zoffline/BDInfoCLI-ng</a></p>
<p><code>docker run --rm -it -v &lt;BD_PATH&gt;:/mnt/bd -v &lt;REPORT_DEST&gt;:/mnt/report zoffline/bdinfocli-ng /mnt/bd /mnt/report</code> (iso需要挂载后再扫)</p>
<h2 id="Demux-x2F-Remux"><a href="#Demux-x2F-Remux" class="headerlink" title="Demux&#x2F;Remux"></a>Demux&#x2F;Remux</h2><h3 id="tsMuxer"><a href="#tsMuxer" class="headerlink" title="tsMuxer"></a>tsMuxer</h3><p><a target="_blank" rel="noopener" href="https://github.com/justdan96/tsMuxer">https://github.com/justdan96/tsMuxer</a></p>
<h3 id="mkvtoolnix"><a href="#mkvtoolnix" class="headerlink" title="mkvtoolnix"></a>mkvtoolnix</h3><p><a target="_blank" rel="noopener" href="https://mkvtoolnix.download/downloads.html">https://mkvtoolnix.download/downloads.html</a><br>注意章节编辑器名称模板改成英文 <code>Chapter &lt;NUM:2&gt;</code></p>
<h3 id="DGDemux"><a href="#DGDemux" class="headerlink" title="DGDemux"></a>DGDemux</h3><p><a target="_blank" rel="noopener" href="http://rationalqm.us/dgdemux/dgdemux.html">http://rationalqm.us/dgdemux/dgdemux.html</a></p>
<h2 id="Encode"><a href="#Encode" class="headerlink" title="Encode"></a>Encode</h2><h3 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h3><p><a target="_blank" rel="noopener" href="https://ffmpeg.org/ffmpeg-all.html">https://ffmpeg.org/ffmpeg-all.html</a></p>
<p>范例</p>
<p><code>ffmpeg -i 1.dts -c:a flac -compression_level 8 1.flac</code></p>
<p><code>ffmpeg -i 1.mkv -map 0:1  -c:a flac -compression_level 8 chi.flac</code></p>
<p><code>ffmpeg  -v quiet -ss 00:23:00 -i file  -vcodec png -vframes 1 -pix_fmt rgb24 -y ~/filename.png</code></p>

                
            </div>
        </div>
    </div>
    
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2024-07-31T10:42:27.376Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2024-07-31</a>
                </time>
                
                
                
            </span>
            
            
                <span class="pull-right">
                    <a class="read-more" href="/2.Tools/Linux/" title="评论">评论<i class="fa fa-chevron-circle-right"></i></a>
                </span>
            

        </footer>
    
</article>

    

    
    
        <article class="kratos-hentry clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-entry-border clearfix">
        
        <div class="kratos-entry-post-main">
            
            
            <div class="kratos-entry-post-inner">
                <header class="kratos-entry-header">
                        
                    <h2 class="kratos-entry-title"><a href="/Others/FXXS%E6%96%B0%E6%89%8B%E5%8E%8B%E5%88%B6%E6%B5%81%E7%A8%8B(%E5%8F%82%E8%80%83%EF%BC%8C%E6%9C%AA%E6%A3%80%E6%9F%A5%E5%AE%8C)/" itemprop="mainEntityOfPage"><span itemprop="name headline">FXXS新手压制流程 V1.5</span></a>
                </header>
                <div class="kratos-entry-content">
                    <p itemProp="description">
                        
                            前言越来越多新人加入了压制行列，但新人上手对教程不理解，不熟悉流程，容易踩到许多坑；且大佬们不是24小时在线，新人可能遇到的坑是前人踩过，反复回复相同问题增加了大佬的负担。故写下此指南流程（想了很久还是流程比较贴切），进一步降低教程门...
                        
                    </p>
                </div>
            </div>
        </div>
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2024-07-16T15:23:07.722Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2024-07-16</a>
                </time>
                <a>
                    
                </a>
                
                
            </span>
            <span class="pull-right">
                <a class="read-more" href="/Others/FXXS%E6%96%B0%E6%89%8B%E5%8E%8B%E5%88%B6%E6%B5%81%E7%A8%8B(%E5%8F%82%E8%80%83%EF%BC%8C%E6%9C%AA%E6%A3%80%E6%9F%A5%E5%AE%8C)/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
            </span>
        </footer>
    </div>
</article>
    

    
    
        <article class="kratos-hentry kratos-entry-border clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-status">
        
            <i class="fa fa-refresh"></i>
        
        <div class="kratos-status-inner">
            <div class="kratos-status-content" itemprop="articleBody">
                
                    <h1 id="x265参数解析"><a href="#x265参数解析" class="headerlink" title="x265参数解析"></a>x265参数解析</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/6627144750">https://tieba.baidu.com/p/6627144750</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://x265.readthedocs.io/en/3.1/cli.html">https://x265.readthedocs.io/en/3.1/cli.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://vcb-s.nmm-hd.org/Dark%20Shrine/[VCB-Studio][%E6%95%99%E7%A8%8B10]x265%202.9%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/[VCB-Studio][%E6%95%99%E7%A8%8B10]x265%202.9%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.pdf">https://vcb-s.nmm-hd.org/Dark%20Shrine/[VCB-Studio][教程10]x265%202.9参数设置/[VCB-Studio][教程10]x265%202.9参数设置.pdf</a></p>
</li>
</ul>
<p><strong>请注意，不能确保完全正确</strong></p>
<h2 id="crf-qp"><a href="#crf-qp" class="headerlink" title="crf,qp"></a>crf,qp</h2><p><strong>qp</strong> 电脑认为的恒定画质(但一般不进行设置)</p>
<p><strong>crf</strong> 人眼认为的恒定画质，但是运动时候画质会降低来节省码率</p>
<p>数值越低画质越好。</p>
<p>一般低于等于18可以认为和原画差不多(主观观点)</p>
<h2 id="ctu-lt-64-32-16-gt"><a href="#ctu-lt-64-32-16-gt" class="headerlink" title="ctu &lt;64|32|16&gt;"></a>ctu &lt;64|32|16&gt;</h2><p>分块大小，64速度最慢，32其次</p>
<p>设成32 对于复杂场景压缩压缩率最高，64 对于简单场景压缩压缩率最高</p>
<p>推荐用32因为速度比64快10%，并且画质更好一些</p>
<p>16适合DVD，32适合1080p,64适合4K,720p用16,x265可能就会直接退出</p>
<h2 id="rd-1-6"><a href="#rd-1-6" class="headerlink" title="rd (1-6)"></a>rd (1-6)</h2><p>分析的复杂度，数值越大画质越高，压出来体积越大，5,6非常慢, 默认3.</p>
<h2 id="early-skip"><a href="#early-skip" class="headerlink" title="early-skip"></a>early-skip</h2><p>–early-skip, –no-early-skip</p>
<p>默认开，开了提高压缩速度，关了提高精度，体积小幅度增加</p>
<h2 id="rdoq-level"><a href="#rdoq-level" class="headerlink" title="rdoq-level"></a>rdoq-level</h2><p>RDOP [rate-distortion optimized quantization] (率失真优化量化)</p>
<p>默认0,关闭，预设slow时候默认开启。(preset placebo 似乎也还是2)</p>
<p>x265最重要的参数，没有之一，开了能有助于保存细节，当然会有更大文件体积。关闭可以提高压缩速度，看起来会轻度模糊。开启掉速度30%以上，推荐舍弃其他参数，也要开启这个。</p>
<p>设成 1 时候 看起来效果最好，但是体积会大30%以上</p>
<p>设成 2 时候 效果略差，体积只会小幅度增加，推荐使用2</p>
<h2 id="psy-rd-amp-psy-rdoq"><a href="#psy-rd-amp-psy-rdoq" class="headerlink" title="psy-rd &amp; psy-rdoq"></a>psy-rd &amp; psy-rdoq</h2><p>都是Psycho-visual options的参数</p>
<p>具体见<a target="_blank" rel="noopener" href="https://x265.readthedocs.io/en/latest/cli.html#psycho-visual-options">https://x265.readthedocs.io/en/latest/cli.html#psycho-visual-options</a></p>
<p>这两者都会影响码率(经测试，开高psy-rdoq到5所增加的码率通过crf来给画面反而效果更好)</p>
<p>psy-rd 默认 2.0有些高，建议开到1.5，开高反而降低画质(不过这种仅适用高还原度压制，如果希望节省码率，这个可能要再试试)</p>
<p>psy-rdoq 一直用1一般就好，开高了保留噪点，画面本身却会变差</p>
<p>一些测试见Compare</p>
<h2 id="tu-intra-depth-lt-1-4-gt-tu-inter-depth-lt-1-4-gt"><a href="#tu-intra-depth-lt-1-4-gt-tu-inter-depth-lt-1-4-gt" class="headerlink" title="tu-intra-depth &lt;1..4&gt; tu-inter-depth &lt;1..4&gt;"></a>tu-intra-depth &lt;1..4&gt; tu-inter-depth &lt;1..4&gt;</h2><p>默认1，开高会小幅增加压缩率，但是特别慢 (preset placebo 似乎就是4)</p>
<h2 id="max-tu-size-lt-32-16-8-4-gt"><a href="#max-tu-size-lt-32-16-8-4-gt" class="headerlink" title="max-tu-size &lt;32|16|8|4&gt;"></a>max-tu-size &lt;32|16|8|4&gt;</h2><p>默认32，开低会降低压缩率，并且不会提速，推荐默认</p>
<h2 id="max-merge-lt-1-5-gt"><a href="#max-merge-lt-1-5-gt" class="headerlink" title="max-merge &lt;1..5&gt;"></a>max-merge &lt;1..5&gt;</h2><p>开高小幅度提高压缩率，对速度影响不明显，默认2 (preset placebo 似乎就是5)</p>
<h2 id="me-merange"><a href="#me-merange" class="headerlink" title="me ,merange"></a>me ,merange</h2><p>me 搜索方式，默认hex ，用umh 或star 能小幅度提高压缩率，但是掉速20%</p>
<p>merange 搜索范围，默认57，me设成hex时候，对速度影响不大，但是使用umh或star时候，开高掉速严重</p>
<p>umh比star好</p>
<ol>
<li><p>dia</p>
</li>
<li><p>hex (default)</p>
</li>
<li><p>umh</p>
</li>
<li><p>star</p>
</li>
<li><p>sea</p>
</li>
<li><p>full</p>
</li>
</ol>
<h2 id="subme-默认2"><a href="#subme-默认2" class="headerlink" title="subme 默认2"></a>subme 默认2</h2><p>开高小幅提高压缩率，开低提高压缩速度，5比3慢10%</p>
<p>推荐3</p>
<h1 id="keyint"><a href="#keyint" class="headerlink" title="keyint"></a>keyint</h1><p>最大IDR间隔</p>
<p>关键帧相关，这个将会影响到点击跳转，开高能提升压缩率(但个人不建议随便动他，720对于一般的24p意味着30秒的时间，60p你可以稍微开高点？)</p>
<p>默认250</p>
<h2 id="min-keyint"><a href="#min-keyint" class="headerlink" title="min-keyint"></a>min-keyint</h2><p>最小分组帧数，默认23，推荐改成个位数，提高gop准确度。</p>
<p>小幅度提高压缩率，对压缩速度没影响</p>
<p>min-keyint&#x3D;1 的情况对于一些高速切换的场景会因此要强制1秒内一个IDR帧，造成P或者B等参考帧使用效率降低(换场景了参考的意义已经不大了)。</p>
<p>还有就是这样可以避免一些老旧的设备出现硬解的bug。 - by fch1993</p>
<h2 id="pmode-amp-no-pmode"><a href="#pmode-amp-no-pmode" class="headerlink" title="pmode &amp; no-pmode"></a>pmode &amp; no-pmode</h2><p>并行决策模式</p>
<p>见这里 <a target="_blank" rel="noopener" href="https://github.com/ted423/FXXS-Encode-Guide/issues/16">https://github.com/ted423/FXXS-Encode-Guide/issues/16</a></p>
<p>官方推荐是CPU不饱和才开，编码器将跨多个工作线程分配每个 CU 的分析工作。</p>
<p>但从测试结果看，建议任何情况下都开</p>
<h2 id="rc-lookahead"><a href="#rc-lookahead" class="headerlink" title="rc-lookahead"></a>rc-lookahead</h2><p>预览帧数，默认20</p>
<p>开高可以提高分组(gop)准确度，小幅度提高压缩率，同时小幅度降速，推荐40</p>
<p>crf模式时，rc-lookahead可以提高cutree的准确度（提高画质)</p>
<h2 id="bframes"><a href="#bframes" class="headerlink" title="bframes"></a>bframes</h2><p>最大b帧数量</p>
<p>开高小幅度提高压缩率，默认4，开到8，掉速10%</p>
<p>bframes 开高了会小幅降低画质</p>
<h2 id="cutree"><a href="#cutree" class="headerlink" title="cutree"></a>cutree</h2><p>–no-cutree since this seems to be a poor implementation of mbtree.</p>
<p><del>目前测试是静态场景表现不错，具体可以看<a target="_blank" rel="noopener" href="https://ted423.github.io/Document/Encode/cutree/">https://ted423.github.io/Document/Encode/cutree/</a></del> 不建议开，码率分配存在非常大的问题(有一处分配了31M的码率结果效果还不如一半码率的x264)</p>
<p>doom9 上2020年有人说”在快速移动的场景中，我一直在努力解决丑陋的扭曲（用条带涂抹看起来有点像运动模糊的东西），最后发现 x265 的 CUTree 是罪魁祸首。</p>
<p>关闭它可以解决它，但是当试图在其他场景中保持相同的整体质量时，比特率会爆炸。</p>
<p>有什么方法可以使 CUTree ‘不那么激进’ 或将其设置为 50% 或某些阈值参数吗？”</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>参照帧数量，默认3</p>
<p>开高小幅度提高压缩率，同时小幅度降速，</p>
<p>3和4速度差不多，推荐4</p>
<p>VCB:不过实测 ref 增加在 x265 中作用不明显。建议不超过 6</p>
<h2 id="sao-默认开启"><a href="#sao-默认开启" class="headerlink" title="sao 默认开启"></a>sao 默认开启</h2><p>–sao, –no-sao</p>
<p>设计目的是去振铃(光环现象)，但是细节丰富地方会去掉太多细节，</p>
<p>推荐关闭。</p>
<h2 id="strong-intra-smoothing"><a href="#strong-intra-smoothing" class="headerlink" title="strong-intra-smoothing"></a>strong-intra-smoothing</h2><p>推荐在追求还原度的压制的时候关闭，严重欠码压制时开启(部分情况下，aq2 或者降低 aqs 更为优先)</p>
<p>对关键帧进行平滑处理，看起来挺吓人的，实际上效果不明显，推荐用<code>--no-strong-intra-smoothing</code>关闭，保留细节(来源贴吧 连接1 的帖内说明)</p>
<p><a target="_blank" rel="noopener" href="http://forum.doom9.net/showthread.php?p=1873696">http://forum.doom9.net/showthread.php?p=1873696</a></p>
<p>相关讨论，与贴吧给出的结论不同</p>
<p>个人测试是开的话画面细节丢失，影响蛮大 <del>可能适合低码压制</del></p>
<p>目前测试是在低码压制上会降低块效应(不知道这么说对不对，aqs psy-rdoq开高会导致块变得严重。特别是4K，44Mbps仍然有些欠码，因此4K欠码压制的情况下，这种现象会非常严重，见 <a target="_blank" rel="noopener" href="https://slow.pics/c/uvnpqHrU">https://slow.pics/c/uvnpqHrU</a> 不过这个对比图没有块现象严重的对比，只是用于说明所需码率，因为一个没注意顺手删了)</p>
<h2 id="lookahead-slices"><a href="#lookahead-slices" class="headerlink" title="lookahead-slices"></a>lookahead-slices</h2><p>设成0有助于提高画质，开高有利于lookahead的并行度，</p>
<p>推荐设成0，对压缩速度无影响</p>
<h2 id="deblock-去色块"><a href="#deblock-去色块" class="headerlink" title="deblock 去色块"></a>deblock 去色块</h2><p>要调低 默认太高， 推荐最高调到-1,-1以下，调高了会模糊</p>
<h2 id="qcomp"><a href="#qcomp" class="headerlink" title="qcomp"></a>qcomp</h2><p>运动时候画质 crf开启时候有效</p>
<p>开高提高运动时候画质，开低减少文件体积</p>
<p>推荐0.6-0.7</p>
<h2 id="frame-threads"><a href="#frame-threads" class="headerlink" title="frame-threads"></a>frame-threads</h2><p>帧线程数量，开高提高cpu利用率，开低有利于小幅度提高压缩率</p>
<p>如果cpu能够满载可以考虑调到2，如果不能满载考虑使用默认值</p>
<p>(默认会自动调整)</p>
<h2 id="aq-strength-默认1-0"><a href="#aq-strength-默认1-0" class="headerlink" title="aq-strength 默认1.0"></a>aq-strength 默认1.0</h2><p>低于1.0首先保留边缘，高于1.0优先保留纹理，这个值也要看aq-mode，噪点多的片可以调低这个值，噪点少的片调高这个值</p>
<p>不了解不要乱调这个</p>
<p>VCB:aq-strength 决定了 aq 的强度，一般来说，Anime 的 aq-strength 不用太高（太高了码率也会浪费）。通常，aq-mode&#x3D;1，aq-strength 给 0.8 比较合理；aq-mode&#x3D;2，aq-strength 给 0.9 左右，aq-mode&#x3D;3，aq-strength 给 0.7 左右。</p>
<h1 id="aq-mode"><a href="#aq-mode" class="headerlink" title="aq-mode"></a>aq-mode</h1><p>目前测试在不足码率压制的情况下,aq1可能会导致画面出现一些奇怪的现象，aq2相对画面更好一些，并且不会出现奇妙的画面(不过测试还不够充分)。</p>
<p>在给够码率的情况下(噪点比较重的片)，aq1似乎会好些(可以看战火高码版对比图，不过暂时还没放到公网)</p>
<p>2 x265默认（推荐）</p>
<p>3 暗处增强，避免暗处被压坏，实际上亮的地方码率也会增加30%以上，所以很 浪费码率(不过就压制而言，通常是差不多码率进行比较，因此浪费码率可以通过调高crf解决)</p>
<p>aq-mode 4 :优先保留边缘，噪点很多时候用</p>
<p>VCB:x265 目前有三种 aq 模式。aq-mode 1 是最安全稳定的 aq，适合高码率&#x2F;高画质编码；aq-mode<br>2 相对来说效率最高，适合中低码率的编码；aq-mode 3 对暗场进行加强，适合 8bit 编码防止暗场压烂。一般 10bit编码根据 crf 高低决定 aq 选取，个人建议在 crf &lt;&#x3D; 16 时候使用 aq-mode 1，否则使用 aq-mode 2。注意同 crf下，不同 aq-mode 出来的体积是不一样的，3&gt;1&gt;2。</p>
<p>补充说明，个人在压制黑白噪点片时，aq2产生了比aq1还大的体积，目测在大颗粒噪点的情况下，aq2会比aq1产生更高的码率</p>
<h2 id="rskip-lt-0-1-2-gt"><a href="#rskip-lt-0-1-2-gt" class="headerlink" title="rskip &lt;0|1|2&gt;"></a>rskip &lt;0|1|2&gt;</h2><p>开启提高速度，关闭提高画质，0是关闭，默认1</p>
<p>模式1比0 wmaf 下降0.03左右</p>
<p>模式2比模式1压缩速度要快30%-50%左右，但是压缩率要低</p>
<p>对于平滑画面（噪点比较少）画质优于rskip&#x3D;1，但是噪点比较多画面 画质不如rskip&#x3D;1</p>
<p>rskip&#x3D;2 和ctu&#x3D;64配合不好，同时开启画质压缩率都会下降</p>
<p><del>推荐rskip&#x3D;2 和ctu&#x3D;32配合</del>(我们一般不开)</p>
<h2 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h2><p>–rect, –no-rect</p>
<p>开了小幅度增加压缩率（0%-5%左右 )和画质，有长方形区域时候才有效，否则是空跑，开了掉速30%以上</p>
<p>推荐关闭增加压缩速度。</p>
<p>VCB:通常来说，&lt;&#x3D;1080p 下，rect 基本上没什么作用，amp 是几乎完全没作用，但是这俩都是速度黑洞。因此从效率角度建议关闭，或者至少关闭 amp</p>
<p>个人测试中，1080p开了之后，码率低了一点，画面差了一点</p>

                
            </div>
        </div>
    </div>
    
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2024-07-04T12:14:23.650Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2024-07-04</a>
                </time>
                
                
                
            </span>
            
            
                <span class="pull-right">
                    <a class="read-more" href="/2.Tools/x265%E5%8F%82%E6%95%B0/" title="评论">评论<i class="fa fa-chevron-circle-right"></i></a>
                </span>
            

        </footer>
    
</article>

    

    
    
        <article class="kratos-hentry kratos-entry-border clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-status">
        
            <i class="fa fa-refresh"></i>
        
        <div class="kratos-status-inner">
            <div class="kratos-status-content" itemprop="articleBody">
                
                    <h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><blockquote>
<p>A collection of Encode tools and scripts.</p>
</blockquote>
<h3 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Document</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://code.videolan.org/videolan/x264">x264</a></td>
<td>x264 codec</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/jpsdr/x264">x264-tMod</a></td>
<td>x264 t_mod codec(默认使用)</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://bitbucket.org/multicoreware/x265_git/src">x265</a></td>
<td>x265 codec</td>
<td><a target="_blank" rel="noopener" href="https://x265.readthedocs.io/">Doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/msg7086/x265-Yuuki-Asuna">x265-Yuuki</a></td>
<td>x265-Yuuki codec</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/AOMediaCodec/SVT-AV1">SVT-AV1</a></td>
<td>AV1 codec</td>
<td><a target="_blank" rel="noopener" href="https://github.com/AOMediaCodec/SVT-AV1/tree/master/Docs">Doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://aomedia.googlesource.com/aom/">AOM-AV1</a></td>
<td>AV1 codec</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/fraunhoferhhi/vvenc">vvenc</a></td>
<td>VVC codec</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://ffmpeg.org//">ffmpeg</a></td>
<td>Web Only, Contain SVT-AV1(not the newest code)<br> <a target="_blank" rel="noopener" href="https://github.com/BtbN/FFmpeg-Builds">Win builds by BtbN</a></td>
<td><a target="_blank" rel="noopener" href="https://ffmpeg.org/ffmpeg.html">Doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/nu774/qaac">qaac</a></td>
<td>是基于 Apple 编码器的命令行 AAC&#x2F;ALAC 编码器前端。开源</td>
<td><a target="_blank" rel="noopener" href="https://github.com/nu774/qaac/wiki">Wiki</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://xiph.org/flac/">flac</a></td>
<td>很多现有的编码器会调用libFLAC.dll，但项目长期不放出libFLAC.dll的编译版本，需要自己找别人的编译版本</td>
<td><a target="_blank" rel="noopener" href="https://xiph.org/flac/documentation.html">Doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://opus-codec.org/">opus</a></td>
<td>2019年发布最后一版 1.3.1</td>
<td><a target="_blank" rel="noopener" href="https://opus-codec.org/docs/">Doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.videohelp.com/software/eac3to">eac3to with UsEac3to GUI</a></td>
<td><a target="_blank" rel="noopener" href="https://forum.doom9.org/showthread.php?t=145574">UsEac3to GUI</a> 作者:tebasuna51 <del><a target="_blank" rel="noopener" href="https://forum.doom9.org/showthread.php?t=125966">eac3to</a> 作者:madshi (老版本)</del> <a target="_blank" rel="noopener" href="https://www.rationalqm.us/eac3to/">https://www.rationalqm.us/eac3to/</a> 新版本 <br><br><a target="_blank" rel="noopener" href="https://github.com/ted423/FXXS-Encode-Guide/issues/14">Issue</a></td>
<td><a target="_blank" rel="noopener" href="http://en.wikibooks.org/wiki/Eac3to">Wiki</a></td>
</tr>
</tbody></table>
<h3 id="VS-etc"><a href="#VS-etc" class="headerlink" title="VS etc"></a>VS etc</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Document</th>
<th>etc</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.vapoursynth.com/">VS Official Web</a> \ <a target="_blank" rel="noopener" href="https://github.com/vapoursynth/vapoursynth">VS Github</a></td>
<td>VS</td>
<td><a target="_blank" rel="noopener" href="http://www.vapoursynth.com/doc/index.html">Doc</a></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/YomikoR/VapourSynth-Editor">VapourSynth Editor Modified by YomikoR</a></td>
<td>原版长期未更新，并且存在一些不足,故只放mod版</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://bitbucket.org/gundamftw/vapoursynth-editor-2">VapourSynth Editor 2</a></td>
<td>Untest</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/AmusementClub/vapoursynth-classic">vapoursynth-classic</a></td>
<td>Untest，旨在维护旧版API的一个版本</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/AmusementClub/tools">tool-pack</a></td>
<td>Untest，类似Mediatool的一个项目，不过我一直好奇里面打包了GPL的东西能不能这么发布</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Other-Tool"><a href="#Other-Tool" class="headerlink" title="Other Tool"></a>Other Tool</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Document</th>
<th>etc</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/vcb-s/OKEGui">OKEGui</a></td>
<td>Untest，平时习惯先封装一个，然后通过样板json批量生成再用mkvmerge命令行批量封装</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/YohoYang/VSGUI">VSGUI</a></td>
<td>Untest，类似于MEGUI的VS版本</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Subtitle"><a href="#Subtitle" class="headerlink" title="Subtitle"></a>Subtitle</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/SubtitleEdit/subtitleedit">subtitleedit</a></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Ristellise/AegisubDC">ageisub</a></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/quietvoid/subtitle_tonemap">subtitle_tonemap</a></td>
<td>adjust brightness to PGS subtitle</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/tp7/Sushi">sushi</a></td>
<td>automatic shifter based audio stream</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/kaegi/alass">alass</a></td>
<td>automatic shifter based subtitle&#x2F;audio</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/dyphire/subtitle-convert">subtitle-convert</a></td>
<td>fix subtitle encoding (to UTF-8)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/yuppity/ttml2srt">ttml2srt</a></td>
<td>convert ttml to srt</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/arcusmaximus/YTSubConverter">YTSubConverter</a></td>
<td>convert ytt to ass(or reverse)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/computer045/vtt2ass">vtt2ass</a></td>
<td>convert vtt to ass</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/civodulab/srt2ass">srt2ass</a></td>
<td>convert srt to ass</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/arition/SubRenamer">Subrenamer</a></td>
<td>Rename subtitles for BDRip</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/qwqcode/SubRenamer">SubRenamer</a></td>
<td>番剧字幕文件自动化一键批量重命名（改名）工具</td>
</tr>
</tbody></table>
<h3 id="Dolby"><a href="#Dolby" class="headerlink" title="Dolby"></a>Dolby</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/domyd/mlp">mlp</a></td>
<td>Dovi TrueHD demuxer</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/pcroland/deew">deew</a></td>
<td>DDP maker</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/rixtox/mp4dovi">mp4dovi</a></td>
<td>Dovi in mp4 files</td>
</tr>
</tbody></table>
<h3 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/N3xusHD/EasyCompare">EasyCompare</a></td>
<td>compare snapshot</td>
</tr>
</tbody></table>
<h3 id="Chapter"><a href="#Chapter" class="headerlink" title="Chapter"></a>Chapter</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/tautcony/ChapterTool">ChapterTool</a></td>
<td>chapter create tool</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/fireattack/chapter_converter">chapter_converter</a></td>
<td>convert chapter file formats</td>
</tr>
</tbody></table>
<h3 id="Player"><a href="#Player" class="headerlink" title="Player"></a>Player</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/dyphire/mpv-config/releases">mpv-config</a></td>
<td>mpv pack</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/p/hevc-video-extensions-from-device-manufacturer/9n4wgh0z6vhq">Hevc Video Extensions From Device Manufacturer</a></td>
<td>hevc extension for Windows</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/p/app/9pltg1lwphlf">Dolby Vision Extensions</a></td>
<td>dovi extension for Windows</td>
</tr>
</tbody></table>

                
            </div>
        </div>
    </div>
    
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2024-07-02T11:16:53.372Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2024-07-02</a>
                </time>
                
                
                
            </span>
            
            
                <span class="pull-right">
                    <a class="read-more" href="/2.Tools/Collection/" title="评论">评论<i class="fa fa-chevron-circle-right"></i></a>
                </span>
            

        </footer>
    
</article>

    

    
    
        <article class="kratos-hentry kratos-entry-border clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-status">
        
            <i class="fa fa-refresh"></i>
        
        <div class="kratos-status-inner">
            <div class="kratos-status-content" itemprop="articleBody">
                
                    <p>因为平时注意力不集中，所以这些可能是碎片化的，有空可能会整理。<br>另外人菜，请批判性的理解</p>
<p>（水平问题，自己的脚本就不放出来了）</p>
<p><a target="_blank" rel="noopener" href="https://git.concertos.live/OpusGang/EncodeScripts/src/branch/master/Jin.Roh.1999/SDR.720P-ZQ.vpy">https://git.concertos.live/OpusGang/EncodeScripts/src/branch/master/Jin.Roh.1999/SDR.720P-ZQ.vpy</a></p>
<p>22行开始 对(luma平面 - Y)先降噪。然后STPresso对噪点进行处理之后再打回来。</p>
<hr>
<p>对帧的一些操作</p>
<p><a target="_blank" rel="noopener" href="https://git.concertos.live/OpusGang/EncodeScripts/src/branch/master/A.Silent.Voice.2016/SDR.1080p.D-Z0N3.vpy">https://git.concertos.live/OpusGang/EncodeScripts/src/branch/master/A.Silent.Voice.2016/SDR.1080p.D-Z0N3.vpy</a></p>

                
            </div>
        </div>
    </div>
    
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2023-07-16T11:12:11.011Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2023-07-16</a>
                </time>
                
                
                
            </span>
            
            
                <span class="pull-right">
                    <a class="read-more" href="/3.Code/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C/" title="评论">评论<i class="fa fa-chevron-circle-right"></i></a>
                </span>
            

        </footer>
    
</article>

    

    
    
        <article class="kratos-hentry kratos-entry-border clearfix" itemscope itemtype="https://schema.org/Article">
    <div class="kratos-status">
        
            <i class="fa fa-refresh"></i>
        
        <div class="kratos-status-inner">
            <div class="kratos-status-content" itemprop="articleBody">
                
                    <h1 id="Advanced-HD-Video-Encoding-Guide"><a href="#Advanced-HD-Video-Encoding-Guide" class="headerlink" title="Advanced HD Video Encoding Guide"></a>Advanced HD Video Encoding Guide</h1><p>说明：并非所有内容都是正确的，部分内容仍待完善。</p>
<p>最新的原文地址在<a target="_blank" rel="noopener" href="https://silentaperture.gitlab.io/mdbook-guide/introduction.html">https://silentaperture.gitlab.io/mdbook-guide/introduction.html</a></p>
<p>【译者注：本文为《Advanced HD Video Encoding Guide》老版本的翻译，限制于译者压制与翻译水平均有限，翻译可能产生偏差甚至误导，在此表示歉意。如遇不明之处还请<a target="_blank" rel="noopener" href="https://github.com/FXXS-Encoder/FXXS-Encode-Guide/blob/main/Others/encode_guide_English.pdf">查看原文</a>。同时有些内容随着时间变迁用法有些不同，请读者遇到相关问题时查阅相关内容。】<br>【译者再注：由于所有图片所在图床一起随时间而逝，所有附图均由PDF中提取再经由Photoshop拼接，过程中可能造成些许损失，但应该不影响区分。】</p>
<h2 id="3-视频编码"><a href="#3-视频编码" class="headerlink" title="3 视频编码"></a>3 视频编码</h2><h3 id="3-1-你的第一个脚本"><a href="#3-1-你的第一个脚本" class="headerlink" title="3.1 你的第一个脚本"></a>3.1 你的第一个脚本</h3><p>一个标准并没有额外滤镜的超级基础的 VapourSynth 脚本应该与此类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你使用的是yuuno而不是VSEdit，请取消下一行的注释：</span></span><br><span class="line"><span class="comment">#%load_ext yuuno # 这将告诉Jupyter加载yuuno。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个代码块是针对VSEdit #</span></span><br><span class="line"><span class="keyword">import</span> vapoursynth <span class="keyword">as</span> vs</span><br><span class="line">core = vs.core</span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line">src = core.ffms2.Source(<span class="string">&quot;/path/to/source.mkv&quot;</span>) <span class="comment"># 对于Windows路径, 使用 r&quot;C:\path\to\source.mkv&quot;.</span></span><br><span class="line">out = core.std.Crop(src, top=<span class="number">138</span>, bottom=<span class="number">138</span>) <span class="comment"># 切除黑边是必要操作</span></span><br><span class="line">out.set_output() <span class="comment"># 标记为vspipe输出使用的变量</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-缩放-Resizing"><a href="#3-1-1-缩放-Resizing" class="headerlink" title="3.1.1 缩放(Resizing)"></a>3.1.1 缩放(Resizing)</h4><p>首先请注意，后面会有一个单独的部分来介绍**缩小像素(Descaling)**。而在这，我将解释调整大小的方法以及哪种调整器分别适合什么情况。<br>如果你想调整大小，重要的是不要超过必要的长宽比的改变。如果你要缩小尺寸，首先要搞明白宽度和高度应该是多少。如果你想缩小分辨率到720p，首先要裁剪，然后弄清楚你是缩放至720高还是1280宽。如果是前者，你的宽度应该是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width = <span class="built_in">round</span>(<span class="number">720</span> * src.height / (<span class="number">2</span> * src.width)) * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>对于后者，你会发现高度的代码与其非常相似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="built_in">round</span>(<span class="number">1280</span> * src.width / (<span class="number">2</span> * src.height)) * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用 <strong>awsmfunc</strong>中封装的 <code>cropresize</code> 函数来处理这些计算并调整大小。</p>
<p>现在有多种调整工具可选，其中最主要的有：</p>
<ul>
<li><code>Point</code> 临近点，也被称为临近采样(nearest neighbor resizing)，是最简单的缩放方式，因为除了放大每个像素或缩小时获取周围每个像素的平均值，并没有真正做任何事情。它产生的结果很糟糕，但在放大时不做任何模糊处理，因此它非常适用于放大检查每个像素的值。它也是自我矛盾的，所以你可以用它放大然后再缩小，得到与开始时相同的结果。</li>
<li><code>Bilinear</code> 双线性，缩放处理速度非常快，但会导致非常模糊的结果，并有明显的 <strong>锯齿(aliasing)</strong> 现象。</li>
<li><code>Bicubic</code> 双立方，缩放处理速度同样很快，但也会导致相当模糊的结果和明显的锯齿。你可以在这里修改参数以获得更清晰的结果，但这将导致更多的锯齿。</li>
<li><code>Lanczos</code> 缩放速度较慢，但可以得到非常清晰的结果。然而，它会产生了非常明显的**振铃(ringing)伪影(artifact)**。</li>
<li><code>Blackmanminlobe</code> 一个 <code>lanczos</code> 的改良版（需要通过 <code>fmtconv</code> 来调用它缩放）具有较少的振铃伪影。这种调整工具对于YUV444编码的色度提升绝对值得考虑（稍后会详细介绍）。</li>
<li><code>Spline</code> 其缩放速度相当慢，但可以得到非常好的结果。有多种 <code>Spline</code> 调整工具可用，<code>Spline16</code> 比 <code>Spline36</code> 快，但效果稍差，而 <code>Spline36</code> 与 <code>Spline64</code> 效果十分相似，所以没有理由使用后者。推荐在缩小分辨率(downscaling)时使用 <code>Spline36</code>。</li>
<li><code>nnedi3</code> 其调整大小的速度相当慢，而且只能以2的幂数进行**放大像素(upscale)**。它也可以与 <code>Spline36</code> 结合起来，先将其分辨率放大，而后缩小所需的分辨率。结果明显好于前述的内核。</li>
<li><code>FSRCNNX</code> 是一个用于 mpv 的着色器，可以通过 <code>vs-placebo</code> 插件使用。它提供了远比 <code>nnedi3</code> 更清晰的结果，但需要GPU的支持。如果可以的话，建议使用它来进行放大分辨率。</li>
</ul>
<p>附录中提供了这些调整工具的效果比较，图16为缩小像素，图17为放大像素。此外，由于更改 <code>bicubic</code> 的参数将输出非常显着区别的结果，因此在附录图18还包括了对不同参数配置的 <code>bicubic</code> 放大比例的比较示例。为了满足更强的好奇心，我在图19中加入了缩小至原始分辨率后的对比，并且在附录中的图20中展示了同一调整工具先缩小再放大的情况。 </p>
<p>虽然这些截图应该可以帮助你对不同缩放方法之间的差异有一个大致的了解，但它们只是单个画面的一小部分。如果你想更好地了解这些调整工具对整体画面的影响，我建议你自己动手使用，在动态中观察它们，并将它们交错在一起(<code>std.Interleave</code>)进行对比。 </p>
<p>缩小像素时不同调整工具之间的差异比放大时要小得多。 但不建议以此为借口，在缩小像素时因偷懒而随意选择调整工具。 </p>
<p>简而言之: 用 <code>core.resize.Spline36</code> 来缩小分辨率。</p>
<h3 id="3-2-滤镜-Filtering"><a href="#3-2-滤镜-Filtering" class="headerlink" title="3.2 滤镜(Filtering)"></a>3.2 滤镜(Filtering)</h3><p>这有几件值得一提的事。首先，大多数蓝光片都是YUV420P8，范围有限(with limited range)。这里的第一组信息是YUV。这意味着我们视频的平面中Y是 <strong>亮度(luma)</strong> 平面，U和V是 <strong>色度(chroma)</strong> 平面。</p>
<p>YUV平面下的颜色，本例是4:2:0，指定了我们的平面大小。这方面最常见的三种变化是：4:2:0，这意味着色度平面是亮度平面的一半大小（例如，一个1920×1080的视频将有960×540的色度平面）；4:2:2，这意味着这种情况下的色度平面是水平分辨率的一半；垂直分辨率的全部；4:4:4，这意味着所有平面都是全分辨率。在播放过程中，视频播放器将色度平面放大到与亮度平面相同的大小。所以较小的色度平面并不明显，但在放大像素时，人们肯定能看出其中的差别。为了说明这一点，这里有个由AnoHana提供的例子，分别是在4:2:0与4:4:4下从720p放大至1080p的两种版本：</p>
<p><img src="/Picture/AHDVEG-pics/Figure1.png" alt="Figure1"></p>
<p>图1：两倍放大下，左边是YUV420，右边是YUV444。用 <code>fvf.Debic</code> 缩小像素，然后用 <code>nnedi3_rpow2.nnedi3</code>和 <code>resize.Bilinear</code> 放大像素。</p>
<p>在这种情况下，最差的调整工具（bilinear）被用于色度平面。如果你使用类似 带有 KrigBilateral配置的mpv 时，这应该看起来好得多。<br>另一个例子：《寄生虫》 SDR UHD缩放为1080p 4:2:0与4:4:4的比较。</p>
<p><img src="/Picture/AHDVEG-pics/Figure2.png" alt="Figure2"></p>
<p>图2：《寄生虫》（Parasite (2019)） SDR UHD缩小为1080p情况下4:2:0与4:4:4的比较。感谢HyerrDoktyer提供。</p>
<p>下一个要解释的信息是P8。这指的是**位深(Bit depth)**，本例中是8-bit。现在大多数视频都存储在8-bit，因为8-bit的 AVC【译者注：H.264】 具有最好的硬件兼容性。 然而，由于8-bit导致位深没有足够的值(0-255)可用，它很容易引入例如 <strong>色带(Banding)</strong> 之类的错误。更高的位深在这方面没有这么大的问题，且由于其更好的准确性，10-bit实际上更能以较小的文件体积存储视频。然而，10-bit的 AVC 几乎没有硬件兼容性可言，而且需要更长的时间来编码，因此PT用户通常不喜欢它。实际上大多数内容是以10-bit或12-bit制作的。 由于精度的提高，最流行的滤镜处理位深是16-bit。值得注意的是，UHD蓝光将采用YUV420P10，即10-bit。 </p>
<p>最后一部分，则要讲述的内容是限制范围(limited range)。在全范围(full range)8-bit中，我们可以用0至255之间的每一个值。可是，电视通常无法显示这些值，因而亮度被限制在16至235、色度被限制在16至240。大多数消费内容（如蓝光盘）也被限制在有限的范围内。假如你给电视一个全范围的视频，它将简单粗暴地将所有16及以下或235&#x2F;240及以上的数值显示为相同效果(make … the same value)（例如：黑色或白色）。</p>
<h4 id="3-2-1-检查你的源"><a href="#3-2-1-检查你的源" class="headerlink" title="3.2.1 检查你的源"></a>3.2.1 检查你的源</h4><p>这可能是花费时间最多的地方：检查你的源代码是否有问题。这需要遍历的整个源文件并亲自是否有**色带(banding)<strong>、</strong>锯齿(aliasing)<strong>、</strong>脏线(dirty line)**以及其他可能存在的问题。好消息是，VSEdit 允许你通过<code>CTRL + SHIFT + LEFT/RIGHT</code>键，按自己定义的步进来检查你的源文件。这个步进可以在预览窗口的右下角定义。我建议步进设置在1至3秒间。显然，间隔越短越好，因为你会检查更多的帧。</p>
<p>为了在一个给定的区间应用一个滤镜，请使用如下方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filtered = my_filter(src)</span><br><span class="line">out = awf.rfs(src, filtered, mappings=<span class="string">&quot;[FIRST_FRAME LAST_FRAME]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-抖动-Dithering"><a href="#3-2-2-抖动-Dithering" class="headerlink" title="3.2.2 抖动(Dithering)"></a>3.2.2 抖动(Dithering)</h4><p>尽管如果你将以与源文件相同的位深输出，就没有必要在高位深下工作，但为了输出时避免四舍五入的错误，建议在滤镜链的最后使用抖动降低位深，这可能会导致色带的伪影（图23是一个例子）。幸运的是，即使你不选择以高位深来编写脚本，大多数插件都可以在内部用高位深工作。由于抖动的速度相当快，而且更高的位深确实能带来更好的精度，所以除了一些为8-bit写的函数稍慢之外，通常没有理由不在更高的位深下工作。</p>
<p>如果你想了解更多关于抖动的信息，维基百科上的内容相当丰富，也有很多值得一读的研究出版物。在这里你只需要明白，只有当压制源和使用滤镜后的片段之间存在实际差异时，你使用的抖动方法才是重要的。由于抖动是对不同位深的四舍五入的一种选择，只有与实际整数的偏移才会有差异。一些算法可能在不同的情况上比其他的更好，因此，有理由使用非标准的算法。例如，如果你想将某个视频的色带去除，并以8-bit的形式输出，但在正确压缩方面存在问题时，你可能想考虑有序抖动，因为众所周知，它在这种情况下的表现略好（尽管它看起来不那么棒）。要做到这一点，请使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source_16 = fvf.Depth(src, <span class="number">16</span>)</span><br><span class="line">deband = core.f3kdb.Deband(source_16, output_depth=<span class="number">16</span>)</span><br><span class="line">out = fvf.Depth(deband, <span class="number">8</span>, dither=<span class="string">&#x27;ordered&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>同样，这只会影响实际的去色带区域。这在大多数情况下并不推荐，因为有序抖动的效果相当难看，但如果你在压缩去色带区域时遇到困难，这依然值得考虑。显然你应该使用遮罩并调整去色带函数的参数，后面会有更多关于此的内容。</p>
<p>为了向上或向下抖动，你可以使用 <code>fvsfunc14</code>(fvf) 或 <code>mvsfunc15</code>(mvf) 中的 <code>Depth</code> 函数。这两者之间的区别是，fvf 仅使用内置调整工具，而 mvf 不仅可以内置调整工具，而且也支持 <code>fmtconv</code>，它比较慢，但有更多的抖动（和缩放）选项。然而，两者都具有标准的 Filter Lite error_diffusion 抖动类型，所以如果你只是使用默认值，我会推荐 fvf。为了说明优质抖动与劣质抖动之间的区别，在附录中的图21下提供一些例子。 请注意，你可能要放大到相当大的程度才能发现其区别。有些PDF阅读器可能会不正确地显示这些图像。</p>
<p>我建议在大多数情况下使用 <strong>Filter Lite</strong>（fvf 的默认值 或 <code>mvf.Depth(dither=3)</code> 即 mvf 默认值)。其他如 <strong>Ostromoukhov</strong> (<code>mvf.Depth(dither=7)</code>), <strong>void and cluster</strong> (<code>fmtc.bitdepth(dither=8)</code>), <strong>standard Bayer ordered</strong> (<code>fvf.Depth(dither=&#39;ordered&#39;)</code> 或 <code>mvf.Depth(dither=0)</code>) 有时也会有用。不过，<strong>Filter Lite</strong> 通常更适用。</p>
<h4 id="3-2-3-去色带-Debanding"><a href="#3-2-3-去色带-Debanding" class="headerlink" title="3.2.3 去色带(Debanding)"></a>3.2.3 去色带(Debanding)</h4><p>这是人们会遇到的最常见的问题。当位深不足和劣化设置导致较平滑的梯度变成突然的颜色变化时，就会发生色带现象，这最终显然看起来不好。好消息是因有更多的值可以用于创建梯度，所以更高的位深可以帮助解决这个问题。正因为如此，很多去色带工作都是在16-bit下完成的，然后在滤镜过程完成后再抖动到10-bit或8-bit。</p>
<p>关于去色带，需要注意的一点是，你应该尽量使用遮罩，最好是边缘遮罩或类似的东西。详见[3.2.14](####3.2.14 遮罩(Masking))！</p>
<p>在 VapourSynth 中，有两个很优秀的函数可以用来修复色带：<code>f3kdb16</code> 和 <code>fvsfunc.gradfun3</code>。后者不太常用，但其中有内置遮罩。<br>让我们先看看 <code>f3kdb</code>。 VapourSynth 的相关代码默认设置如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deband = core.f3kdb.deband(src = clip, <span class="built_in">range</span> = <span class="number">15</span>, y = <span class="number">64</span>, cb = <span class="number">64</span>, cr = <span class="number">64</span>, grainy = <span class="number">64</span>, grainc = <span class="number">64</span>, dynamic_grain = <span class="literal">False</span>, output_depth = <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>这些设置对一些人来说可能是不言自明的，但还是说明一下各参数的作用：</p>
<ul>
<li><code>src</code> 这显然指你的输入内容。</li>
<li><code>range</code> 指定了用于计算某场景中色带的像素范围。更高的范围意味着更多的像素被用于计算，也意味着它有更高的性能需求。默认值15通常是足够的。</li>
<li><code>y</code> 最重要的设置，因为大多数（明显的）色带发生在亮度平面。它规定了在亮度平面上要有多大的差异才会被认为是色带的。你应该从低数值开始，缓慢但有效地提高，直到色带消失。如果设置得太高，很多细节就会被视为色带，从而变得模糊不清。</li>
<li><code>cb</code>&#x2F;<code>cr</code> 与y相同，但应用于色度平面。然而，色度平面上的色带是很不常见的，所以你通常可以忽略它。</li>
<li><code>grainy</code>&#x2F;<code>grainc</code> 为了防止带状物再次出现，并抵消平滑度，通常在去色带过程后加入**颗粒(grain)**。然而，由于这种假颗粒是相当明显的，建议保守一点添加。另外，你可以使用自定义加噪，这将得到一个更好的输出（见 3.2.10 颗粒化(Graining)）</li>
<li><code>dynamic_grain</code> 默认情况下，<code>f3kdb</code>添加的噪点是静态的。这样压缩效果更好，因为动态显然更少，但它在实拍内容中看起来不正常，所以除非你正在处理动画内容，否则通常建议将其设置为 <code>True</code>。</li>
<li><code>output_depth</code> 你应该将其设置为你想在去色带处理后的任意位深。如果你一直在8-bit下进行处理，你可以忽略这个选项。</li>
</ul>
<p>一个相当简单去色带的例子：</p>
<p><img src="/Picture/AHDVEG-pics/Figure3.png" alt="Figure3"></p>
<p>图3：两倍放大下，左边为源，右边为 <code>deband = core.f3kdb.Deband(src, y=64, cr=0, cb=0, grainy=32, grainc=0, range=15, keep_tv_range=True)</code> 处理后的效果。</p>
<p>如果你想把 <code>f3kdb</code> 和 <code>gradfun3</code> 两种遮罩一起使用，你可以使用 <code>fag3kdb</code> 替代。我建议在去色带力度非常强时尝试这个方法，但 <code>retinex_edgemask</code> 或 <code>debandmask</code> 在大多数情况下效果更好（尽管比前者的速度要慢很多）。</p>
<p>最常用的替代品是 <code>gradfun3</code>，它可能主要是由于其参数不太直接而不太受欢迎。它的工作原理是将源平滑处理，并通过 <code>mvf.LimitFilter</code> 将其限制在 <code>thr</code> 和 <code>elast</code>指定的值内，然后通过其内部遮罩与源合并（尽管使用外置遮罩也是可行的）。<br>许多人认为 <code>gradfun3</code> 比 <code>f3kdb</code> 的处理结果更平滑。因为它与 <code>f3kdb</code> 相比有更多的选项，而且使用它在大多数时候不必为遮罩而烦恼，所以值得了解如何去使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fvsfunc <span class="keyword">as</span> fvf</span><br><span class="line">deband = fvf.GradFun3(src, thr=<span class="number">0.35</span>, radius=<span class="number">12</span>, elast=<span class="number">3.0</span>, mask=<span class="number">2</span>, mode=<span class="number">3</span>,</span><br><span class="line">ampo=<span class="number">1</span>, ampn=<span class="number">0</span>, pat=<span class="number">32</span>, dyn=<span class="literal">False</span>, staticnoise=<span class="literal">False</span>, smode=<span class="number">2</span>, thr_det=<span class="number">2</span> + <span class="built_in">round</span>(<span class="built_in">max</span>(thr - <span class="number">0.35</span>, <span class="number">0</span>) / <span class="number">0.3</span>), debug=<span class="literal">False</span>, thrc=thr,radiusc=radius, elastc=elast,planes=<span class="built_in">list</span>(<span class="built_in">range</span>(src.<span class="built_in">format</span>.num_planes)), ref=src, bits=src.<span class="built_in">format</span>.bits_per_sample) <span class="comment"># + 调整大小的变量</span></span><br></pre></td></tr></table></figure>

<p>很多这些值是用于 <code>fmtconv </code> 位深转换的，因此它的文档可以证明其是有帮助的。<code>GradFun3</code>中的缩小像素与其他缩小方法没有什么不同，所以我不会讨论这个。其他一些可能感兴趣的参数是：</p>
<ul>
<li><code>thr</code> 等价于<code>y</code>&#x2F;<code>cb</code>&#x2F;<code>cr</code>。你可能想提高或降低它。</li>
<li><code>radius</code> 与 <code>f3kdb</code>的<code>range</code> 具有相同的效果。</li>
<li><code>smode</code> 设置平滑模式。通常最好保持默认值，即双边(bilateral)滤镜。如果你想使用支持CUDA的GPU而不是CPU的话，可以把它设置为5。使用 <code>ref</code>（默认为input clip）作为参考素材。</li>
<li><code>mask</code> 如果设置为0，则禁用遮罩。否则，它设置了要调用的 <code>std.Maximum</code>和<code>std.Minimum</code> 的次数。</li>
<li><code>planes</code> 设置需要处理的平面。</li>
<li><code>mode</code> 设置 <code>fmtconv</code> 中使用的抖动模式。</li>
<li><code>ampn</code>&#x2F;<code>staticnoise</code> 设置 <code>fmtconv</code>应该添加多少噪点以及噪点是否为静态。对于真人动作内容来说，有必要进行调整。</li>
<li><code>debug</code> 允许你查看遮罩。</li>
<li><code>elast</code>是 “软阈值的弹性”。更高的值会在去色带遮罩和源之间做更多的混合。</li>
</ul>
<p>如果去色带处理后的片段与未经处理的相比噪点很少，此时你应该考虑使用一个单独的函数来添加匹配的噪点，这样场景就更容易融合在一起。 如果有很多噪点，你可能要考虑使用 <code>adptvgrnMod</code>、<code>adaptive_grain</code> 或 <code>GrainFactory3</code>；对于不太明显的噪点或对于通常只有很少噪点的明亮场景，你也可以使用 <code>grain.Add</code>。这个话题将在后面的[3.2.10](####3.2.10 颗粒化(Graining))中进一步阐述。</p>
<p><img src="/Picture/AHDVEG-pics/Figure4.png" alt="Figure4"></p>
<p>图4：左边是源，右边是滤镜处理后的。这里的色带可能很难发现，但我不能在这个PDF中加入更大的图片。不过，这个效果应该是显而易见的。</p>
<p>如果你想进行自动色带检测，你可以使用一个基于 <code>bandmask</code> 的检测函数，叫做 <code>banddtct</code>。确保适当调整数值并检查全部输出。[3.2.17](####3.2.17 论坛和博客文章)中有一个解释它的论坛帖子链接。你也可以在运行 <code>adptvgrnMod</code> 或<code>adaptive_grain</code> 时使用一个高的 <code>luma_scaling</code> 值，希望噪点能完全覆盖它。 更多关于这个的内容在[3.2.10](####3.2.10 颗粒化(Graining))中继续讨论。</p>
<h4 id="3-2-4-修复脏线-Dirty-Lines-及不合适的边缘-Borders"><a href="#3-2-4-修复脏线-Dirty-Lines-及不合适的边缘-Borders" class="headerlink" title="3.2.4 修复脏线(Dirty Lines)及不合适的边缘(Borders)"></a>3.2.4 修复脏线(Dirty Lines)及不合适的边缘(Borders)</h4><p>另一个非常常见的问题，至少在真人电影的内容中，是脏线。这类问题通常出现在视频的边界上，与周围的行相比，某一行或某一列的像素通常表现出过低的亮度值。通常情况下，这是由于不适当地缩小分辨率，更明显的是在应用边框后的缩小分辨率。脏线也可能发生，因为视频编辑者往往不知道他们是在YUV422下工作的，这意味着他们的竖向像素值不必是偶数；而消费者内容将是YUV420，意味着竖向像素值必须是偶数，导致额外的黑行。</p>
<p>另一种形式的脏线是在黑条上出现色度平面时表现出来的。 通常情况下，这些应该被裁剪掉。然而，相反的情况也可能发生，即具有合法的亮度信息的平面但缺乏色度信息。 有六种常用的滤镜用于修复脏线。</p>
<ul>
<li><p><strong>cf</strong>的<code>ContinuityFixer</code></p>
<p><code>ContinuityFixer</code> 的工作原理是将指定的行&#x2F;列与周围范围指定的行&#x2F;列数量进行比较，通过最小二乘法再回归找到新值。其设置如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix = core.cf.ContinuityFixer(src=clip, left=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], right=[<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>], top=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], bottom=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], radius=<span class="number">1920</span>)</span><br></pre></td></tr></table></figure>

<p>这是假设你使用的是1080p的素材，因为半径的值被设置为源的分辨率所定义的最长的集合。我建议使用一个更低的值，但不要低于3，因为在这一点上，你可能是在复制像素（参见下面的<code>FillBorders</code>）。可能会让大多数新手感到困惑的是，我输入了一个数组，作为要固定的行&#x2F;列的值。这些值表示要应用到三个平面上的值。通常情况下，脏线只会发生在亮度平面上，所以你通常可以把其他两个平面的值保持为0。 请注意，数组并非必须，因此您也可以只输入希望应用修复的行&#x2F;列的数量，所有平面都会被处理。<br><code>ContinuityFixer</code> 最擅长的一点是去除不规则的东西，比如点。 它也比 <code>bbmod</code> 和 <code>FixBrightnessProtect2</code> 快，但它应该被视为这两者的备选方案。</p>
</li>
<li><p><strong>awsmfunc</strong>的<code>bbmod</code></p>
<p>这是原<code>BalanceBorders</code> 函数的一个修改版。它与 <code>ContinuityFixer</code> 非常相似，但在更高的 <strong>模糊值(blur)</strong> 和 <strong>阈值(thresh)</strong> 的情况下会产生更好的效果。如果它没有产生去分的结果，可以改变这些，但是你设置的模糊值越低，这个函数的破坏性就越大。它也比 <code>havsfunc</code> 和 <code>sgvsfunc</code> 中的版本快得多，因为只有必要的像素被处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> awsmfunc <span class="keyword">as</span> awf</span><br><span class="line">bb = awf.bbmod(src=clip, left=<span class="number">0</span>, right=<span class="number">0</span>, top=<span class="number">0</span>, bottom=<span class="number">0</span>,thresh=[<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>], blur=[<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>], scale_thresh=<span class="literal">False</span>,cpass2=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><code>thresh</code> 和 <code>blur</code> 的数组也是Y、U和V的值。建议先试试 <code>blur=999</code>，然后尝试降低这个和 <code>thresh</code> 的值，反复尝试，直到你得到合适的效果。<br><code>thresh</code>指定了结果可以和输入值相差多少。<code>blur</code> 是过滤器的强度，数值越低越强，数值越大则越弱。如果你设置 <code>blur=1</code> ，你基本上就等同于复制行。</p>
</li>
<li><p><strong>fb</strong>的<code>FillBorders</code></p>
<p>这个函数几乎就是复制下一列&#x2F;行的内容。虽然这听起来很傻，但当分辨率缩小导致更多的行在底部而不是顶部，并且由于YUV420的偶数的竖向像素值，我们不得不填充一行时，它就会非常有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill = core.fb.FillBorders(src=clip, left=<span class="number">0</span>, right=<span class="number">0</span>, bottom=<span class="number">0</span>, top=<span class="number">0</span>, mode=<span class="string">&quot;fillmargins&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个函数的一个非常有趣的应用是类似于只对色度平面应用 <code>ContinuityFixer</code>，它可以用在灰色边界或无论应用什么亮度平面修复的修复方法都与边界不匹配他们的环境时。这可以用下面的脚本来完成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fill = core.fb.FillBorders(src=clip, left=<span class="number">0</span>, right=<span class="number">0</span>, bottom=<span class="number">0</span>, top=<span class="number">0</span>, mode=<span class="string">&quot;fillmargins&quot;</span>)</span><br><span class="line">merge = core.std.Merge(clipa=clip, clipb=fill, weight=[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>你也可以分离平面并单独处理色度平面，尽管这只是稍微快一点。允许您为fb【译者注：<code>core.fb</code>】指定每个平面值的封装函数是 <strong>awsmfunc</strong> 中的 <code>FillBorders</code>。</p>
</li>
<li><p><strong>edgefixer</strong>的<code>ReferenceFixer</code></p>
<p>这需要原始版本的edgefixer（cf只是它的一个旧的移植版本，但它使用起来更漂亮，处理过程也没有改变）。我从来没有发现它有什么用处，但从理论上讲，它是很好的。它与一个参考素材进行比较，以调整其边缘固定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix = core.edgefixer.Reference(src, ref, left=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], right=[<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>], top=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], bottom=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], radius = <span class="number">1920</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rekt</strong>的 <code>rektlvls</code></p>
<p>这基本上是 <code>FixBrightnessProtect</code> 和 <code>FixBrightness</code> 的合二为一，另外还有一个事实，即不是整个画面都被处理。它的参数非常简单明了，提高调整值可以变亮，降低调整值可以变暗。将 <code>prot_val</code> 设置为0时，它的功能就与 <code>FixBrightness</code>相同，意味着调整值需要改变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rekt <span class="keyword">import</span> rektlvls</span><br><span class="line">fix = rektlvls(src, rownum=<span class="literal">None</span>, rowval=<span class="literal">None</span>, colnum=<span class="literal">None</span>, colval=<span class="literal">None</span>, prot_val=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>如果你想一次处理多行，你可以输入一个列表（例如，<code>rownum=[0, 1, 2]</code>）。</p>
</li>
</ul>
<p>有一点不应该被忽视的是，对太多的行&#x2F;列应用这些修正（除了 <code>rektlvls</code> 之外）可能会导致最终结果看起来很模糊。正因为如此，我们建议尽可能使用 <code>rektlvls</code>，或只在必要的行上使用亮度修复。如果失败了，最好在使用 <code>ContinuityFixer</code> 之前先试试 <code>bbmod</code>。</p>
<p>值得注意的是，你总是应该在调整大小之前修复脏线，否则做会引入更多的脏线。然而，更需注意的是，如果你在边缘使用 <code>FillBorders</code> 填充了一条黑线，你应该使用调整大小的工具来删除它。例如，要将一个顶部有一条填充线的片段从1920 × 1080调整为1280 × 536时应该这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top_crop = <span class="number">138</span></span><br><span class="line">bot_crop = <span class="number">138</span></span><br><span class="line">top_fill = <span class="number">1</span></span><br><span class="line">bot_fill = <span class="number">0</span></span><br><span class="line">src_height = src.height - (top_crop + bot_crop) - (top_fill + bot_fill)</span><br><span class="line">crop = core.std.Crop(src, top=top_crop, bottom=bot_crop)</span><br><span class="line">fix = core.fb.FillBorders(crop, top=top_fill, bottom=bot_fill, mode=<span class="string">&quot;fillmargins&quot;</span>)</span><br><span class="line">resize = core.resize.Spline36(<span class="number">1280</span>, <span class="number">536</span>, src_top=top_fill, src_height=src_height)</span><br></pre></td></tr></table></figure>

<p>如果你要处理对角线的边框，正确的做法是使用蒙版覆盖源，用<code>FillBorders</code> 调用合并源。为此举一个例子（来自D-Z0N3压制的作品《你的名字》）：</p>
<p><img src="/Picture/AHDVEG-pics/Figure5.png" alt="Figure5"></p>
<p>图5：该示例为《你的名字》（Your Name (2016)）中不恰当地使用边框。D-Z0N3的使用了蒙版，而Geek没有。 因此，Geek缺乏任何类似的纹理，而D-Z0N3则尽可能地保留它。使用 <code>FillBorders</code> 中的镜像模式可能更明智，但事后看来是20&#x2F;20【译者注： “20&#x2F;20视力”称为“完美”视力】。</p>
<p>D-Z0N3使用的代码（16-bit下）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = core.std.ShufflePlanes(src, <span class="number">0</span>, vs.GRAY).std.Binarize(<span class="number">43500</span>)</span><br><span class="line">cf = core.fb.FillBorders(src, top=<span class="number">6</span>).std.MaskedMerge(src, mask)</span><br></pre></td></tr></table></figure>

<p>在附录中的图22下有一个例子，说明为什么要使用蒙版。 </p>
<p>为了说明脏线可能是什么样子，这里有一个 <code>ContinuityFixer</code> 和纯色的 <code>FillBorders</code> 对比的例子。</p>
<p><img src="/Picture/AHDVEG-pics/Figure6.png" alt="Figure6"></p>
<p>图6：来源于的D-Z0N3的压制作品《无声的声音》（A Slinet Voice (2016)）的脏线修复与过滤。在最上面的三行使用 <code>ContinuityFixer</code>，在最左边的两列使用<code>FillBorders</code>。 当前画面放大15倍。</p>
<p>脏线很难发现。如果你在随机检查不同帧的边界时候不能发现存在脏线，那么可能就没有问题。如果你发现有每边都有小黑线边界，那么可以使用类似下面的脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">black_detect</span>(<span class="params">clip, thresh=<span class="literal">None</span></span>):</span><br><span class="line">	<span class="keyword">if</span> thresh == <span class="literal">None</span>:</span><br><span class="line">		thresh = (<span class="number">25</span> * (<span class="number">1</span> &lt;&lt; clip.<span class="built_in">format</span>.bits_per_sample) - <span class="number">1</span>) / <span class="number">255</span></span><br><span class="line">	mask = core.std.ShufflePlanes(clip, <span class="number">0</span>, vs.GRAY).std.Binarize(&#123;<span class="number">0</span>&#125;<span class="string">&quot;.format(thresh)).std.Invert().std.Maximum().std.Inflate().std.Maximum().std.Inflate()</span></span><br><span class="line"><span class="string">	l = core.std.Crop(mask, right=clip.width / 2)</span></span><br><span class="line"><span class="string">	r = core.std.Crop(mask, left=clip.width / 2)</span></span><br><span class="line"><span class="string">	mask_test = core.std.StackHorizontal([r, l])</span></span><br><span class="line"><span class="string">	t = core.std.Crop(mask_test, top=clip.height / 2)</span></span><br><span class="line"><span class="string">	b = core.std.Crop(mask_test, bottom=clip.height / 2)</span></span><br><span class="line"><span class="string">	mask_test = core.std.StackVertical([t, b])</span></span><br><span class="line"><span class="string">return mask_test</span></span><br></pre></td></tr></table></figure>

<p>这个脚本将 <code>threshold</code> 以下的数值（即黑色边框）在大部分黑色背景的中部显示为垂直或水平白线。你可以运用这个函数来浏览并检查你的视频。你也可以尝试使用 <code>blckdtct27</code>，它可以为你扫描视频。 </p>
<p>其他类型的可变脏线是一个修复难题(a bitch to fix)，需要手动检查场景。</p>
<p> 一个与脏线非常相似的问题是糟糕的边界(bad borders)。在不同场景中（例如IMAX或4:3），黑色边框有时可能不完全是黑色的，或者完全被打乱了。为了解决这个问题，只需将其裁剪并重新添加。你也可能想修复过程中可能出现的脏线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crop = core.std.Crop(src, left=<span class="number">100</span>, right=<span class="number">100</span>)</span><br><span class="line">clean = core.cf.ContinuityFixer(crop, left=<span class="number">2</span>, right=<span class="number">2</span>, top=<span class="number">0</span>, bottom=<span class="number">0</span>, radius=<span class="number">25</span>)</span><br><span class="line">out = core.std.AddBorders(clean, left=<span class="number">100</span>, right=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-抗锯齿-Anti-Aliasing"><a href="#3-2-5-抗锯齿-Anti-Aliasing" class="headerlink" title="3.2.5 抗锯齿(Anti-Aliasing)"></a>3.2.5 抗锯齿(Anti-Aliasing)</h4><p>这可能是最常见的问题。如果你想解决这个问题，首先要确定这个问题是由锯齿而不是糟糕的 <strong>放大像素(upscaling)</strong> 造成的。如果你已经确认，我推荐的工具是 <code>TAAmbk</code> 套件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vsTAAmbk <span class="keyword">as</span> taa</span><br><span class="line">aa = taa.TAAmbk(clip, aatype=<span class="number">1</span>, aatypeu=<span class="literal">None</span>, aatypev=<span class="literal">None</span>, preaa=<span class="number">0</span>, strength=<span class="number">0.0</span>, cycle=<span class="number">0</span>, mtype=<span class="literal">None</span>, mclip=<span class="literal">None</span>, mthr=<span class="literal">None</span>, mthr2=<span class="literal">None</span>, mlthresh=<span class="literal">None</span>, mpand=(<span class="number">1</span>, <span class="number">0</span>), txtmask=<span class="number">0</span>, txtfade=<span class="number">0</span>, thin=<span class="number">0</span>, dark=<span class="number">0.0</span>, sharp=<span class="number">0</span>, aarepair=<span class="number">0</span>, postaa=<span class="literal">None</span>, src=<span class="literal">None</span>, stabilize=<span class="number">0</span>, down8=<span class="literal">True</span>, showmask=<span class="number">0</span>, opencl=<span class="literal">False</span>, opencl_device=<span class="number">0</span>, **args)</span><br></pre></td></tr></table></figure>

<p>尽管GitHub的README内容相当详细，但在这有必要进行一些额外的补充：</p>
<ul>
<li><code>aatype</code>: (默认值: 1)</li>
</ul>
<p>  这里的值可以是表示亮度平面AA类型的数字，也可以是表示其AA类型的字符串。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0: lambda clip, *args, **kwargs: type(&#x27;&#x27;, (), &#123;&#x27;out&#x27;: lambda: clip&#125;),</span><br><span class="line">1: AAEedi2,</span><br><span class="line">2: AAEedi3,</span><br><span class="line">3: AANnedi3,</span><br><span class="line">4: AANnedi3UpscaleSangNom,</span><br><span class="line">5: AASpline64NRSangNom,</span><br><span class="line">6: AASpline64SangNom,</span><br><span class="line">-1: AAEedi2SangNom,</span><br><span class="line">-2: AAEedi3SangNom,</span><br><span class="line">-3: AANnedi3SangNom,</span><br><span class="line">&#x27;Eedi2&#x27;: AAEedi2,</span><br><span class="line">&#x27;Eedi3&#x27;: AAEedi3,</span><br><span class="line">&#x27;Nnedi3&#x27;: AANnedi3,</span><br><span class="line">&#x27;Nnedi3UpscaleSangNom&#x27;: AANnedi3UpscaleSangNom,</span><br><span class="line">&#x27;Spline64NrSangNom&#x27;: AASpline64NRSangNom,</span><br><span class="line">&#x27;Spline64SangNom&#x27;: AASpline64SangNom,</span><br><span class="line">&#x27;Eedi2SangNom&#x27;: AAEedi2SangNom,</span><br><span class="line">&#x27;Eedi3SangNom&#x27;: AAEedi3SangNom,</span><br><span class="line">&#x27;Nnedi3SangNom&#x27;: AANnedi3SangNom,</span><br><span class="line">&#x27;PointSangNom&#x27;: AAPointSangNom,</span><br></pre></td></tr></table></figure>
<p>  我建议使用的是 <code>Eedi3</code>、<code>Nnedi3</code>、<code>Spline64SangNom</code> 和 <code>Nnedi3SangNom</code>。 这两种 <code>SangNom</code> 模式都具有难以置信的破坏性，只有在绝对必要的情况下才应使用。<code>Nnedi3</code> 通常是你最好的选择；它不是很强也不具有破坏性，但往往足够好，而且速度相当快。<code>Eedi3</code> 慢得令人难以置信，但比 <code>Nnedi3</code> 强，且不像 <code>SangNom</code> 模式那样具有破坏性。</p>
<ul>
<li><p><code>aatypeu</code>: (默认值 <code>aatype</code> 一致)</p>
<p>当片段的格式为YUV时，为U平面选择主AA内核。</p>
</li>
<li><p><code>aatypeu</code>: (默认值 <code>aatype</code> 一致)</p>
<p>当片段的格式为YUV时，为V平面选择主AA内核。</p>
</li>
<li><p><code>strength</code>: (默认值: 0)</p>
<p>预降(predown)的强度，有效范围是[0, 0. 5]。 在应用主AA核之前，分辨率会先被缩小到 <code>(1- strength)×clip_resolution</code>，然后被主AA核放大至原始分辨率。这可能对那些因放大像素不足而造成严重锯齿的素材有好处。当使用不适合放大像素的AA内核时，自动禁用。如果可能，即不要增加，也不要降低。</p>
</li>
<li><p><code>preaa</code>: (默认值: 0)</p>
<p>选择 <code>preaa</code> 模式</p>
<ul>
<li>0: 不使用</li>
<li>1: 垂直</li>
<li>2: 水平</li>
<li>-1: Both</li>
</ul>
<p>在应用主AA内核之前，先使用 <code>preaa</code>。<code>preaa</code> 基本上是 <code>daa</code> 的一个简化版本。在处理由劣质 <strong>反交错(deinterlacing)</strong> 引起的残余隔行(residual comb)时相当有用。否则，不要使用它。</p>
</li>
<li><p><code>cycle</code>: (默认值: 0)</p>
<p>设置主AA内核的循环次数。用于非常非常糟糕的锯齿和3D锯齿。</p>
</li>
<li><p><code>mtype</code>: (默认值: 1)</p>
<p>选择要使用的边缘遮罩的类型。目前三种遮罩类型分别是： </p>
<ul>
<li>0：无遮罩 </li>
<li>1：Canny遮罩 </li>
<li>2：Sobel遮罩 </li>
<li>3：Prewitt遮罩</li>
</ul>
<p>遮罩总是在8-bit下构建。这所有选项都棒，但你最好测试一下，看看哪种最终效果最好。</p>
</li>
<li><p><code>mclip</code>: (默认值: None)</p>
<p>使用自定义遮罩，而不是由函数内部建立，并且你应该自己处理遮罩的分辨率、位深、格式等问题。如果设置了<code>mclip</code>，脚本将不会构建其他遮罩了。</p>
</li>
<li><p><code>mthr</code>: </p>
<p>遮罩的大小。你给定的值越小，你将得到越大的遮罩。</p>
</li>
<li><p><code>mlthresh</code>: (默认值: None)</p>
<p>为 n-pass 的遮罩设置亮度 thresh。使用一个列表或数组来指定luma的部分。</p>
</li>
<li><p><code>mpand</code>: (默认值: (1,0) )</p>
<p>使用一个列表或元组来指定掩码扩展和掩码放大的循环。</p>
</li>
<li><p><code>txtmask</code>: (默认值: 0)</p>
<p>创建一个掩码来保护屏幕上的白色字幕。值是亮度的阈值。有效范围是0-255。当一个区域的亮度值大于阈值，色度值为128±2时，它将被认为是一个字幕。</p>
</li>
<li><p><code>txtfade</code>: (默认值: 0)</p>
<p>设置淡入淡出的长度(时长？)。用于的淡入淡入淡出字幕。</p>
</li>
<li><p><code>thin</code>: (默认值: 0)</p>
<p>在应用主AA内核之前，通过aWarpSharp2对该行进行扭曲。</p>
</li>
<li><p><code>dark</code>: (默认值: 0.0) </p>
<p>在应用主AA内核之前，通过 <code>Toon</code> 使线条变暗。</p>
</li>
<li><p><code>sharp</code>: (默认值: 0)</p>
<p>在应用主AA内核后，对片段进行锐化。</p>
<ul>
<li>0: 没有锐化。</li>
<li>1 inf:LSFmod (defaults&#x3D;’old’) </li>
<li>0 1: 类似 Avisynth 的 <code>sharpen()</code> </li>
<li>-1 0: LSFmod (defaults&#x3D;’fast’) </li>
<li>-1:ContraSharpen</li>
</ul>
<p>无论哪种类型的锐化，较大的锐化绝对值意味着较大的锐化强度。</p>
</li>
<li><p><code>aarepair</code>: (默认值: 0)</p>
<p>使用修复来消除由主AA内核引入的伪影。根据不同的修复模式，原始素材中的像素将被处理过的素材的3x3邻居中的中位数或平均值所取代。强烈建议在主AA内核包含 <code>SangNom</code> 时使用该修复。更多信息请<a target="_blank" rel="noopener" href="http://www.vapoursynth.com/doc/plugins/rgvs.html#rgvs.Repair">查看</a>。 但很难让这个工具正常工作。</p>
</li>
<li><p><code>postaa</code>: (默认值: False)</p>
<p>是否使用 soothe 来对抗锐化带来的混杂现象。</p>
</li>
<li><p><code>src</code>: (默认值: clip)</p>
<p>引入片段进行锐化、修复、蒙版合并等。</p>
</li>
<li><p><code>stabilize</code>: (默认值: 0)</p>
<p>通过 MVTools 稳定时间上的变化。值是时间半径。有效范围是[0, 3]。</p>
</li>
<li><p><code>down8</code>: (默认值: True)</p>
<p>如果你将此设置为 True，引入的片段将先被降低到8-bit，并在应用主AA内核之后回升到原始的位深度。在位深转换中，采用 <code>LimitFilter</code> 来减少损失。</p>
</li>
<li><p><code>showmask</code>: (默认值: 0)</p>
<p>如果你把它设置为非0数值，则输出遮罩而不是处理过的片段。</p>
<ul>
<li>0：正常输出</li>
<li>1：只有蒙版</li>
<li>2：粘性蒙版和剪辑</li>
<li>3：交错蒙版和剪辑</li>
<li>-1：只有文本蒙版</li>
</ul>
</li>
<li><p><code>opencl</code>: (默认值: False)</p>
<p>是否使用opencl版本的一些插件。目前有三个插件可以使用opencl：</p>
<ul>
<li>TcannyCL</li>
<li>EEDI3CL</li>
<li>NNEDI3CL</li>
</ul>
<p>这可能会加快速度，这显然是很好的，因为抗锯齿计算通常是很慢。</p>
</li>
<li><p><code>opencl_device</code>: (默认值: 0)</p>
<p>选择一个 OpenCL 设备。要知道选择的是哪一个的，请输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core.nnedi3cl.NNEDI3CL(clip, <span class="number">1</span>, list_device=<span class="literal">True</span>).set_output()</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他参数：</p>
<p>将被收集到一个特别为 <code>aatype</code> 制作的手册中。</p>
</li>
</ul>
<p>请注意，还有很多非常好的抗锯齿方法，以及许多不同类型的遮罩，你可以使用（例如，其他边缘遮罩，无限接近两种遮罩的结合(clamping one method’s changes to those of another method)等等）。然而，大多数方法都是基于与 <code>TAA</code> 实现的非常相似的方法。</p>
<p>如果你的整个视频都受到锯齿的影响，那么放大像素的效果就很糟糕，这也不是太不可能的。在这种情况下，在决定你是否需要执行抗锯齿操作之前，先缩小像素或调整大小。</p>
<p>这有一个抗锯齿修复例子（来自《悠哉日常大王》(劇場版 のんのんびより ばけーしょん（2018）)）：</p>
<p><img src="/Picture/AHDVEG-pics/Figure7.png" alt="Figure7"></p>
<p>图7：左边为带有锯齿的源，右边为滤镜处理后</p>
<p>在这个例子中，我们进行了以下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask = kgf.retinex_edgemask(src).std.Binarize(<span class="number">65500</span>).std.Maximum().std.Inflate()</span><br><span class="line">aa = taa.TAAmbk(src, aatype=<span class="number">2</span>, mtype=<span class="number">0</span>, opencl=<span class="literal">True</span>)</span><br><span class="line">out = core.std.MaskedMerge(src, aa, mask)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-6-缩小像素-Descale"><a href="#3-2-6-缩小像素-Descale" class="headerlink" title="3.2.6 缩小像素(Descale)"></a>3.2.6 缩小像素(Descale)</h4><p>虽然大多数电影是以2K分辨率制作的，大多数动漫是以720p制作的，但蓝光片几乎都是1080p，UHD蓝光片都是4K。这意味着母版制作公司经常要对画面进行放大。这种操作的结果通常不理想，但幸运的是，有些损伤是可逆的。由于动漫通常以比源图像更高的分辨率发布，而且使用 <code>bilinear</code> 或 <code>bicubic</code> 放大像素非常常见，大多数缩小分辨率软件是为动漫编写的，这也是你需要缩小分辨率的主要场景。真人电影通常不能被缩小分辨率，因为糟糕的专有缩放器（通常是 QTEC 或类似的），因此大多数真人电影压制人员不知道是否需要缩小分辨率或根本不考虑。</p>
<p>所以，如果你对动漫进行编码，一定要确保查看过原画分辨率(check what the source images are)。你可以使用<a target="_blank" rel="noopener" href="https://anibin.blogspot.com/">https://anibin.blogspot.com/</a> 来查阅原画发行信息 ，通过 <a target="_blank" rel="noopener" href="https://anibin.blogspot.com/"><code>getnative</code></a> 进行截图，或者干脆自己试试。最后一个选项显然是最好的方法，但 <code>getnative</code> 通常也非常好，而且更容易。Anibin，虽然也很有用，但并不总是能得到正确的分辨率。</p>
<p>为了达到缩小分辨率的效果，你应该使用 <code>fvsfunc</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fvsfunc <span class="keyword">as</span> fvf</span><br><span class="line">descaled = fvf.Debilinear(src, <span class="number">1280</span>, <span class="number">720</span>, yuv444=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将使用 <code>bilinear</code> 缩小到720p，并用 <code>Spline36</code> 将色度平面缩小到360p。如果你为一个不关心硬件兼容性的网站&#x2F;团体压制动漫作品，你可能会想将<code>yuv444=true</code>，并相应地改变你的编码设置。</p>
<p>缩小像素支持使用 <code>bilinear</code>、<code>bicubic</code> 和 <code>spline</code> 放大内核。除了 <code>Debilinear</code>之外，每一种都有自己的参数。对于 <code>Debicubic</code>，这些参数是：</p>
<ul>
<li>b：在0和1之间，这相当于应用了模糊的效果</li>
<li>c：也在0到1之间，这是锐利的效果</li>
</ul>
<p>  最常见的情况是 b&#x3D;1&#x2F;3和c&#x3D;1&#x2F;3 ，这是默认值；b&#x3D;0和c&#x3D;1，这是过度锐化的 <code>bicubic</code>；b&#x3D;1和c&#x3D;0，这是模糊化的 <code>bicubic</code>。不过，介于两者之间的数值也很常见。</p>
<p>同样，<code>Delanczos</code> 也有 <code>taps</code> 选项，使用<code>Spline</code> 放大分辨率的同样可以用 <code>Despline36</code> 和 <code>Despline16</code> 来反转放大分辨率操作。 </p>
<p>缩小分辨率后，你很可能想再放大至1080p或2160p。这样做的首选方法是通过 <code>nnedi3</code>，或者更具体地说是使用<code>edi3_rpow2</code> 或 <code>nnedi3_rpow2</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> edi3_rpow2 <span class="keyword">import</span> nnedi3_rpow2</span><br><span class="line">descaled = fvf.Debilinear(src, <span class="number">1280</span>, <span class="number">720</span>)</span><br><span class="line">upscaled = nnedi3_rpow2(descaled, <span class="number">2</span>).resize.Spline36(<span class="number">1920</span>, <span class="number">1080</span>)</span><br><span class="line">out = core.std.Merge(upscaled, src, [<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>我们在这里做的是 <code>bilinear</code> 放大后再降至720p，然后用 <code>nnedi3</code> 将其升至1440p，再降至1080p，然后与源的色度平面合并。这样做的原因有很多：</p>
<ul>
<li>大多数人都没有正确地设置视频播放器来使分辨率放大(upscale the footage)。</li>
<li>那些不是很了解情况的人往往认为更高的分辨率&#x3D;更好的质量，因此1080p更受欢迎。</li>
<li>很多PT站点只允许720p和1080p的画面。也许你不想伤害色度平面，或者原始分辨率介于两者之间（810p和900p很常见）时，你更想放大到1080p而不是缩小至720p。</li>
</ul>
<p>另一件要注意的事是，字幕和其他文字往往是在放大像素后添加的，因此你需要使用一个蒙版，以免破坏这些文字。幸运的是，你可以简单地在缩小像素的函数名称后添加一个M（<code>DebilinearM</code>），你就会得到一个遮罩。然而，这将大大减慢了缩小分辨率速度，所以你可能想在这里进行场景过滤。</p>
<p>在上述常见的分辨率缩小方法之外，还有一些值得考虑的滤镜，尽管它们的作用实际上都是一样的，那就是对线条艺术(line art)（又称边缘）进行分辨率缩小，并将其重新调整为源分辨率。如果在放大分辨率后添加了大量的抖动，这就特别有用。</p>
<ul>
<li><code>DescaleAA</code>：<code>fvsfunc</code> 的一部分，使用一个 <code>Prewitt</code> 遮罩来找到线条艺术并重新将像素放大。</li>
<li><code>InsaneAA</code>：使用强化的 <code>Sobel</code> 遮罩以及混合使用 <code>eedi3</code> 与 <code>nnedi3</code>。</li>
</ul>
<p>就个人而言，我不喜欢把它放大回去并坚持使用YUV444编码。然而，如果你想这样做，你也可以考虑尝试编写你自己的遮罩。一个例子是（根据以前的代码）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask = kgf.retinex_edgemask(src).std.Binarize(<span class="number">15000</span>).std.Inflate()</span><br><span class="line">new_y = core.std.MaskedMerge(src, upscaled, mask)</span><br><span class="line">new_clip = core.std.ShufflePlanes([new_y, u, v], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], vs.YUV)</span><br></pre></td></tr></table></figure>

<p>为了说明区别，这里有一些放大至源分辨率的例子。请注意，通过视频播放器将YUV444分辨率缩小后的画面放大会更好看。</p>
<p><img src="/Picture/AHDVEG-pics/Figure8.png" alt="Figure8"></p>
<p>图8：蓝光源，左边是通过 <code>bicubic</code> 放大函数将720p的画面提升到1080p，右边是用<code>Debilinear</code> 和 <code>nnedi3</code> 重新缩放。</p>
<p>重要的是要注意，这当然也可以用于实景拍摄的画面。一个例子是《权力的游戏》第一季的UHD蓝光片，它是双线性(bilinear)升频的。虽然在截图中并不明显，但在播放过程中的差异是惊人的。</p>
<p><img src="/Picture/AHDVEG-pics/Figure9.png" alt="Figure9"></p>
<p>图9：《权力的游戏》（Games of Throne:Seaon 1 (2011)）UHD蓝光源，左边是通过 <code>bilinear</code> 像素放大函数将1080p的画面提升到2160p，右边是用 <code>Debilinear</code> 和 <code>nnedi3</code> 重新缩放。</p>
<p>如果你的视频在每一帧中都有多个源分辨率（即不同的层有不同的分辨率），你可以通过 <code>getnative</code> 输出多个结果来注意到这一点，你最好的办法是通过 <code>Spline36</code> 缩小到最低分辨率。虽然从技术上讲，你可以屏蔽每个图层，将它们全部缩小到它们的源分辨率，然后再将每个图层放大回去，但这太费劲了，不值得这么做。</p>
<h4 id="3-2-7-去振铃-Deringing"><a href="#3-2-7-去振铃-Deringing" class="headerlink" title="3.2.7 去振铃(Deringing)"></a>3.2.7 去振铃(Deringing)</h4><p>术语 “振铃” 可以指大多数边缘伪影，其中最常见的是<strong>蚊式噪声(mosquito noise)</strong> 和 **边缘增强伪影(edge enhancement artifacts)**。振铃是低质量视频源中十分常见。然而，由于拍摄设备原因和糟糕的压缩方法，即使是高比特率的音乐会也很容易出现这种情况。为了解决这个问题，建议使用 <code>HQDeringmod</code> 或 <code>EdgeCleaner</code>（来自 <code>scoll</code>）等软件，我建议使用前者。这些方法主要目的是模糊和锐化边缘，然后通过边缘遮罩进行合并。它们简单易用，所以你可以自己阅读和了解它们，并熟悉它们的用途。由于 <code>rgvs.Repair</code> 可能相当激进，如果你使用这些函数，并且默认值不能产生足够好的结果，我建议你尝试修复数值。</p>
<p><img src="/Picture/AHDVEG-pics/Figure10.jpg" alt="Figure10"></p>
<p>图10：左边是源，右边是经 <code>HQDeringmod(mrad=5, msmooth=10, drrep=0)</code> 处理后的。 这是非常暴力的去振铃方式，我一般不推荐。该示例图像是来自One Ok Rock演唱会，码率37 mbps蓝光视频。</p>
<h4 id="3-2-8-去光晕-Dehaloing"><a href="#3-2-8-去光晕-Dehaloing" class="headerlink" title="3.2.8 去光晕(Dehaloing)"></a>3.2.8 去光晕(Dehaloing)</h4><p>光晕如其名：边缘周围的粗而亮的线条。这一问题常出现在没有正确地调整大小后。你可能也会发现，像素缩小(descaling)参数不足或对低质量视频缩小分辨率会产生明显的光晕。为了解决这个问题，你应该使用<code>havsfunc</code>的<code>DeHalo_alpha</code> 或其已蒙版处理的同类产品 <code>FineDehalo</code>。如果使用前者，你必须编写你自己的掩码，因为无掩码的去晕通常会导致糟糕的结果。关于如何写一个简单的去光晕遮罩，请看<a target="_blank" rel="noopener" href="https://guide.encode.moe/encoding/masking-limiting-etc.html#example-build-a-simple-dehalo-mask">encode.moe的指南</a>。</p>
<p>由于 <code>FineDehalo</code> 是 <code>DeHalo_alpha</code> 的衍生函数，因此它们共享一些参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FineDehalo(src, rx=<span class="number">2.0</span>, ry=<span class="literal">None</span>, thmi=<span class="number">80</span>, thma=<span class="number">128</span>, thlimi=<span class="number">50</span>, thlima=<span class="number">100</span>,</span><br><span class="line">darkstr=<span class="number">1.0</span>, brightstr=<span class="number">1.0</span>, showmask=<span class="number">0</span>, contra=<span class="number">0.0</span>, excl=<span class="literal">True</span>,edgeproc=<span class="number">0.0</span>) <span class="comment"># ry defaults to rx</span></span><br><span class="line">DeHalo_alpha(clp, rx=<span class="number">2.0</span>, ry=<span class="number">2.0</span>, darkstr=<span class="number">1.0</span>, brightstr=<span class="number">1.0</span>, lowsens=<span class="number">50</span>,highsens=<span class="number">50</span>, ss=<span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>

<p>AviSynth维基上的解释足以帮助了解：<a target="_blank" rel="noopener" href="http://avisynth.nl/index.php/DeHalo_alpha#Syntax_and_Parameters">http://avisynth.nl/index.php/DeHalo_alpha#Syntax_and_Parameters</a> 和 <a target="_blank" rel="noopener" href="http://avisynth.nl/index.php/FineDehalo#Syntax_and_Parameters">http://avisynth.nl/index.php/FineDehalo#Syntax_and_Parameters</a> 。</p>
<h4 id="3-2-9-降噪-Denoising"><a href="#3-2-9-降噪-Denoising" class="headerlink" title="3.2.9 降噪(Denoising)"></a>3.2.9 降噪(Denoising)</h4><p>降噪是一个相当棘手的问题。真人电影压制从不降噪(Live action encoders will never denoise)，而动漫压制往往会降噪过度。你想对动漫进行降噪的主要原因是，它本身不应该有任何噪点，但压制时会引入噪点，而位深转换会引入抖动。前者是不需要的，而后者是需要的。你也可能会遇到像<strong>闪回(flashbacks)</strong> 过程中遇到明显的**颗粒感(grains)**。去除不需要的噪点将有助于压缩码率，并消除一些轻微的抖动&#x2F;颗粒感；这对10-bit来说是很有用的，因为更平滑的视频源可以更好地进行编码并得到很好的效果，而8-bit的效果更为突出，更多的噪点可以防止出现色带等。可是，有时你可能会遇到这样的情况，你必须对压缩以外的内容进行去噪&#x2F;去纹。例如，假设你正在对一部动漫电影进行编码，其中有一个原版动漫剧集的闪回场景。动漫电影通常是1080p制作的，但大多数系列不是。因此，你可能会遇到一个带有大量颗粒的1080p升级版。在这种情况下，你会想把颗粒去掉，重新缩放，并把它合并回来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">degrained = core.knlm.KNLMeansCL(src, a=<span class="number">1</span>, h=<span class="number">1.5</span>, d=<span class="number">3</span>, s=<span class="number">0</span>, channels=<span class="string">&quot;Y&quot;</span>, device_type=<span class="string">&quot;gpu&quot;</span>, device_id=<span class="number">0</span>)</span><br><span class="line">descaled = fvf.Debilinear(degrained, <span class="number">1280</span>, <span class="number">720</span>)</span><br><span class="line">upscaled = nnedi3_rpow2(descaled, rfactor=<span class="number">2</span>).resize.Spline36(<span class="number">1920</span>, <span class="number">1080</span>).std.Merge(src, [<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">diff = core.std.MakeDiff(src, degrained, planes=[<span class="number">0</span>])</span><br><span class="line">merged = core.std.MergeDiff(upscaled, diff, planes=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h4 id="3-2-10-颗粒化-Graining"><a href="#3-2-10-颗粒化-Graining" class="headerlink" title="3.2.10 颗粒化(Graining)"></a>3.2.10 颗粒化(Graining)</h4><p>由于**颗粒(grain)**【译者注：可以理解为有益的噪点】和 <strong>抖动(dither)</strong> 是最难压缩的东西之一，许多视频源都只包含很少的颗粒，或者已去除明显的颗粒。为了应对这种情况，或者仅压缩没有颗粒的区域，手动添加颗粒往往是有利举措的。在这种没有明显颗粒的情况下，你通常要先移除噪点，然后再重新打上颗粒。这对动画片尤其有利，因为缺乏颗粒通常会使重编码更难保持颜色渐变。<br>由于是人为地添加颗粒，我们可以选择静态颗粒。在动漫中不易被察觉，而且压缩效果更好，因此它通常是动漫内容的最佳选择。然而，这在真人电影内容中往往是相当明显的，因此静态颗粒不常被用于发布在PT的压制作品中。</p>
<p>标准的加噪函数，<code>grain.Add</code>，也是其他函数在用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grained = core.grain.Add(clip, var=<span class="number">1</span>, constant=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>var</code> 标志着强度。一般不会调得太高。如果你发现自己把它调得太高，它就会变得很明显，以至于你要尝试颗粒与画面相匹配，以保证颗粒不影响画面。</p>
<p>最著名的添加颗粒的函数是 <code>GrainFactory3</code>。这个函数允许你指定 <code>grain.Add</code> 应该如何应用于三个不同的亮度(luma)级别（亮、中、暗）。同时该函数也用 <code>resize.Bicubic</code> 对亮度平面进行缩放，以提高或降低其大小，以及通过函数中 <code>b</code>和 <code>c</code> 参数对其进行锐化，这些参数通过锐化选项来修改。由于你必须修改大小、锐度和阈值参数，所以在这里可能很难匹配。 然而，它可以产生很棒的效果，特别是对于具有更多自然颗粒的实景内容。</p>
<p>自动化程度更高的选择是 <code>adaptive_grain</code>。它的工作原理与 <code>GrainFactory3</code> 相似，但根据整体画面的亮度值和特定区域的亮度，对部分画面应用不同数量的颗粒。由于它没有很多设置项，所以更容易使用，而且对动漫来说效果很好。由于其考虑整个帧画面的平均亮度，因此能产生非常好的效果。</p>
<p>除了这两个函数之外，还有一个叫做 <code>adptvgrnMod32</code> 的组合，它将 <code>GrainFactory3</code> 的锐度和尺寸规格选项添加到 <code>adaptive_grain</code> 中。由于颗粒只被添加到一个（通常比帧小）图像的一个尺寸中，这往往是最快的函数。如果颗粒的大小不会因为不同的卢马等级而改变，就像数字生产的颗粒一样，这可能会导致比前述两个函数更好的结果。</p>
<p>对于那些好奇这可能是什么样子的人来说，请参考图4中《未来的未来》（Mirai (2018)）的去色带例子，因为在那个例子中，<code>adptvgrnMod</code> 被用来做纹路。</p>
<h4 id="3-2-11-去色块-Deblocking"><a href="#3-2-11-去色块-Deblocking" class="headerlink" title="3.2.11 去色块(Deblocking)"></a>3.2.11 去色块(Deblocking)</h4><p>解锁主要相当于平滑源，通常在上面再加一个掩码。这里最流行的函数是来自 <code>havsfunc</code>的<code>Deblock_QED</code>。其主要参数是</p>
<ul>
<li>quant1：块边缘解锁的强度。默认值是24。你可能想显著提高这个值</li>
<li>quant2：区块内部解锁的强度。默认值是26。同样，提高这个值可能被证明是有益的。</li>
</ul>
<p>其他流行的选项有 <code>deblock.Deblock</code>，它相当强大，但几乎总是有效；<code>dfttest.DFTT</code>，效果较弱，但仍然相当积极；以及 <code>fvf.AutoDeblock</code>，它对解锁MPEG-2源相当有用，可以应用于整个视频。另一种流行的方法是简单的去色带，因为去色块和去色带是非常类比似的。这对AVC蓝光资源来说是一个不错的选择。</p>
<h4 id="3-2-12-色彩校正-Detinting"><a href="#3-2-12-色彩校正-Detinting" class="headerlink" title="3.2.12 色彩校正(Detinting)"></a>3.2.12 色彩校正(Detinting)</h4><p>如果你有一个较好并但偏色的片源和一个较差且无色彩渲染的片源，而你想去掉偏色层(you’d like to<br>remove tint)，你可以通过 <code>timecube</code> 和 Dr.Dre 的颜色匹配工具来实现。首先，在该工具中添加两张参考截图，导出LUT，保存它，并通过以下方式添加它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clip = core.resize.Point(src, matrix_in_s=<span class="string">&quot;709&quot;</span>, <span class="built_in">format</span>=vs.RGBS)</span><br><span class="line">detint = core.timecube.Cube(clip, <span class="string">&quot;LUT.cube&quot;</span>)</span><br><span class="line">out = core.resize.Point(detint, matrix=<span class="number">1</span>, <span class="built_in">format</span>=vs.YUV420P16)</span><br></pre></td></tr></table></figure>

<p><img src="/Picture/AHDVEG-pics/Figure11.png" alt="Figure11"></p>
<p>图11：左为偏色的源，右为色彩纠正后的。这个例子来自于D-Z0N3压制的《你的名字》（Your name (2016)）。此帧中还进行了抗锯齿处理。</p>
<p>同样，如果你有所谓的**伽马(gamma)<strong>错误，或者更准确地说，</strong>双范围(double range)**压缩（将有限范围的压缩完全应用于已经过范围受限处理的片段），只需做以下工作（适用于16-bit）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out = core.std.Levels(src, gamma=<span class="number">0.88</span>, min_in=<span class="number">4096</span>, max_in=<span class="number">60160</span>, min_out=<span class="number">4096</span>, max_out=<span class="number">60160</span>, planes=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/Picture/AHDVEG-pics/Figure12.png" alt="Figure12"></p>
<p>图12：左由双范围(double range)处理，右由伽马(gamma)修复处理</p>
<p>通常会要求的使用值为0.88，但其他伽玛值也不是不可以。如果黑色的亮度值是218而不是235，这就是必要的。不要在低位深下进行这种操作，原因如图23所示。如果色度平面也受到影响，则必须单独处理它们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out = core.std.Levels(src, gamma=<span class="number">0.88</span>, min_in=<span class="number">4096</span>, max_in=<span class="number">61440</span>,min_out=<span class="number">4096</span>, max_out=<span class="number">61440</span>, planes=[<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>你也可以使用 <strong>awsmfunc</strong>中封装的<code>fixlvls</code> 函数来完成所有这些操作。 </p>
<p>如果你有一个色彩矩阵不正确的源，你可以用以下方法来解决这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out = core.resize.Point(src, matrix_in_s=<span class="string">&#x27;470bg&#x27;</span>, matrix_s=<span class="string">&#x27;709&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>‘470bg’就是通常所说的601。调整大小的原因是，矩阵转换发生在 YUV 到 RGB 转换之间，这意味着我们需要提高色度。 我们使用点调整大小，因为它是绝对的。要知道你是否应该这样做，你需要一些参考来源，最好不是网络来源。从技术上讲，你可以识别不好的颜色，并意识到有必要改变矩阵。</p>
<p><img src="/Picture/AHDVEG-pics/Figure13.png" alt="Figure13"></p>
<p>图13：使用了TayTO压制的《燃烧》（Burning (2018)）进行矩阵转换的例子。最值得关注的地方是她的粉红色胸罩和背景中的红色。</p>
<h4 id="3-2-13-去硬字幕和图标-Dehardsubbing-and-Delogoing"><a href="#3-2-13-去硬字幕和图标-Dehardsubbing-and-Delogoing" class="headerlink" title="3.2.13 去硬字幕和图标(Dehardsubbing and Delogoing)"></a>3.2.13 去硬字幕和图标(Dehardsubbing and Delogoing)</h4><p>虽然这个问题在动画片中特别常见，但它也发生在一些实拍片源中，而且许多音乐视频或音乐会在电视台播放时都有标识，因此值得研究如何删除硬拷贝或标识。对于logo，<code>Delogo</code> 插件非常值得考虑。要使用它，你将需要 Logo 的 <code>.lgd</code> 文件。你可以通过你最喜欢的搜索引擎简单地查找这个，应该会找到一些东西。从那里，用这个插件做什么应该是相当直接的。</p>
<p>最常见的去除硬字幕的方法是比较两个来源，一个有硬字幕，一个没有硬拷贝的参考来源。我推荐的函数是 <code>kagefunc33</code>的<code>hardsubmask</code> 和 <code>hardsubmask_fades</code>。前者只对有黑白字幕的资源有用，而后者可用于标识和移动字幕。两者的重要参数是扩展选项，这意味着对 <code>std.max</code> 的调用。根据你的视频源质量和检测到的数量，可能需要降低这些参数值。</p>
<p>我们也可以用 <code>Delogo</code> 进行类似的操作，以创建一个类似的遮罩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No example script yet</span><br></pre></td></tr></table></figure>

<p>一旦你准备好你的蒙版，你就可以把你的参考无硬字幕源和主源合并起来。此过程中可能需要使用一些着色处理，因为二者可能有色差。值得注意的是，这样做要远好于将好的视频源（有硬字幕）替换成差的视频源。如果你很懒，通常可以毫无问题地将这些蒙版应用到整个片段中，无需遍历整个视频来寻找硬字幕区域。</p>
<h4 id="3-2-14-遮罩-masking"><a href="#3-2-14-遮罩-masking" class="headerlink" title="3.2.14 遮罩(masking)"></a>3.2.14 遮罩(masking)</h4><p>【译者注：也可以叫做蒙版】这是最复杂的部分，也是动漫编码人员之外的大多数编码人员倾向于忽视的部分。遮罩有助于保护重要的细节不被你的滤镜所破坏。PT压制组使用的最常用的蒙版是二值化蒙版(binarize masks)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = core.std.ShufflePlanes(src, <span class="number">0</span>, vs.GRAY)</span><br><span class="line">mask = core.std.Binarize(y, <span class="number">5000</span>)</span><br><span class="line">merge = core.std.MaskedMerge(filtered, src, mask)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我假设我们是在16-bit下操作。<code>std.Binarize</code> 在这里所做的是在位深允许范围内将小于5000以下的每个值变为最小值，5000以上的每个值变为最大值。这意味着5000以上的每个像素都将从源素材中复制出来。这通常被称为**亮度遮罩(luma mask)**，通常用于解决画面暗部色带问题。</p>
<p>我们也可以用其中一个色度平面来做相同的事：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u = core.std.ShufflePlanes(src, <span class="number">1</span>, vs.GRAY)</span><br><span class="line">mask = core.std.Binarize(u, <span class="number">5000</span>)</span><br><span class="line">mask = core.resize.Bilinear(mask, <span class="number">1920</span>, <span class="number">1080</span>)</span><br><span class="line">mask = core.std.Inflate(mask)</span><br><span class="line">merge = core.std.MaskedMerge(filtered, src, mask)</span><br></pre></td></tr></table></figure>

<p>你可能已经注意到了，我进行了同样的二值化处理，但同时调整了蒙版的大小并使其膨胀。调整大小的原因显然是因为色度平面在YUV420中的分辨率较低，但有些人可能对调整工具的选择产生疑惑；使用双线性(bilinear)调整器会导致模糊，这意味着周围的像素也会受到影响，这通常对抗锯齿很有效。出于同样的原因，我增加了一个额外的 <code>std.Inflate</code>，尽管它通常对亮度平面比色度平面更有效。</p>
<p>更有趣和有用的蒙版是边缘蒙版和去烙印的特定蒙版。对于边缘蒙版，VapourSynth 用户有一个很大的优势，因为 <code>kgf.retinex_edgemask</code> 令人难以置信的准确，有着不可思议的结果。这个边缘遮罩获取源图像，使用 retinex 算法来提高黑暗区域的对比度和亮度，然后在 <code>Kirsch</code> 遮罩的基础上叠加一个 <code>TCanny</code> 遮罩。它的两个常见的用途是去色带和抗锯齿。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retinex = kgf.retinex_edgemask(src)</span><br><span class="line">antialiasingmask = retinex.std.Binarize(<span class="number">65000</span>).std.Inflate()</span><br><span class="line">antialiasingmerge = core.std.MaskedMerge(src, antialiasing,antialiasingmask)</span><br><span class="line">debandmask = retinex.std.Binarize(<span class="number">7000</span>).std.Maximum().std.Inflate()</span><br><span class="line">merge = core.std.MaskedMerge(deband, src, debandmask)</span><br></pre></td></tr></table></figure>

<p>对于去色带，你通常希望从源文件中获取尽可能多的内容，以避免破坏细节，因此我们在低值处进行二值化，并用<code>std.Maximum</code> 和 <code>std.Inflate</code> 来增强蒙版。我们想用这个遮罩将源文件中的内容添加到去色带处理的片段中。我们可以用很多不同的方法来处理蒙版，比如把超过阈值的东西都乘以某个值 <code>(std.Expr(retinex, &quot;x 7000 &gt; x 10 * x ?&quot;)</code>，只让它最大化和膨胀，让它保持原样，或者你可以做任何想做的操作。</p>
<p>以一种非常不同但又相似的方式，抗锯齿通常只想应用于明显的边缘，因此我们在一个高值上进行二值化。<code>std.Inflate</code> 的调用就十分重要，它可以让我们获得应用抗锯齿的全部特效。在这里，我们想通过我们的遮罩将抗锯齿添加到源文件中。</p>
<p>其他有用的**边缘遮罩(edge mask)**包括：</p>
<ul>
<li><code>std.Prewitt</code></li>
<li><code>std.Sobel</code> 通常比Prewitt更准确，但如果不选择 <code>Kirsch</code> 或 <code>Retinex</code> 遮罩，建议同时测试这两种遮罩。</li>
<li><code>tcanny.TCanny</code> 这基本上是在一个模糊的片段上抛出了一个 <code>Sobel</code> 遮罩。</li>
<li><code>kgf.kirsch</code> 在明亮的场景中会产生与 <code>retinex_edgemask</code> 几乎相同的结果，因为其被包含其中。处理速度比其他的慢，但因它使用了更多的方法(directions)，会给你带来很好的结果。</li>
</ul>
<p>所有这些的比较可以在附录中的图24和25下找到。</p>
<p>虽然边缘遮罩对去色带很有帮助，但它们往往也会检测到色带本身的边缘，而且通常相当慢。很好的替代品包括 <code>GradFun3</code> 和 <code>debandmask</code>。 后者非常快，能得到更好的结果，但它经由膨胀处理。对于 <code>GradFun3</code>，你可以使用Frechdachs制作的 <code>Fag3kdb</code>。我建议尽可能使用 <code>debandmask</code>，但在较暗的场景中，边缘遮罩通常被证明能产生更好的结果，所以要做一些测试进行选择。要从 <code>GradFun3</code> 中得到一个蒙版输出，你可以这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask = fvf.GradFun3(src, debug=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/Picture/AHDVEG-pics/Figure14.png" alt="Figure14"></p>
<p>图14：<code>GradFun3</code>（左上）、<code>debandmask</code>（右上）、<code>retinex_edgemask</code>（左下）和 <code>retinex_edgemask.std.Maximum().std.Inflate()</code>（右下）的比较</p>
<p>针对那些对使用和不使用遮罩的强力去色带之间的区别感到好奇的人，我们准备了附录中的图26作为参考，对比一个简单的边缘遮罩对去色带的影响。当使用亮度&#x2F;色度遮罩时，请不要忘记测试你是否应该在之前的遮罩上使用适当的边缘遮罩或去色带专用遮罩，因为简单的亮度遮罩会使边缘被破坏。附录中的图27和28有这方面的例子。</p>
<p>现在我们已经介绍了常见的蒙版，让我们继续介绍那些能帮助你操作的蒙版或创建你自己的蒙版。在这我只简单介绍，因为他们的文档写的非常详细。</p>
<ul>
<li><p><code>std.Maximum/Minimum</code>：用这个来放大或缩小你的蒙版，你可能还想应用 <code>coordinates=[0, 1, 2, 3, 4, 5, 6, 7]</code>，使用任何适宜的数值来指定周围像素的权重。</p>
</li>
<li><p><code>std.Inflate/Deflate</code>：与前面的函数类似，但它不是应用像素的最大值，而是将它们合并，这将使你得到一个轻微的边缘模糊。在大多数蒙版的末尾很有用，这样你可以在蒙版区域之间得到一个轻微的过渡。</p>
</li>
<li><p><code>std.Expr</code>：众所周知，这是一个非常复杂的函数。通过反向波兰语符号应用逻辑。如果你还不知道，可以去维基百科粗略了解。你可以用它做一些很酷的事情，比如让一些像素变亮，同时保持其他像素不变（而不是像 <code>std.Binarize</code> 那样让它们变暗）：<code>std.Expr(&quot;x 2000 &gt; x 10 * x ?&quot;)</code>。 这将使2000以上的每个值都乘以10，而其他的则保持不变。有一个很好的用例是，在数值之间：<code>std.Expr(&quot;x 10000 &gt; x 15000 &lt; and x &#123;&#125; = x 0 = ?&quot;.format(2**src.format.bits_per_sample - 1))</code>。<br>这使得10000和15000之间的每一个值都是位深所允许的最大值，其余置零，就像 <code>std.Binarize</code> 蒙版做的那样。几乎每一个函数都可以或者已经通过这种方式表达了。</p>
</li>
<li><p><code>std.MakeDiff</code> 与 <code>std.MergeDiff</code>：字如其名。用法可以是将一些东西应用于降噪的片段，然后将片段合并回来，正如在降噪部分所阐述的那样。</p>
</li>
<li><p><code>std.Convolution</code>：从本质上讲，对你的像素应用矩阵。其文档对此进行了很好的说明，如果没有理解，请仔细阅读。很多蒙版是通过卷积核定义的。 你可以用它来做很多事情，就像 <code>std.Expr</code> 一样。例如，如果你想平均一个像素周围的所有数值，那么使用 <code>std.Convolution([1, 1, 1, 1, 0, 1, 1, 1, 1])</code>。</p>
</li>
<li><p><code>std.Transpose</code>转置（即翻转）你的片段。</p>
</li>
<li><p><code>std.Turn180</code>：旋转180度。</p>
</li>
<li><p><code>std.BlankClip</code>：生成一帧纯色的画面。你可以用它来替换糟糕的背景，或者在整个影片中添加颗粒感但又不希望片尾字幕充满颗粒感的情况下使用。为了保持电视色彩范围，你可以对8-bit黑色使用 <code>std.BlankClip(src, color=[16, 128, 128])</code>。这个函数在制作基于区域的蒙版时也很有用。</p>
</li>
<li><p><code>std.Invert</code>：不言而喻。你也可以只交换通过蒙版合并片段，而不是这样做。</p>
</li>
<li><p><code>std.Limiter</code>：你可以用它将像素限制在某些数值。对维持电视色彩范围很有用（<code>std.Limiter(min=16, max=235)</code>）。</p>
</li>
<li><p><code>std.Median</code>：这将用其附近的中位值替换每个像素。大部分情况不会用到。</p>
</li>
<li><p><code>std.StackHorizontal</code> &#x2F; <code>std.StackVertical</code>：将片段上下&#x2F;左右拼叠</p>
</li>
<li><p><code>std.Merge</code>：这可以让你将两个具有给定权重的片段合并。权重为0将返回第一个片段，而1将返回第二个片段。你需要提供给函数一个片段列表和一个权重列表。下面是如何将第二个片段的色度平面合并到第一个片段的亮度平面中：<code>std.Merge([first, second], [0, 1])</code>。如果没有给出第三个值，第二个值将被应用于第三个平面。</p>
</li>
<li><p><code>std.MaskedMerge</code>：根据给定的蒙版，将第二个片段与第一个片段合并。</p>
</li>
<li><p><code>std.ShufflePlanes</code>：从一个片段中提取或合并平面。例如，你可以用 <code>std.ShufflePlanes(src, 0, vs.GRAY)</code> 获得亮度平面。</p>
</li>
</ul>
<p>如果你想只在某个区域应用某个东西，你可以使用封装好的函数 <code>rekt34</code> 或 <code>rekt_fast</code>。后者只将你的函数应用于给定的区域，这就加快了它的速度，对于抗锯齿和类似的慢速慢速滤镜相当有用。关于它的一些封装好的函数已经出世，比如用于抗锯齿的 <code>rektaa</code>。<code>rekt_fast lambda</code> 函数相关，所以你应该输入<code>rekt_fast(src, lambda x: core.f3kdb.Deband(x))</code>，而非 <code>core.f3kdb.Deband(src)</code>。</p>
<p>还有一个非常特别的函数是 <code>std.FrameEval</code>。它允许你对一个片段的每一帧进行评估，并应用一个特定于帧的函数。这很令人困惑，但在 VapourSynth 的文档中有<a target="_blank" rel="noopener" href="http://www.vapoursynth.com/doc/functions/frameeval.html">一些不错的例子</a>。现在，除非你有兴趣写一个需要这样做的函数，否则你可能永远不会使用它。然而，许多函数都使用它，包括<code>kgf.adaptive_grain</code>、<code>awf.FrameInfo</code>、<code>fvf.AutoDeblock</code>、<code>TAAmbk</code>等。我能想到的一个例子是，根据帧的类型应用不同的去色带工具来展示这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FrameTypeDeband</span>(<span class="params">n, clip</span>):</span><br><span class="line">	<span class="keyword">if</span> clip.get_frame(n).props._PictType.decode() == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> core.f3kdb.Deband(clip, y=<span class="number">64</span>, cr=<span class="number">0</span>, cb=<span class="number">0</span>, grainy=<span class="number">64</span>, grainc=<span class="number">0</span>,keep_tv_range=<span class="literal">True</span>, dynamic_grain=<span class="literal">False</span>)</span><br><span class="line">	<span class="keyword">elif</span> clip.get_frame(n).props._PictType.decode() == <span class="string">&quot;P&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> core.f3kdb.Deband(clip, y=<span class="number">48</span>, cr=<span class="number">0</span>, cb=<span class="number">0</span>, grainy=<span class="number">64</span>, grainc=<span class="number">0</span>,keep_tv_range=<span class="literal">True</span>, dynamic_grain=<span class="literal">False</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> core.f3kdb.Deband(clip, y=<span class="number">32</span>, cr=<span class="number">0</span>, cb=<span class="number">0</span>, grainy=<span class="number">64</span>, grainc=<span class="number">0</span>,</span><br><span class="line">			keep_tv_range=<span class="literal">True</span>, dynamic_grain=<span class="literal">False</span>)</span><br><span class="line">out = core.std.FrameEval(src, functools.partial(FrameTypeDeband, clip=src)</span><br></pre></td></tr></table></figure>

<p>如果你想了解更多，我建议阅读<a target="_blank" rel="noopener" href="https://guide.encode.moe/encoding/masking-limiting-etc.html">Irrational Encoding Wizardry GitHub小组的指南</a> ，并阅读大多数你喜欢的 VapourSynth 和 Python 函数相关手册。几乎所有的优秀压制员都应该使用一些蒙版，或者针对特定的情况开发自己的蒙版。</p>
<h4 id="3-2-15-滤镜顺序"><a href="#3-2-15-滤镜顺序" class="headerlink" title="3.2.15 滤镜顺序"></a>3.2.15 滤镜顺序</h4><p>以错误的顺序使用滤镜会导致破坏性的或失败的过滤。正因为如此，建议使用以下顺序：</p>
<p><img src="/Picture/AHDVEG-pics/Figure15.png" alt="Figure15"></p>
<p>图15：推荐应用每个滤镜的顺序。在某些情况下，降噪可能必须先于调整大小前进行。</p>
<h4 id="3-2-16-脚本范例"><a href="#3-2-16-脚本范例" class="headerlink" title="3.2.16 脚本范例"></a>3.2.16 脚本范例</h4><p>Mirai (2018):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vapoursynth <span class="keyword">as</span> vs</span><br><span class="line">core = vs.get_core()</span><br><span class="line"><span class="keyword">import</span> fvsfunc <span class="keyword">as</span> fvf</span><br><span class="line"><span class="keyword">import</span> mvsfunc <span class="keyword">as</span> mvf</span><br><span class="line"><span class="keyword">import</span> kagefunc <span class="keyword">as</span> kgf</span><br><span class="line"><span class="keyword">import</span> vsTAAmbk <span class="keyword">as</span> taa</span><br><span class="line"><span class="keyword">import</span> havsfunc <span class="keyword">as</span> haf</span><br><span class="line"><span class="keyword">from</span> debandmask <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> rekt <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> adptvgrnMod <span class="keyword">import</span> *</span><br><span class="line">src = core.ffms2.Source(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Going up to 16-bit, as I like to work in this depth.</span></span><br><span class="line">b16 = mvf.Depth(src, <span class="number">16</span>).std.Crop(top=<span class="number">20</span>, bottom=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filling the first row and filling the chroma of the first two rows.</span></span><br><span class="line">fb1 = core.fb.FillBorders(b16, top=<span class="number">1</span>)</span><br><span class="line">fb2 = core.fb.FillBorders(b16, top=<span class="number">2</span>)</span><br><span class="line">b16 = core.std.Merge(fb1, fb2, [<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Super light denoising. No point in BM3D for denoising this weak.</span></span><br><span class="line">b16 = core.knlm.KNLMeansCL(b16, a=<span class="number">3</span>, h=<span class="number">0.1</span>, d=<span class="number">2</span>, device_type=<span class="string">&#x27;gpu&#x27;</span>,</span><br><span class="line">device_id=<span class="number">0</span>, channels=<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">b16 = core.knlm.KNLMeansCL(b16, a=<span class="number">2</span>, h=<span class="number">0.2</span>, d=<span class="number">1</span>, device_type=<span class="string">&#x27;gpu&#x27;</span>,</span><br><span class="line">device_id=<span class="number">0</span>, channels=<span class="string">&#x27;UV&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Soft dehalo.</span></span><br><span class="line">b16 = haf.FineDehalo(b16, rx=<span class="number">2.0</span>, thmi=<span class="number">80</span>, thma=<span class="number">128</span>, thlimi=<span class="number">25</span>, thlima=<span class="number">100</span>,darkstr=<span class="number">0.5</span>, brightstr=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dirty lines during credits. Cleaning edges, then halos.</span></span><br><span class="line">cf = core.std.Crop(b16, left=<span class="number">94</span>, top=<span class="number">292</span>, right=<span class="number">1018</span>,bottom=<span class="number">290</span>).fb.FillBorders(top=<span class="number">1</span>, left=<span class="number">1</span>,</span><br><span class="line">bottom=<span class="number">1</span>).edgefixer.ContinuityFixer(left=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], top=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],right=<span class="number">2</span>, bottom= [<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>], radius=<span class="number">15</span>)</span><br><span class="line">fb = rekt_fast(b16, <span class="keyword">lambda</span> x: core.fb.FillBorders(x, left=<span class="number">2</span>, top=<span class="number">2</span>,right=<span class="number">1</span>, bottom=<span class="number">2</span>).std.Merge(cf, [<span class="number">1</span>,<span class="number">0</span>]), left=<span class="number">94</span>, top=<span class="number">292</span>, right=<span class="number">1018</span>,bottom=<span class="number">290</span>)</span><br><span class="line">dh = rekt_fast(fb, <span class="keyword">lambda</span> x: haf.FineDehalo(x, rx=<span class="number">2.0</span>, thmi=<span class="number">80</span>, thma=<span class="number">128</span>,thlimi=<span class="number">25</span>, thlima=<span class="number">100</span>, darkstr=<span class="number">0.5</span>, brightstr=<span class="number">2.3</span>), left=<span class="number">94</span>, top=<span class="number">292</span>,right=<span class="number">1018</span>, bottom=<span class="number">290</span>)</span><br><span class="line">sf = fvf.rfs(b16, dh, <span class="string">&quot;[1434 2296]&quot;</span>)</span><br><span class="line">cf = core.std.Crop(b16, left=<span class="number">94</span>, top=<span class="number">302</span>, right=<span class="number">1018</span>,bottom=<span class="number">300</span>).fb.FillBorders(left=<span class="number">1</span>).edgefixer.ContinuityFixer(left=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], top=<span class="number">1</span>, right=<span class="number">1</span>, bottom= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], radius=<span class="number">5</span>)</span><br><span class="line">fb = rekt_fast(b16, <span class="keyword">lambda</span> x: core.fb.FillBorders(x, left=<span class="number">2</span>, top=<span class="number">1</span>,right=<span class="number">1</span>, bottom=<span class="number">2</span>).std.Merge(cf, [<span class="number">1</span>,<span class="number">0</span>]), left=<span class="number">94</span>, top=<span class="number">302</span>, right=<span class="number">1018</span>,bottom=<span class="number">300</span>)</span><br><span class="line">dh = rekt_fast(fb, <span class="keyword">lambda</span> x: haf.FineDehalo(x, rx=<span class="number">2.0</span>, thmi=<span class="number">80</span>, thma=<span class="number">128</span>,thlimi=<span class="number">25</span>, thlima=<span class="number">100</span>, darkstr=<span class="number">0.5</span>, brightstr=<span class="number">1.5</span>), left=<span class="number">94</span>, top=<span class="number">302</span>,right=<span class="number">1018</span>, bottom=<span class="number">300</span>)</span><br><span class="line">sf = fvf.rfs(sf, dh, <span class="string">&quot;[133711 135117] [135360 136057] [136143 137216] [137282 138288] [138377 138757] [138820 140782]&quot;</span>)</span><br><span class="line">cf = core.std.Crop(b16, left=<span class="number">94</span>, top=<span class="number">302</span>, right=<span class="number">1018</span>,bottom=<span class="number">300</span>).fb.FillBorders(left=<span class="number">1</span>).edgefixer.ContinuityFixer(left=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], top=<span class="number">1</span>, right=<span class="number">1</span>, bottom= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], radius=<span class="number">5</span>)</span><br><span class="line">fb = rekt_fast(b16, <span class="keyword">lambda</span> x: core.fb.FillBorders(x, left=<span class="number">2</span>, top=<span class="number">1</span>,right=<span class="number">1</span>, bottom=<span class="number">2</span>).std.Merge(cf, [<span class="number">1</span>,<span class="number">0</span>]), left=<span class="number">94</span>, top=<span class="number">302</span>, right=<span class="number">1018</span>,bottom=<span class="number">300</span>)</span><br><span class="line">dh = rekt_fast(fb, <span class="keyword">lambda</span> x: haf.FineDehalo(x, rx=<span class="number">2.0</span>, thmi=<span class="number">80</span>, thma=<span class="number">128</span>,thlimi=<span class="number">25</span>, thlima=<span class="number">100</span>, darkstr=<span class="number">0.5</span>, brightstr=<span class="number">1.5</span>).f3kdb.Deband(y=<span class="number">48</span>,cb=<span class="number">0</span>, cr=<span class="number">0</span>, <span class="built_in">range</span>=<span class="number">5</span>, grainy=<span class="number">64</span>, grainc=<span class="number">32</span>, output_depth=<span class="number">16</span>,keep_tv_range=<span class="literal">True</span>), left=<span class="number">94</span>, top=<span class="number">302</span>, right=<span class="number">1018</span>, bottom=<span class="number">300</span>)</span><br><span class="line">sf = fvf.rfs(sf, dh, <span class="string">&quot;[135118 135296] [138305 138376]&quot;</span>)</span><br><span class="line">mask = core.std.ShufflePlanes(b16, <span class="number">0</span>, vs.GRAY).std.Trim(<span class="number">2400</span>, <span class="number">2401</span>) *src.num_frames</span><br><span class="line">mask = rekt(mask, core.std.BlankClip(b16, <span class="number">1920</span>, <span class="number">1038</span>, <span class="built_in">format</span>=vs.GRAY16),left=<span class="number">666</span>, top=<span class="number">292</span>, right=<span class="number">1114</span>, bottom=<span class="number">744</span>)</span><br><span class="line">dh_lim = core.std.MaskedMerge(dh, b16, mask)</span><br><span class="line">sf = fvf.rfs(sf, dh_lim, <span class="string">&quot;[2297 2329]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4:3 cropped scene. Replacing borders with my own black borders in order to keep them from having a different shade of black.</span></span><br><span class="line">crop = core.std.Crop(b16, left=<span class="number">254</span>, right=<span class="number">254</span>)</span><br><span class="line">fb = core.fb.FillBorders(crop, left=<span class="number">1</span>, right=<span class="number">1</span>).std.Merge(crop,[<span class="number">1</span>,<span class="number">0</span>]).edgefixer.ContinuityFixer(left=<span class="number">1</span>, right=<span class="number">1</span>, top=<span class="number">0</span>, bottom=<span class="number">0</span>,</span><br><span class="line">radius=<span class="number">50</span>).std.AddBorders(left=<span class="number">254</span>, right=<span class="number">254</span>, color=[<span class="number">4096</span>, <span class="number">32768</span>,<span class="number">32768</span>])</span><br><span class="line">sf = fvf.rfs(sf, fb, <span class="string">&quot;[33448 34196]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Placebo edgemask binarized so we only get the obvious edges, then</span></span><br><span class="line">inflated.</span><br><span class="line">mask = kgf.retinex_edgemask(b16).std.Binarize(<span class="number">65500</span>).std.Maximum().std.Inflate()</span><br><span class="line"><span class="comment"># Strong aliasing.</span></span><br><span class="line">aa = taa.TAAmbk(b16, aatype=<span class="number">2</span>, mtype=<span class="number">0</span>, opencl=<span class="literal">False</span>)</span><br><span class="line">aa = core.std.MaskedMerge(b16, aa, mask)</span><br><span class="line">sf = fvf.ReplaceFramesSimple(sf, aa, mappings=<span class="string">&quot;[4225 4727] [18340 18387] [129780 131148]&quot;</span>)</span><br><span class="line"><span class="comment"># Mild aliasing.</span></span><br><span class="line">aa = taa.TAAmbk(b16, aatype=<span class="number">3</span>, mtype=<span class="number">0</span>, opencl=<span class="literal">False</span>)</span><br><span class="line">aa = core.std.MaskedMerge(b16, aa, mask)</span><br><span class="line">sf = fvf.ReplaceFramesSimple(sf, aa, mappings=<span class="string">&quot;[55394 55451] [55649 55782] [120840 120901]&quot;</span>)</span><br><span class="line"><span class="comment"># Very strong aliasing.</span></span><br><span class="line">aa = taa.TAAmbk(b16, aatype=<span class="number">6</span>, mtype=<span class="number">0</span>, repair=<span class="number">16</span>)</span><br><span class="line">aa = core.std.MaskedMerge(b16, aa, mask)</span><br><span class="line">sf = fvf.ReplaceFramesSimple(sf, aa, mappings=<span class="string">&quot;[107405 107462]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strong aliasing that I tried to fix with a terrible mask.</span></span><br><span class="line">mask = kgf.retinex_edgemask(b16).std.Binarize(<span class="number">65500</span>).std.Maximum().std.Minimum(coordinates=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]).std.Deflate().std.Deflate()</span><br><span class="line">aa = taa.TAAmbk(b16, aatype=<span class="number">6</span>, mtype=<span class="number">0</span>, opencl=<span class="literal">False</span>)</span><br><span class="line">aa = core.std.MaskedMerge(b16, aa, mask)</span><br><span class="line">sf = fvf.ReplaceFramesSimple(sf, aa, mappings=<span class="string">&quot;[55510 55580]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># I simply marked this, it would require a lot of work, so I just decidedagainst doing this.</span></span><br><span class="line"><span class="comment">#sf = fvf.rfs(sf, ?, &quot;[65880 66478]&quot;)</span></span><br><span class="line"><span class="comment">#sf = fvf.rfs(sf, ?, &quot;[120902 121051] [121790 121905] [122388 122528] [123038 123153] [126686 126812] [128740 128953]&quot;)  #Banding? [121063 121095] [121906 121968] [122530 122576]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Graining an area with no grain.</span></span><br><span class="line">gr = adptvgrnMod(b16, strength=<span class="number">2.5</span>, size=<span class="number">1.25</span>, sharp=<span class="number">35</span>, static=<span class="literal">False</span>,</span><br><span class="line">luma_scaling=<span class="number">3</span>, grain_chroma=<span class="literal">False</span>)</span><br><span class="line">sf = fvf.rfs(sf, gr, <span class="string">&quot;[120840 120901]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debanding with the standard debandmask. All of these debanding areas had almost no grain, so I added some on top.</span></span><br><span class="line">dbmask = debandmask(b16, lo=<span class="number">6144</span>, hi=<span class="number">12288</span>, lothr=<span class="number">320</span>, hithr=<span class="number">384</span>, mrad=<span class="number">2</span>)</span><br><span class="line">deband = core.f3kdb.Deband(b16, y=<span class="number">34</span>, cb=<span class="number">0</span>, cr=<span class="number">0</span>, <span class="built_in">range</span>=<span class="number">10</span>, grainy=<span class="number">16</span>,grainc=<span class="number">8</span>, output_depth=<span class="number">16</span>, keep_tv_range=<span class="literal">True</span>)</span><br><span class="line">merge = core.std.MaskedMerge(deband, b16, dbmask)</span><br><span class="line">merge = adptvgrnMod(merge, strength=<span class="number">2</span>, size=<span class="number">1.5</span>, sharp=<span class="number">25</span>, static=<span class="literal">False</span>,luma_scaling=<span class="number">5</span>, grain_chroma=<span class="literal">True</span>)</span><br><span class="line">sf = fvf.rfs(sf, merge, <span class="string">&quot;[3174 3254] [3540 3655] [7463 7749] [41056 41597] [63482 64106] [91033 91164]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debanding with retinex.</span></span><br><span class="line">mask = kgf.retinex_edgemask(b16).std.Maximum().std.Inflate().std.Maximum().std.Inflate()</span><br><span class="line">deband = core.f3kdb.Deband(b16, y=<span class="number">48</span>, cb=<span class="number">48</span>, cr=<span class="number">48</span>, <span class="built_in">range</span>=<span class="number">15</span>, grainy=<span class="number">16</span>, grainc=<span class="number">16</span>, output_depth=<span class="number">16</span>, keep_tv_range=<span class="literal">True</span>)</span><br><span class="line">merge = core.std.MaskedMerge(deband, b16, mask)</span><br><span class="line">merge = adptvgrnMod(merge, strength=<span class="number">2.2</span>, size=<span class="number">1.25</span>, sharp=<span class="number">15</span>, static=<span class="literal">False</span>,luma_scaling=<span class="number">5</span>, grain_chroma=<span class="literal">True</span>)</span><br><span class="line">sf = fvf.rfs(sf, merge, <span class="string">&quot;[77952 78034] [93358 93443]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debanding with gradfun3 mask.</span></span><br><span class="line">deband = Fag3kdb(b16, thry=<span class="number">54</span>, thrc=<span class="number">54</span>, radiusy=<span class="number">10</span>, radiusc=<span class="number">6</span>, grainy=<span class="number">32</span>, grainc=<span class="number">16</span>)</span><br><span class="line">sf = fvf.rfs(sf, deband, <span class="string">&quot;[25 263]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dithering back to 8-bit.</span></span><br><span class="line">final = mvf.Depth(sf, <span class="number">8</span>, dither=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replacing black areas with a simple black screen in order to keep slight variations from happening. Usually not necessary, though.</span></span><br><span class="line">blank = core.std.BlankClip(src.std.Crop(top=<span class="number">20</span>, bottom=<span class="number">22</span>), <span class="number">1920</span>, <span class="number">1038</span>, color=[<span class="number">16</span>, <span class="number">128</span>, <span class="number">128</span>])</span><br><span class="line">final = fvf.rfs(final, blank, <span class="string">&quot;[0 24] [1352 1433] [58945 59016] [75563 75633] [78351 78421] [81130 81141] [81261 81272] [93967 94062 [99889 99959] [118093 118147] [140928 140951]&quot;</span>)</span><br><span class="line"></span><br><span class="line">final.set_output()</span><br></pre></td></tr></table></figure>

<p>Sword Art Online: The Movie - Ordinal Scale (2017): </p>
<blockquote>
<p>Sword.Art.Online.The.Movie.Ordinal.Scale.2017.ITA.1080p.BluRay.AC3.x264.D-Z0N3</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vapoursynth <span class="keyword">as</span> vs</span><br><span class="line">core = vs.get_core()</span><br><span class="line"><span class="keyword">import</span> fvsfunc <span class="keyword">as</span> fvf</span><br><span class="line"><span class="keyword">import</span> kagefunc <span class="keyword">as</span> kgf</span><br><span class="line"><span class="keyword">import</span> havsfunc <span class="keyword">as</span> hvf</span><br><span class="line"><span class="keyword">import</span> vsTAAmbk <span class="keyword">as</span> taa</span><br><span class="line"><span class="keyword">import</span> fag3kdb</span><br><span class="line"><span class="keyword">import</span> nnedi3_rpow2 <span class="keyword">as</span> nnrp</span><br><span class="line"></span><br><span class="line">src = core.ffms2.Source(<span class="string">&quot;&quot;</span>)</span><br><span class="line">resize = src <span class="comment"># I called this and was too lazy to change it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rescaling a flashback with grain.</span></span><br><span class="line">dn = core.knlm.KNLMeansCL(src, d=<span class="number">3</span>, a=<span class="number">1</span>, s=<span class="number">0</span>, h=<span class="number">1.5</span>, device_type=<span class="string">&quot;gpu&quot;</span>,</span><br><span class="line">device_id=<span class="number">1</span>, channels=<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">diff = core.std.MakeDiff(src, dn, planes=[<span class="number">0</span>])</span><br><span class="line">ds = fvf.Debicubic(dn, <span class="number">1280</span>, <span class="number">720</span>)</span><br><span class="line">us = nnrp.nnedi3_rpow2(ds, <span class="number">2</span>, <span class="number">1920</span>, <span class="number">1080</span>, kernel=<span class="string">&quot;Spline36&quot;</span>)</span><br><span class="line">merged = core.std.MergeDiff(us, diff, planes=[<span class="number">0</span>])</span><br><span class="line">src = fvf.ReplaceFramesSimple(resize, merged, mappings=<span class="string">&quot;[3418 3507] [3508 5145] [75916 76205] [76253 76323] [77720 77790]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rescaling a flashback without grain.</span></span><br><span class="line">ds = fvf.DescaleAA(dn, <span class="number">1280</span>, <span class="number">720</span>).std.MergeDiff(diff, planes=[<span class="number">0</span>])</span><br><span class="line">src = fvf.ReplaceFramesSimple(src, ds, mappings=<span class="string">&quot;[3298 3417]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Going to 16-bit. The above parts are in 8-bit because I was scared of performance issues.</span></span><br><span class="line">src = fvf.Depth(src, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># I like to establish a separate variable for 16-bit and leave src for 8-bit, but didn&#x27;t do that here. This is so I could copy-paste commands.</span></span><br><span class="line">b16 = src</span><br><span class="line"></span><br><span class="line"><span class="comment"># Anti-aliasing. As you might be able to tell, the crop and stacking could</span></span><br><span class="line">now be replaced by rekt_fast <span class="keyword">or</span> simply rektaa.</span><br><span class="line">aa = core.std.Crop(b16, left=<span class="number">400</span>, right=<span class="number">1006</span>)</span><br><span class="line">aa = taa.TAAmbk(aa, aatype=-<span class="number">3</span>, preaa=-<span class="number">1</span>, strength=<span class="number">0</span>, mtype=<span class="number">2</span>, opencl=<span class="literal">True</span>)</span><br><span class="line">left = core.std.Crop(b16, right=<span class="number">1920</span> - <span class="number">400</span>)</span><br><span class="line">right = core.std.Crop(b16, left=<span class="number">1920</span> - <span class="number">1006</span>)</span><br><span class="line">aa = core.std.StackHorizontal([left, aa, right]).std.Crop(top=<span class="number">208</span>, bottom=<span class="number">456</span>)</span><br><span class="line">top = core.std.Crop(b16, bottom=<span class="number">1080</span> - <span class="number">208</span>)</span><br><span class="line">bottom = core.std.Crop(b16, top=<span class="number">1080</span> - <span class="number">456</span>)</span><br><span class="line">aa = core.std.StackVertical([top, aa, bottom])</span><br><span class="line">sfaa = fvf.ReplaceFramesSimple(b16, aa, mappings=<span class="string">&quot;[42583 42813] [58812 59050] [65211 65281] [92132 92274]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debanding with a standard ass mask.</span></span><br><span class="line">db = b16.f3kdb.Deband( <span class="built_in">range</span>=<span class="number">15</span>, y=<span class="number">60</span>, cb=<span class="number">60</span>, cr=<span class="number">60</span>, grainy=<span class="number">22</span>, grainc=<span class="number">22</span>,</span><br><span class="line">output_depth=<span class="number">16</span>)</span><br><span class="line">mask = kgf.retinex_edgemask(b16).std.Inflate()</span><br><span class="line">merged = core.std.MaskedMerge(db, b16, mask)</span><br><span class="line">sfdb = fvf.ReplaceFramesSimple(sfaa, merged, mappings=<span class="string">&quot;[3508 3603] [17600 17706] [41865 42113] [76922 77488] [78444 78598] [81054 81280] [150853 150933] [152057 152288] [152324 152424] [152443 152508] [152521 152686] [171669 172433] [172561 172643] [170283 170557]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debanding values that were outside of the range of 10000-25000.</span></span><br><span class="line">db = b16.f3kdb.Deband(<span class="built_in">range</span>=<span class="number">10</span>, y=<span class="number">160</span>, cb=<span class="number">0</span>, cr=<span class="number">0</span>, grainy=<span class="number">28</span>, grainc=<span class="number">0</span>, output_depth=<span class="number">16</span>)</span><br><span class="line">mask = core.std.ShufflePlanes(b16, <span class="number">0</span>, vs.GRAY).std.Expr(<span class="string">&quot;x 10000 &lt; x 25000 &gt; or x 10 * x 10 / ?&quot;</span>)</span><br><span class="line">merged = core.std.MaskedMerge(db, b16, mask)</span><br><span class="line">sfdb = fvf.ReplaceFramesSimple(sfdb, merged, mappings=<span class="string">&quot; [96133 96273]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fixing dirty lines during credits. Again, rekt_fast would&#x27;ve been useful</span></span><br><span class="line">back then.</span><br><span class="line">bot = core.std.Crop(sfdb, top=<span class="number">1080</span> - <span class="number">330</span>)</span><br><span class="line">middle = core.std.Crop(sfdb, top=<span class="number">318</span>,bottom=<span class="number">330</span>).edgefixer.ContinuityFixer(top=<span class="number">1</span>, bottom=<span class="number">1</span>, left=<span class="number">0</span>, right=<span class="number">0</span>, radius=<span class="number">5</span>)</span><br><span class="line">fb = core.fb.FillBorders(middle, top=<span class="number">2</span>, bottom=<span class="number">2</span>)</span><br><span class="line">middle = core.std.Merge(fb, middle, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">top = core.std.Crop(sfdb, bottom=<span class="number">1080</span> - <span class="number">318</span>)</span><br><span class="line">merge = core.std.StackVertical([top, middle, bot])</span><br><span class="line">right = core.std.Crop(merge, left=<span class="number">1920</span> - <span class="number">134</span>)</span><br><span class="line">middle = core.std.Crop(merge, left=<span class="number">1018</span>, right=<span class="number">134</span>).edgefixer.ContinuityFixer(left=<span class="number">2</span>, right=<span class="number">2</span>, top=<span class="number">0</span>, bottom=<span class="number">0</span>, radius=<span class="number">5</span>)</span><br><span class="line">fb = core.fb.FillBorders(middle, left=<span class="number">2</span>, right=<span class="number">2</span>)</span><br><span class="line">middle = core.std.Merge(fb, middle, [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">left = core.std.Crop(merge, right=<span class="number">1920</span> - <span class="number">1018</span>)</span><br><span class="line">merge = core.std.StackHorizontal([left, middle, right])</span><br><span class="line">sfc = fvf.ReplaceFramesSimple(sfdb, merge, mappings=<span class="string">&quot;[165067 167168] [167403 169466] [169842 170557] [170558 171041]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dithering the result back to 8-bit.</span></span><br><span class="line">final = fvf.Depth(sfc, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">final.set_output()</span><br></pre></td></tr></table></figure>

<p>BTS - Blood, Sweat and Tears (2016)</p>
<blockquote>
<p>BTS - Blood, Sweat &amp; Tears 2016 1080p ProRes FLAC 2.0 AVC x264 10-bit - A.R.M.Y</p>
</blockquote>
<p>对<code>bandmask</code>的快问快答：</p>
<p>边缘遮罩通过寻找梯度大的区域来工作，所以最简单的卷积是<br>$$<br>\left[ \begin{matrix} 0 &amp; 0 &amp; 0\ 1 &amp; 0 &amp; -1 \ 0 &amp; 0 &amp; 0\end{matrix} \right]<br>$$<br>意思是我们要检查左边的像素和右边的像素之间的差异。 我们可以移动减法，通过检查与原始像素的差异来识别没有颗粒的区域。<br>$$<br>\left[ \begin{matrix} 0 &amp; 0 &amp; 0\ 1 &amp; -1 &amp; 0 \ 0 &amp; 0 &amp; 0\end{matrix} \right]<br>$$<br>不过，这并不是这里发生的事情；我们是在卷积的多次迭代后进行减法，所以我们得到了更多像素的梯度。然后我们将其二值化，最小化以去除噪声(noise)，然后再次最大化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vapoursynth <span class="keyword">as</span> vs</span><br><span class="line">core = vs.get_core()</span><br><span class="line"><span class="keyword">import</span> fvsfunc <span class="keyword">as</span> fvf</span><br><span class="line"><span class="keyword">import</span> kagefunc <span class="keyword">as</span> kgf</span><br><span class="line"><span class="keyword">import</span> havsfunc <span class="keyword">as</span> hvf</span><br><span class="line"><span class="keyword">from</span> adptvgrnMod <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> rekt <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> bandmask <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load, go to high bit depth, and crop.</span></span><br><span class="line">src = core.ffms2.Source(<span class="string">&quot;Blood, Sweat &amp; Tears ����_BTS �����-187617728.mov&quot;</span>)</span><br><span class="line">hbd = fvf.Depth(src, <span class="number">16</span>)</span><br><span class="line">crp = hbd.std.Crop(top=<span class="number">134</span>, bottom=<span class="number">134</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># One scene has four lines missing at the bottom and dirty lines elsewhere.</span></span><br><span class="line"><span class="comment"># Every plane was fixed individually.</span></span><br><span class="line">acr = crp.std.Crop(bottom=<span class="number">4</span>)</span><br><span class="line">ycr = acr.std.ShufflePlanes(<span class="number">0</span>, vs.GRAY)</span><br><span class="line">ucr = acr.std.ShufflePlanes(<span class="number">1</span>, vs.GRAY)</span><br><span class="line">vcr = acr.std.ShufflePlanes(<span class="number">2</span>, vs.GRAY)</span><br><span class="line">ufx = rektlvls(ucr, [ucr.height - <span class="number">2</span>], [-<span class="number">6.5</span>], prot_val=<span class="number">0</span>).fb.FillBorders(top=<span class="number">1</span>, mode=<span class="string">&quot;fillmargins&quot;</span>).cf.ContinuityFixer(bottom=<span class="number">1</span>, radius=<span class="number">3</span>)</span><br><span class="line">vfx = vcr.cf.ContinuityFixer(bottom=<span class="number">3</span>, radius=<span class="number">5</span>).fb.FillBorders(bottom=<span class="number">2</span>, top=<span class="number">1</span>, mode=<span class="string">&quot;fillmargins&quot;</span>)</span><br><span class="line">lvl = rektlvls(ycr, [ycr.height - <span class="number">2</span>, ycr.height - <span class="number">3</span>], [-<span class="number">30</span>, -<span class="number">6</span>], prot_val=<span class="number">10</span>)</span><br><span class="line">fmg = lvl.cf.ContinuityFixer(bottom=<span class="number">2</span>, radius=<span class="number">3</span>).fb.FillBorders(bottom=<span class="number">1</span>, top=<span class="number">1</span>, mode=<span class="string">&quot;fillmargins&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Merge fixes and change subsampling to 4:2:0, then add borders.</span></span><br><span class="line">acr = core.std.ShufflePlanes([fmg, ufx, vfx], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], vs.YUV)</span><br><span class="line">rsz = acr.resize.Spline36(<span class="built_in">format</span>=vs.YUV420P16)</span><br><span class="line">adb = rsz.std.AddBorders(bottom=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rest of the video only has one line missing top and bottom. Fixed and subsampling changed.</span></span><br><span class="line">fmg = crp.fb.FillBorders(top=<span class="number">1</span>, bottom=<span class="number">1</span>, mode=<span class="string">&quot;fillmargins&quot;</span>)</span><br><span class="line">rsz = fmg.resize.Spline36(<span class="built_in">format</span>=vs.YUV420P16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spliced the fix in with the rest.</span></span><br><span class="line">trm = rsz.std.Trim(<span class="number">0</span>, <span class="number">5232</span>) + adb.std.Trim(<span class="number">5233</span>, <span class="number">5260</span>) + rsz.std.Trim(<span class="number">5261</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Luma debanding during a couple scenes with graining.</span></span><br><span class="line">dbn = trm.f3kdb.Deband(y=<span class="number">64</span>, cr=<span class="number">0</span>, cb=<span class="number">0</span>, <span class="built_in">range</span>=<span class="number">6</span>, grainy=<span class="number">0</span>, grainc=<span class="number">0</span>,</span><br><span class="line">output_depth=<span class="number">16</span>)</span><br><span class="line">msk = kgf.retinex_edgemask(trm).std.Binarize(<span class="number">11000</span>).std.Maximum().std.Inflate()</span><br><span class="line">mrg = dbn.std.MaskedMerge(trm, msk)</span><br><span class="line">grn = adptvgrnMod(mrg, size=<span class="number">1.4</span>, sharp=<span class="number">90</span>, luma_scaling=<span class="number">4</span>, grainer=<span class="keyword">lambda</span> x: core.grain.Add(x, var=<span class="number">1.6</span>, uvar=<span class="number">1.0</span>, constant=<span class="literal">False</span>))</span><br><span class="line">snf = fvf.rfs(trm, grn, <span class="string">&quot;[1612 1616] [7779 7794]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Some blocking was fixed with bandmask, since no edges were present.</span></span><br><span class="line">bmk = bandmask(trm, <span class="number">200</span>).std.Crop(top=<span class="number">500</span>).std.AddBorders(top=<span class="number">500</span>)</span><br><span class="line">grn = adptvgrnMod(dbn, size=<span class="number">1.3</span>, sharp=<span class="number">90</span>, luma_scaling=<span class="number">4</span>, grainer=<span class="keyword">lambda</span> x: core.grain.Add(x, var=<span class="number">.4</span>, uvar=<span class="number">.3</span>, constant=<span class="literal">False</span>))</span><br><span class="line">mrg = trm.std.MaskedMerge(grn, bmk)</span><br><span class="line">snf = fvf.rfs(snf, mrg, <span class="string">&quot;[7964 7980] [8009 8018]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># One scene has missing grain, so used bandmask and adptvgrnMod to fix this.</span></span><br><span class="line"><span class="comment"># I got frustrated and started copy pasting random Maximize/Inflate calls.</span></span><br><span class="line">bmk = bandmask(trm, thr=<span class="number">300</span>)</span><br><span class="line">lmk = trm.std.ShufflePlanes(<span class="number">0</span>,</span><br><span class="line">vs.GRAY).std.Binarize(<span class="number">55000</span>).std.Maximum().std.Maximum().std.Maximum().std.Maximum().std.Maximum()</span><br><span class="line">gmk = core.std.Expr([bmk, lmk], <span class="string">&quot;x y -&quot;</span>).std.Crop(bottom=<span class="number">225</span>,top=<span class="number">100</span>).std.AddBorders(bottom=<span class="number">225</span>, top=<span class="number">100</span>).std.Maximum().std.Inflate().std.Maximum().std.Inflate().std.Maximum().std.Maximum().std.Maximum().std.Maximum().std.Maximum().std.Maximum().std.Inflate().std.Inflate().std.Inflate().std.Inflate().std.Inflate().std.Inflate().std.Inflate()</span><br><span class="line">gmk = kgf.iterate(gmk, core.std.Maximum, <span class="number">3</span>)</span><br><span class="line">grn = adptvgrnMod(trm, size=<span class="number">1.2</span>, sharp=<span class="number">80</span>, luma_scaling=<span class="number">1</span>, grainer=<span class="keyword">lambda</span>  x: core.grain.Add(x, var=<span class="number">1.4</span>, uvar=<span class="number">1.0</span>, constant=<span class="literal">False</span>))</span><br><span class="line">mrg = core.std.MaskedMerge(trm, grn, gmk)</span><br><span class="line">snf = fvf.rfs(snf, mrg, <span class="string">&quot;[7579 7778]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dehalo on one scene.</span></span><br><span class="line">fdh = hvf.FineDehalo(trm)</span><br><span class="line">grn = adptvgrnMod(fdh, size=<span class="number">1.2</span>, sharp=<span class="number">80</span>, luma_scaling=<span class="number">8</span>, grainer=<span class="keyword">lambda</span> x: core.grain.Add(x, var=<span class="number">.8</span>, uvar=<span class="number">.5</span>, constant=<span class="literal">False</span>))</span><br><span class="line">snf = fvf.rfs(snf, grn, <span class="string">&quot;[6523 6591]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dither to output depth.</span></span><br><span class="line">out = fvf.Depth(snf, <span class="number">10</span>)</span><br><span class="line">out.set_output()</span><br></pre></td></tr></table></figure>

<p>其他可供阅读的有趣脚本：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/blaze077/9025d2c1a9a59d63f0168e5fd6f9cd31">https://gist.github.com/blaze077/9025d2c1a9a59d63f0168e5fd6f9cd31</a> Kaiji episode 1 by blaze077</li>
<li><a target="_blank" rel="noopener" href="https://pastebin.com/q469qUcU">https://pastebin.com/q469qUcU</a> How to IVTC by eXmendiC</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Beatrice-Raws/encode-scripts">https://github.com/Beatrice-Raws/encode-scripts</a> Various scripts by BeatriceRaws</li>
<li><a target="_blank" rel="noopener" href="https://github.com/LightArrowsEXE/Encoding-Projects">https://github.com/LightArrowsEXE/Encoding-Projects</a> Various scripts by LightArrowsEXE</li>
<li><a target="_blank" rel="noopener" href="https://git.kageru.moe/kageru/vs-scripts/src/branch/master/abyss1.py">https://git.kageru.moe/kageru/vs-scripts/src/branch/master/abyss1.py</a> Made in Abyss episode 1 by kageru</li>
<li><a target="_blank" rel="noopener" href="https://pastebin.com/JB8aEGgf">https://pastebin.com/JB8aEGgf</a> Something by Nginx from TnP</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Ichunjo/encode-scripts">https://github.com/Ichunjo/encode-scripts</a> - Various scripts by Vardë</li>
<li><a target="_blank" rel="noopener" href="https://git.concertos.live/OpusGang/EncodeScripts">https://git.concertos.live/OpusGang/EncodeScripts</a> - Various crowdsourced scripts</li>
</ul>
<h4 id="3-2-17-论坛和博客文章"><a href="#3-2-17-论坛和博客文章" class="headerlink" title="3.2.17 论坛和博客文章"></a>3.2.17 论坛和博客文章</h4><p>公开：</p>
<ul>
<li>缩小像素： <a target="_blank" rel="noopener" href="https://guide.encode.moe/encoding/descaling.html">https://guide.encode.moe/encoding/descaling.html</a></li>
<li>遮罩： <a target="_blank" rel="noopener" href="https://guide.encode.moe/encoding/masking-limiting-etc.html">https://guide.encode.moe/encoding/masking-limiting-etc.html</a></li>
<li>自适应加噪：<a target="_blank" rel="noopener" href="https://blog.kageru.moe/legacy/adaptivegrain.html">https://blog.kageru.moe/legacy/adaptivegrain.html</a></li>
<li>Krisch和Retinex的边缘遮罩：<a target="_blank" rel="noopener" href="https://blog.kageru.moe/legacy/edgemasks.html">https://blog.kageru.moe/legacy/edgemasks.html</a></li>
<li>降噪工具： <a target="_blank" rel="noopener" href="https://blog.kageru.moe/legacy/edgemasks.html">https://blog.kageru.moe/legacy/edgemasks.html</a></li>
</ul>
<p>私藏：</p>
<ul>
<li>色带遮罩的解析：<a target="_blank" rel="noopener" href="https://i.fiery.me/Atwjs.png">https://i.fiery.me/Atwjs.png</a></li>
<li><code>adptvgrnMod</code> 的噪点参数解析：<a target="_blank" rel="noopener" href="https://i.fiery.me/bELRN.png">https://i.fiery.me/bELRN.png</a></li>
<li>自动去色带（不使用 <code>banddtct</code> 的情况下）： <a target="_blank" rel="noopener" href="https://awesome-hd.me/forums.php?action=viewthread&threadid=27426&post=4#post20150336">https://awesome-hd.me/forums.php?action=viewthread&amp;threadid=27426&amp;post=4#post20150336</a></li>
<li>聚焦于**双范围(double range)**压缩：<a target="_blank" rel="noopener" href="https://passthepopcorn.me/forums.php?action=viewthread&threadid=9197&postid=1622921#post1622921">https://passthepopcorn.me/forums.php?action=viewthread&amp;threadid=9197&amp;postid=1622921#post1622921</a></li>
<li>对何时与如何使用脏线修复的看法（使用<code>ContinuityFixer</code>）：<a target="_blank" rel="noopener" href="https://passthepopcorn.me/forums.php?action=viewthread&threadid=35149&postid=1656050#post165605038h">https://passthepopcorn.me/forums.php?action=viewthread&amp;threadid=35149&amp;postid=1656050#post165605038h</a></li>
<li>运用<code>banddtct</code> 与 <code>dirtdtct</code>：<a target="_blank" rel="noopener" href="https://git.concertos.live/AHD/awsmfunc/issues/13#issuecomment-62">https://git.concertos.live/AHD/awsmfunc/issues/13#issuecomment-62</a></li>
</ul>
<h3 id="3-3-x264与x265"><a href="#3-3-x264与x265" class="headerlink" title="3.3 x264与x265"></a>3.3 x264与x265</h3><p>我们推荐的两个主要视频编码器是x264和x265。x265作为较新的编码器，在技术上应该更胜一筹，不过两者也都各有优劣之处。</p>
<p>x264作为更成熟的编解码器，它更稳定(more consistent)，这意味着你不太可能遇到随机出现莫名其妙地看起来很糟糕的场景。它还具有更好的硬件支持，并且编码速度快得多。编码速度的差异通常至少是5倍。</p>
<p>从另一方面看，x265的优势在于它能够存储HDR信息，而且效率高得多，特别是类似低码率动漫这样的简单内容。</p>
<h4 id="3-3-1-8-bit-与-10-bit"><a href="#3-3-1-8-bit-与-10-bit" class="headerlink" title="3.3.1 8-bit 与 10-bit"></a>3.3.1 8-bit 与 10-bit</h4><p>我们建议考虑x264的两个位深是 8-bit 和 10-bit。如果你正在使用x265，就始终使用10-bit，因为它在各方面都更好。对于x264，8-bit有更多的硬件兼容性（10-bit几乎没有），而且速度明显更快。然而，10-bit x264通常能够节省相当多的空间，同时仍然比x265快。此外，10-bit编码在保留梯度方面要好得多（也就是说，你不必担心色带再次出现），这使得它在编码无噪点内容（比如动漫）方面非常受欢迎。</p>
<h4 id="3-3-2-x264参数设置"><a href="#3-3-2-x264参数设置" class="headerlink" title="3.3.2 x264参数设置"></a>3.3.2 x264参数设置</h4><p>来自于AHD指南的参数（需硬件兼容的用斜体字做标注，并有一部分修改）：</p>
<p><strong>通用参数设置</strong>：</p>
<ul>
<li><em><code>--level 4.1</code></em> <em>用于DVXA【译者注：DirectX Video Acceleration】</em></li>
<li><code>--b-adapt 2</code> 使用最好的（x264具有的）算法来决定B帧的插入位置。</li>
<li><code>--min-keyint</code> 通常应该是你的视频的帧率，例如，如果你是编码23.976帧的内容，那么你就使用24帧。这是设置I帧之间的最小间隔。</li>
<li><em><code>--vbv-bufsize 78124 --vbv-maxrate 62500</code></em> <em>用于DVXA（旧的指南使用较低的值来考虑将编码写入蓝光盘播放的可能性，但这不再需要考虑，因为其他设置破坏了这种兼容性。新的数值是 <code>--level 4.1</code> 可以做到的最大值，如果你的设备因此而损坏，那不是编码的问题，而是你的设备不符合DXVA规格）。</em></li>
<li><code>--rc-lookahead 250</code> 如果使用 mbtree，则为60或更高。这设置了x264可以提前多少帧查看，这对 mbtree 来说至关重要。你需要大量的内存来实现这一点。(就我个人而言，我现在只是把它放在250，因为它对内存使用的影响是2GB左右）。如果你在没有 mbtree 的情况下进行编码，并且在你的脚本中有很多 ReplaceFramesSimple 的调用，一定要调低这个值。</li>
<li><code>--me umh</code> 是你应该去的最低限度。如果你的CPU足够快，你可能需要忍受 <code>tesa</code> 带来的减速。<code>esa</code> 需要和 <code>tesa</code> 相同时长而没有任何好处，所以如果你想放慢你的编码来尝试捕捉更多的运动矢量，就使用 <code>tesa</code>，尽管这种增加并不一定总是值得。这并不是一个你需要测试的设置，但是如果你使用 <code>tesa</code>，你可能会从x264中挤出一些更多的性能。</li>
<li><code>--direct auto</code> 这将会自动选择预测模式(<code>spatial</code> &#x2F;  <code>temporal</code>)。</li>
<li><code>--subme 10</code> or <code>11</code> （就个人而言我会设置为11，他们的不同在于对编码速度有3-4%的影响）。</li>
<li><code>--trellis 2</code></li>
<li><code>--no-dct-decimate</code> 相反的是<code>dct-decimate</code>是牺牲质量换取速度。把它关掉好了，因为你的电脑很可能足以应付。</li>
<li><code>--preset veryslow</code> or <code>placebo</code> 尽管我们改变的参数会让 <code>veryslow</code> 变成 <code>placebo</code>，也无所谓了。</li>
</ul>
<p><strong>受源影响的参数设置：</strong></p>
<ul>
<li><p><code>--bitrate / --crf</code> 比特率【译者注：也称为码率】的单位是Kbps（千比特&#x2F;秒），CRF采用浮点数，越低质量越好。这是你掌握的最重要参数；如果码率不足，质量肯定会很次。如果码率过高，就会臃肿不堪(如果人们想下载大文件，他们会得到一个remux)。当然，码率的需求可以根据来源的不同而有很大的不同。</p>
</li>
<li><p><code>--deblock -3:-3 to 1:1</code> 对于真人电影，大多数人只是坚持使用-3:-3。对于动漫来说，通常取-3:-2和0:0之间的值，两个值之间的偏移量为1是正常的（一般取值为-1:0，0:-1，和-2:-1）。</p>
</li>
<li><p><code>--aq-mode 1 to 3:1</code> 在每一帧的基础上分配码率，2倾向于将更多的码率分配给前景，并且可以在小范围的帧中分配码率，3是2的修改版，试图将更多的比特分配给帧的暗部。要知道哪种模式最适合，唯一的办法是进行测试。但几乎每一个源最终都是用 <code>aq-mode 3</code> 时看起来最好。</p>
</li>
<li><p><code>--aq-strength 0.5 to 1.3</code> 0.5至1.3之间的值非常值得尝试。 更高的值有助于（避免？）色块(help with blocking)。<br>更低的值倾向于将更多码率分配至前景，与 <code>aq-mode 2</code> 所做的类似。当使用CRF进行编码时，此参数会极大地影响码率，因此如果您打算使用CRF进行最终编码，那么使用<code>2- pass</code>测试此参数可能是值得的。</p>
</li>
<li><p><code>--merange 24(能够使用的最低的值) to 64</code> 设置太高（超过128）可能有害，32或48对大多数编码来说都很好。一般来说，对于有大量运动的电影（如动作片），（使用 <code>umh</code> 时）将1080p设为32-48、720p为32有所成效。人物对话场景可以应用24这样的低值。对编码速度的影响是明显的但并不严重。个人而言，在使用 <code>umh</code> 时，我更喜欢将1080p设置为48，720p设置为32，或者使用 <code>tesa</code> 时，1080p为32，720p也为32。</p>
</li>
<li><p><code>--no-mbtree</code> 我强烈建议在启用和禁用 mbtree 的情况下进行测试，因为通常它会导致两种截然不同的编码结果。**宏块树(mbtree)**基本上试图降低块而不是帧的质量，因此只有帧中不重要的部分被分配更低码率。要做到这一点，它需要知道一个块以后被引用的频率，这就是为什么 <code>rc-lookahead</code>  应该被设置为 250。这对有静态背景的视频很有用，比如动画片。或者在那些已经使用了高 <code>qcomp</code>（.75或以上）的视频，宏块树的影响较小。在测试宏块树开启与否哪种合适时，你可能需要重新测试每一个参数设置，特别是<code>qcomp</code>、<code>psy-rd</code> 和 <code>ipratio</code>。</p>
</li>
<li><p><code>--ipratio 1.15 to 1.40</code> 1.30是最常用的数值。此参数决定I帧和P帧之间比特率的分配比例。</p>
</li>
<li><p><code>--pbratio 1.05 to 1.30</code> 1.20是最常用的数值。此参数决定P帧和B帧之间的比特率分配比例。这个值应该总比 <code>-ipratio</code> 低0.10左右，所以在测试 <code>-ipratio</code> 的时别忘了降低它。如果你使用 <code>mbtree</code>，这个设置不会有任何影响，因为其由宏块树自身决定。</p>
</li>
<li><p><code>--psy-rd 0.40:0 to 1.15:0</code> 0.95:0到1.15:0适用于真人电影。第一个数值是 <code>psyrd</code> 强度，第二个是 <code>psy-rellis</code> 强度。这试图使x264不使事情变得模糊，而是保持复杂性。对于动画片来说，(0.40和1.00之间):0.00是通常选用。<code>psy-rellis</code> 通常会引入很多**振铃(ringing)**，但可以帮助保持抖动。 你可以为真人表演尝试0.00和0.15之间的值，为动画尝试高达0.50的值,如果你提高你的 <code>aq-strength</code> 的话，通常会得到更好的结果。</p>
</li>
<li><p><code>--bframes 6 to 16</code> 这是设置可以用B帧替换的连续P帧的最大数量。在你的第一次测试运行中使用16，并根据x264日志进行设置:</p>
<blockquote>
<p>x264 [info]: consecutive B-frames: 1.0% 0.0% 0.0% 0.0% 14.9% 23.8% 13.9% 15.8% 8.9% 9.9% 0.0% 11.9% 0.0% 0.0% 0.0% 0.0% 0.0%</p>
</blockquote>
</li>
</ul>
<p>  从第一个百分比为0开始计算，选择超过1%的最高数字，在这个例子中是11。(或者就把这个数字保持在16，因为允许更多的 bframes 不会损害你的编码，而且会帮助压缩，对速度的影响并不是那么巨大)。</p>
<ul>
<li><p><code>-ref</code> 设置每个P帧可以使用的前一帧的数量作为参考。如果你不关心硬件兼容性（和&#x2F;或正在进行10-bit编码），将其设置为16。这对性能的影响相当大，但在大多数时候是值得的。<em>计算你可以使用的数字，或者如果你使用本末提供的CLI输入，它将由x264为你计算。始终使用你可以使用的最大值。 最大的–参考值可以按以下方式计算：对于–级别4.1，根据H.264由于每一帧是以YV12格式存储的，或每像素1.5字节，一个1920x1088帧是1920×1088×1.5&#x3D;3133440字节&#x3D;3060千字节。请记住，在进行计算时，将两个维度四舍五入到mod16值，即使你没有进行mod16编码！让我们来计算一下1920x800。 1920 × 800 × 1.5 &#x3D; 2304000字节 &#x3D; 2250千字节。12，288÷2250千字节&#x3D;5.45777778，所以你最多可以使用5个参考帧 注意，这些转换使用基数2，所以1千字节&#x3D;&#x3D;1024字节。如果你把数学弄错了，那也没关系–如果你用的太多，x264会显示一个警告，所以你会知道你是否需要改变它。</em></p>
</li>
<li><p><code>--zones</code> 对去色带和区块相当有用，因为这些区域需要较大的比特率来保持透明度。其语法为：</p>
<p><code>--zones 0,100,crf=10/101,200,crf=15 </code> 或 <code>--zones 0,100,b=5/101,200,b=10</code> 在这种情况下，b是一个码率系数。你也可以用它来处理那些没有得到足够比特分配的区域。特别常见的区域是较暗的场景或有大量红色的场景。渐变也会受到码率缺失的影响，需要进行分区。也可以在片头时降低码率，以节省一点压制时间。</p>
</li>
<li><p><code>--output-depth 8 or 10</code> 取决于你想编码的格式</p>
</li>
<li><p><code>--output-csp i444</code> 仅在编码4:4:4时需要，否则无需此参数。</p>
</li>
</ul>
<p>3.3.3 x265 参数</p>
<p>这里的文档已经足够好了，所以我只需要介绍一下推荐值：</p>
<p><strong>与源无关的参数设置：</strong></p>
<ul>
<li><code>--preset veryslow</code> or <code>slower</code></li>
<li><code>--no-rect</code> 对于较慢的电脑。有些许可能被证明是有用的，但很可能并不值得。</li>
<li><code>--no-amp</code> 与 <code>rect</code> 相似，尽管它看起来稍微更有效。</li>
<li><code>--no-open-gop</code></li>
<li><code>--no-cutree</code> 因为这似乎是一个很糟糕的mbtree实现（应用）。</li>
<li><code>--no-rskip rskip</code> 会牺牲一些质量来换取加速，所以对于差点的cpu来说，它值得考虑。</li>
<li><code>--no-sao</code> 因为 <code>sao</code> 是x265中最愚蠢的实现（设置）之一。</li>
<li><code>--ctu 64</code></li>
<li><code>--min-cu-size 8</code></li>
<li><code>--rdoq-level 2</code></li>
<li><code>--max-merge 5</code></li>
<li><code>--rc-lookahead 60</code> 虽然并不相关，但只要大于 min-keyint。</li>
<li><code>--ref</code> 好cpu用6，差点的用4。</li>
<li><code>--bframes 16</code> 或者取决于最终的 bframes 日志输出的值。</li>
<li><code>--rd 3</code> or <code>4</code> (目前是效果一致的)</li>
<li><code>--subme 5</code> 你也可以把它改成7，但众所周知这会导致锐化。</li>
<li><code>--merange 57</code> 只要不要低于32，就不会有问题。</li>
<li><code>--high-tier</code></li>
<li><code>--range limited</code></li>
<li><code>--aud</code></li>
<li><code>--repeat-headers</code></li>
</ul>
<p><strong>受源影响（依赖于源）的参数设置:</strong></p>
<ul>
<li><p><code>--colorprim X</code> (X代表数值) HDR设为9，SDR设为1。</p>
</li>
<li><p><code>--colormatrix X</code> (X代表数值) HDR设为9，SDR设为1。</p>
</li>
<li><p><code>--transfer X</code> (X代表数值) HDR设为16，SDR设为1。</p>
</li>
<li><p><code>--hdr10</code> 仅HDR需要。</p>
</li>
<li><p><code>--hdr10-opt</code> 适用于4:2:0 HDR，<code>--no-hdr10-opt</code> 适用于 4:4:4 HDR 和 SDR。</p>
</li>
<li><p><code>--master-display &quot;G(8500,39850)B(6550,2300)R(35400,14600)WP(15635,16450)L(10000000,20)&quot;</code> </p>
<p>L的值取自于源的媒体信息(with the values for L coming from your source’s MediaInfo output)。</p>
</li>
<li><p><code>--max-cll &quot;711,617&quot;</code> 同样来自于源的媒体信息。</p>
</li>
<li><p><code>--cbqpoffs</code> 和 <code>--crqpoffs</code> 通常应该在-3和0之间。它设置了应用于亮度和色度平面的比特率之间的偏移量(This sets an offset between the bitrate applied to the luma and the chroma planes)。</p>
</li>
<li><p><code>--qcomp  0.60 to 0.80</code></p>
</li>
<li><p><code>--aq-mode 4, 3, 2, 1</code> or <code>--hevc-aq</code> 4和3通常是两个最佳的选择。</p>
</li>
<li><p><code>--aq-strength  0.80 to 1.50</code></p>
</li>
<li><p><code>--deblock -4:-4 to 0:0</code> 与x264相同。真正使用时你可以用默认的 -3:-3。</p>
</li>
<li><p><code>--ipratio</code> and <code>--pbratio</code> 与x264相同。</p>
</li>
<li><p><code>--psy-rd 0.50 to 2.00</code> 与x264相似。</p>
</li>
<li><p><code>--psy-rdoq</code> 通常从0.00到2.00不等。</p>
</li>
<li><p><code>--no-strong-intra-smoothing</code> 用于锐化&#x2F;噪点的内容。对于模糊不清的内容，可以把这个选项打开，因为这是一个额外的模糊，有助于避免色带。</p>
</li>
<li><p><code>--output-depth 10</code> 10-bit输出。</p>
</li>
</ul>
<p><strong>实验性质的参数（设置）：</strong></p>
<ul>
<li><code>--scenecut-aware-qp</code></li>
<li><code>--scenecut-window 550</code></li>
<li><code>--max-qp-delta 2</code></li>
<li><code>--hist-scenecut</code></li>
<li><code>--hist-threshold 0.02</code></li>
</ul>
<h3 id="3-4-测试参数设置"><a href="#3-4-测试参数设置" class="headerlink" title="3.4 测试参数设置"></a>3.4 测试参数设置</h3><p>首先，你要选择一个较小的视频文件区域作为参考，因为对整个文件进行测试会花费很多时间。推荐的方法是通过使用 <strong>awsmfunc</strong>的<code>SelectRangeEvery</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> awsmfunc <span class="keyword">as</span> awf</span><br><span class="line">out = awf.SelectRangeEvery(clip, every=<span class="number">15000</span>, length=<span class="number">250</span>, offset=[<span class="number">1000</span>,<span class="number">5000</span>])</span><br></pre></td></tr></table></figure>

<p>这里，第一个数字是各部分之间的偏移量，第二个数字是各部分的长度，偏移数组内为开始和结束的偏移量。 你要使用一个相当长的片段（通常是几千帧），包括黑暗、明亮、静态和动作场景，但是，这些场景应该大致上在整个视频中一样平均分布。 </p>
<p>当测试参数时，你应该一直使用2-pass编码，因为许多参数会大大改变 CRF 得到的比特率。对于最终的编码，两者都很好，尽管 CRF 更快一些。</p>
<p>要找出怎么设置是最好的，就需要把它们都与源文件相互比较。你可以通过单独交错或通过 <strong>awsmfunc</strong> 将文件夹内所有内容进行交错来达成比较。通常还需要给它们贴上标签，这样你就能知道你在看哪个片段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load the files before this</span></span><br><span class="line">src = awf.FrameInfo(src, <span class="string">&quot;Source&quot;</span>)</span><br><span class="line">test1 = awf.FrameInfo(test1, <span class="string">&quot;Test 1&quot;</span>)</span><br><span class="line">test2 = awf.FrameInfo(test2, <span class="string">&quot;Test 2&quot;</span>)</span><br><span class="line">out = core.std.Interleave([src, test1, test2])</span><br><span class="line"><span class="comment"># You can also place them all in the same folder and do</span></span><br><span class="line">src = awf.FrameInfo(src, <span class="string">&quot;Source&quot;</span>)</span><br><span class="line">folder = <span class="string">&quot;/path/to/settings_folder&quot;</span></span><br><span class="line">out = awf.InterleaveDir(src, folder, PrintInfo=<span class="literal">True</span>, first=extract,</span><br><span class="line">repeat=<span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>如果你使用 yuuno，你可以使用下面的 iPython Magic ，通过悬停在预览屏幕上让预览在两个源之间切换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%vspreview --diff</span><br><span class="line">clip_A = core.ffms2.Source(<span class="string">&quot;settings/crf/17.0&quot;</span>)</span><br><span class="line">clip_A.set_output()</span><br><span class="line">clip_B = core.ffms2.Source(<span class="string">&quot;settings/crf/17.5&quot;</span>)</span><br><span class="line">clip_B.set_output(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>通常情况下，你会想先测试一下码率。只要在几个不同的CRF下编码，并与源画面进行比较，找到与源码无差别的最高CRF值。现在，将该值四舍五入，最好是向下，然后切换到2-pass。对于标准测试，测试<code>qcomp</code>（步进为0.05）、<code>aq-modes</code>、<code>aq-strength</code>（步进为0.05）<code>merange</code>（32、48或64）、psy-rd（步进为0.05）、<code>ipratio</code>&#x2F;<code>pbratio</code>（步进为0.05，并保持两者间0.10的差值），然后<code>deblock</code>（步进为1）。如果你认为 mbtree 有帮助（即你在对动画进行编码），在打开 mbtree 的情况下重新进行这个过程。你可能不会想太多地改变顺序，但当然也可以这样做。</p>
<p>对于x265，测试调整顺序应该是<code>qcomp</code>、<code>aq-mode</code>、<code>aq-strength</code>、<code>psy-rd</code>、<code>psy-rdoq</code>、<code>ipratio</code> 和 <code>pbratio</code>，最后 <code>deblock</code>。</p>
<p>如果你想要提高一点额外的效率，你可以在你最终决定的每个设置的数值周围用较小的步进再次进行测试。建议在你已经对每个设置做了一次测试之后再做，因为它们都会对彼此产生轻微的影响。</p>
<p> 一旦你完成了对2-pass设置的测试，就切换回CRF，重复寻找视觉无损的 CRF 值过程。</p>
<h2 id="4-音频"><a href="#4-音频" class="headerlink" title="4 音频"></a>4 音频</h2><h3 id="4-1-SoX"><a href="#4-1-SoX" class="headerlink" title="4.1 SoX"></a>4.1 SoX</h3><p>如果你的源音频是高清晰度(hi-res)的（24位或&gt;48kHz），你可能要考虑改变它以节省空间，因为如果转换能够恰当的完成的话，高解析度音频对消费者来说很大程度上只是心理作用。为了做到这一点，我们推荐SoX。如果你想转换为16-bit 48 kHz，你可以使用以下方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sox foo.wav -G -b 16 bar.wav -v -L 48000 dither -s -f gesemann</span></span><br></pre></td></tr></table></figure>

<p>如果你的源音频的采样率是48kHz的倍数（如96kHz），就使用这个。对于44.1kHz的倍数，你可以简单地把48000换成44100。</p>
<p>我们建议对编码进行这些转换，因为更高的采样率通常比其他任何方法更具破坏性，24-bit和正确处理后的16-bit之间的差异是如此之小，以至于只有在极高的音量下才会注意到。</p>
<h3 id="4-2-有损编码"><a href="#4-2-有损编码" class="headerlink" title="4.2 有损编码"></a>4.2 有损编码</h3><h4 id="4-2-1-Opus"><a href="#4-2-1-Opus" class="headerlink" title="4.2.1 Opus"></a>4.2.1 Opus</h4><p>Opus，虽然是最高效的编解码器，也是音乐会(Concertos)上首选的有损编解码器，但几乎没有硬件兼容性。这对使用HTPC、台式机、笔记本电脑甚至手机的人来说都不是问题，但试图使用蓝光播放器播放的用户就无法解决了。由于我们不那么关心硬件兼容性，这可能是最简单的方法了。</p>
<p>除了是最有效的编解码器，它也是完全开源的，就像FLAC一样，在每个操作系统上都能完美运行。Opus最大的问题是它不能与matroska【译者注：mkv容器】的有序章节一起使用；但是，除非你在编码时有很多相同的前奏&#x2F;结尾重复，否则这并不重要。</p>
<p>为了对 Opus 进行编码，你需要安装 opus-tools，从那里开始，你只需要:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">opusenc foo.wav bar.opus</span></span><br></pre></td></tr></table></figure>

<p>此外，如果你不想使用（公认较低）默认值，你可以指定 <code>-- bitrate</code>，尽管Opus会自动检测它的最佳目标比特率。</p>
<h4 id="4-2-2-qAAC-和-fdkaac"><a href="#4-2-2-qAAC-和-fdkaac" class="headerlink" title="4.2.2 qAAC 和 fdkaac"></a>4.2.2 qAAC 和 fdkaac</h4><p>作为在效率方面紧随 Opus 之后的 qAAC，也是一个可行的选择。与 Opus 不同，AAC 有更好的硬件兼容性，特别是在立体声方面。它也没有有序章节的问题。然而，qAAC 需要 iTunes，在 Unix 下需要 Wine。为了编码最高质量的 qAAC，你将要输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qaac.exe -V 127 foo.wav bar.m4a</span><br></pre></td></tr></table></figure>

<p><code>-V</code> 指定质量，数字越大越好，最大值是127。</p>
<h4 id="4-2-3-杜比声-又名AC3"><a href="#4-2-3-杜比声-又名AC3" class="headerlink" title="4.2.3 杜比声 又名AC3"></a>4.2.3 杜比声 又名AC3</h4><p>硬件兼容性之王是AC-3。由于它是DVD的首选编解码器，所以它在大多数播放设备上有非常好的支持。然而，它的效率比MP3还差。如果你想在家里编码以实现硬件兼容（例如，你想为AHD&#x2F;HDB&#x2F;等压制组工作），推荐的方法是通过 Sound Forge（Windows）或 Dolby Media Producer（OS X）。</p>
<p>为了用 Sound Forge 对 AC-3 进行编码，打开文件（w64格式），等待它建立索引，然后进入另存为选项。从这里，选择Dolby Digital AC-3 Pro。然后，选择以下选项（从AHD的指南中复制）。</p>
<ul>
<li>Bitstream mode: Main audio service: Complete main</li>
<li>Audio coding mode: 3&#x2F;2 (L, C, R, Ls, Rs) with LFE enabled</li>
<li>Sample rate: 48 kHz</li>
<li>Data rate: 640 kbps</li>
<li>Dialog normalization: -32 dB</li>
<li>Do not select Save data in Intel byte order</li>
<li>Center mix level: -3 dB</li>
<li>Surround mix level: -3 dB</li>
<li>Do not set copyright bit</li>
<li>do not mark as original bitstream</li>
<li>Do not include audio production information</li>
<li>Do not enable extended bitstream information</li>
<li>Do not enable digital de-emphasis</li>
<li>Enable DC high-pass flter</li>
<li>Enable Bandwidth low-pass flter</li>
<li>Enable LFE low-pass flter</li>
<li>Do not enable 90-degree phase shift</li>
<li>Do not enable 3 dB attenuation</li>
<li>Line mode profle: None</li>
<li>RF mode profle: None</li>
<li>Do not enable RF overmodulation protection</li>
</ul>
<p>新的E-AC-3编解码器正异军突起。这带来的是对 Atmos 与更多通道的支持。然而，EAC3编码器的唯一缺陷是并不包括对 Atmos 的支持，其效率与AC-3相同，因为它只是在其基础上封装了另一层。 由于这些原因，我们觉得除了说明需要 Dolby Media Producer 外，没有必要详细说明它是如何编码的。</p>
<h4 id="4-2-4-DTS"><a href="#4-2-4-DTS" class="headerlink" title="4.2.4 DTS"></a>4.2.4 DTS</h4><p>这种编解码器在1080p的PT编码中十分常见。坦率地说，这只是因为臃肿的比特率(bloated bitrate)。DTS 实际上在1509 kbps时比 AC-3 在448 kbps时更糟。就不要用这个了。考虑它的唯一原因是偷懒，因为几乎每个电影源都会有一个DTS核心音轨，可以直接套用。</p>
<h3 id="4-3-无损编码"><a href="#4-3-无损编码" class="headerlink" title="4.3 无损编码"></a>4.3 无损编码</h3><h4 id="4-3-1-FLAC"><a href="#4-3-1-FLAC" class="headerlink" title="4.3.1 FLAC"></a>4.3.1 FLAC</h4><p>它是免费、开源的，兼容性极佳，压缩效率最佳的。如果你是立体声或单声道，它在硬件兼容性方面应该没有问题。否则，它可能对一些接收器有问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flac --compression-level-8 foo.wav bar.flac</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-TrueHD"><a href="#4-3-2-TrueHD" class="headerlink" title="4.3.2 TrueHD"></a>4.3.2 TrueHD</h4><p>由于硬件支持较差，这种编解码器不如 DTS-HD MA 流行，但它的压缩率更高一些，特别是在低比特率的情况下，DTS核心的臃肿并不会使比特率膨胀。遗憾的是，由于其较差的硬件兼容性，很多小组坚持再封装一条单独的AC-3兼容音轨。在交响音乐会(Concertos)制作中，我们希望您不要这样做，但我们理解这可能是上传其他地方所必须的，或者仅仅是您为了硬件兼容性所做的妥协。</p>
<h4 id="4-3-3-DTS-HD-MA"><a href="#4-3-3-DTS-HD-MA" class="headerlink" title="4.3.3 DTS-HD MA"></a>4.3.3 DTS-HD MA</h4><p>由于更好地支持使用核心(DTS-core)作为后备，这种编解码器在环绕声重合中相当受欢迎。你可以将你的音轨提取为多个wavs，每个通道一个，然后将它们拖入编码套件，并点击大的红色编码按钮来进行编码。在交响音乐会(concertos)中，我们并不关心这种编解码器，我们更喜欢使用 TrueHD 或 FLAC。</p>
<h2 id="5-混流"><a href="#5-混流" class="headerlink" title="5 混流"></a>5 混流</h2><h3 id="5-1-追加文件"><a href="#5-1-追加文件" class="headerlink" title="5.1  追加文件"></a>5.1  追加文件</h3><p>有时，你的编码会崩溃，或者你想编辑某个编码的一小部分。在这样的情况下，我们可以 mkvtoolnix 中方便地追加文件。如果你只是想在另一个文件后添加一些东西，只需在 mkvtoolnix 的源文件分区中右击该文件即可。 </p>
<p>对于视频内的编辑，首先在结尾处找到适当的I帧，这样你就真正编码够了，然后编码你的片段，在 mkvtoolnix 中打开每个文件，在输出标签中进入分割选项，然后为视频的一部分设置帧。请记住，这里的计数从1开始，而不是像 Python 那样从0开始。对你想添加变化的部分进行这样的处理，然后像以前一样追加。你也可以这样做来创建一个混合视频的Remux。 </p>
<p>确保在混音后检查文件包含所有必要的帧，因为如果你不注意的话，很容易导致使用错误的I帧或由于错误的修剪而导致帧数不正确。</p>
<h3 id="5-2-无缝衔接"><a href="#5-2-无缝衔接" class="headerlink" title="5.2 无缝衔接"></a>5.2 无缝衔接</h3><p>推荐阅读这篇文章： <a target="_blank" rel="noopener" href="https://forums.animesuki.com/showthread.php?t=66444%E3%80%82">https://forums.animesuki.com/showthread.php?t=66444。</a> 在这没什么需要补充的。</p>
<h2 id="6-推荐的教程和资源"><a href="#6-推荐的教程和资源" class="headerlink" title="6 推荐的教程和资源"></a>6 推荐的教程和资源</h2><ul>
<li>Irrational Encoding Wizardry’s fansubbing guide: <a target="_blank" rel="noopener" href="https://guide.encode.moe/">https://guide.encode.moe</a></li>
<li>Kageru’s blog: <a target="_blank" rel="noopener" href="https://kageru.moe/blog/">https://kageru.moe/blog/</a></li>
<li>eXmendiC’s filtering guide: <a target="_blank" rel="noopener" href="https://iamscum.wordpress.com/_test1/_test2/">https://iamscum.wordpress.com/_test1/_test2/</a></li>
<li>AHD Guides</li>
</ul>
<h2 id="7-贡献者们（以字母表排名）"><a href="#7-贡献者们（以字母表排名）" class="headerlink" title="7  贡献者们（以字母表排名）"></a>7  贡献者们（以字母表排名）</h2><ul>
<li>Aicha @ D-Z0N3, NSDAB, REEEEEEEE </li>
<li>Anon @ Concertos, NSDAB</li>
<li>Q2KTyrant @ Concertos</li>
<li>Ryuu @ Concertos, NSDAB</li>
<li>Scrooge @ Concertos, COC, FidelityTM</li>
<li>xCreamEnte @ EPSiLON, HDBEE, SiGMA</li>
</ul>
<h2 id="8-附录"><a href="#8-附录" class="headerlink" title="8 附录"></a>8 附录</h2><p><img src="/Picture/AHDVEG-pics/Figure16.png" alt="Figure16"></p>
<p>图16：不同缩小像素函数的效果比较。将源从1080p缩小到720p，然后被裁剪。所有参数都保留默认值。</p>
<p><img src="/Picture/AHDVEG-pics/Figure17.png" alt="Figure17"></p>
<p>图17：放大以后的大小。来自于Commie压制的《你的名字》（Your Name (2016)），相较于源进行了裁剪，然后被放大了2倍。</p>
<p><img src="/Picture/AHDVEG-pics/Figure18.png" alt="Figure18"></p>
<p>图18：不同参数的双三次(bicubic)放大比较。记住，这些只是视频的小片段，双三次放大总是会导致伪影，特别是锯齿。尖锐的双三次曲线(b&#x3D;0, c&#x3D;1)特别容易产生锯齿伪影。</p>
<p><img src="/Picture/AHDVEG-pics/Figure19.png" alt="Figure19"></p>
<p>图19：缩小并放大到原始分辨率的调整器比较。所有内容都被缩小到源分辨率的一半，然后使用<code>nnedi3_rpow2</code>放大回去。所有参数都保留默认值。</p>
<p><img src="/Picture/AHDVEG-pics/Figure20.png" alt="Figure20"></p>
<p>图20：缩小并放大到原始分辨率的调整器比较。所有内容都被缩小到源分辨率的一半，然后用相同的调整器放大回去。所有参数都保留默认值。</p>
<p><img src="/Picture/AHDVEG-pics/Figure21.png" alt="Figure21"></p>
<p>图21：抖动类型的比较。输入源为8-bit视频，向上抖动并用 <code>f3kdb</code> 去色带，输出为16-bit，然后抖动至8-bit。</p>
<p><img src="/Picture/AHDVEG-pics/Figure22.png" alt="Figure22"></p>
<p>图22：一个说明为什么不适当的对角边界fx是个坏主意的例子。上面是源，下面是Geek使用边缘遮罩后的。来自Geek压制的《精灵旅社2》（Hotel Transylvania 2 (2015))。</p>
<p><img src="/Picture/AHDVEG-pics/Figure23.png" alt="Figure23"></p>
<p>图23：在16-bit（右)和8-bit（左)分别进行伽马修复(gamma bug fix)的比较</p>
<p><img src="/Picture/AHDVEG-pics/Figure24.png" alt="Figure24"></p>
<p>图24：不同**边缘遮罩(edgemask)**的比较。从左上角到右下角：source,  <code>Prewitt</code>, <code>Sobel</code>, <code>Kirsch</code>, <code> TCanny</code>，和<code>retinex_edgemask</code>。所有设置都保留默认值。</p>
<p><img src="/Picture/AHDVEG-pics/Figure25.png" alt="Figure25"><br>图25：更精确的边缘遮罩(edgemask)的比较。从左上角到右下角：source, <code>retinex_edgemask</code>, <code>Kirsch</code>, <code>Sobel</code>。请注意，这是在质量极差且场景灯光昏暗的源上进行对比，因此 <code>retinex_edgemask</code> 和 <code>Kirsch</code> 两种遮罩的区别比常规情况更大。</p>
<p><img src="/Picture/AHDVEG-pics/Figure26.png" alt="Figure26"></p>
<p>图26：去色带时使用与不使用边缘遮罩(edgemask)的比较。从左上到右下分别是：源，源中裁剪区域标记，裁剪区域，裁剪区域上的遮罩（<code>kgf.retinex_edgemask(src).std. binated(5000).std. maximum ().std.Inflate()</code>），无蒙版去色带（<code>f3kdb.Deband(y=90, grainy=32,grainc=16)</code>），和蒙版去色带。通过平滑级别，伽马值提高了50%。</p>
<p><img src="/Picture/AHDVEG-pics/Figure27.png" alt="Figure27"></p>
<p>图27： 一个例子说明为什么简单的 <strong>亮度遮罩(luma mask)</strong> 往往是不够的。取自1080p的O2STK对《了不起的狐狸爸爸 》（Fantastic Mr. Fox (2009)）进行了编码。O2STK使用了 <code>GradFun3</code> 和一个亮度遮罩。 标记为 Masked 的截图是 <code>f3kdb</code>用RGB截图的简单<code>Sobel</code>遮罩。</p>
<p><img src="/Picture/AHDVEG-pics/Figure28.png" alt="Figure28"></p>
<p>图28：来自Geek的《Hotel Transylvania 2》压制作品：另一个例子说明了为什么在没有正确屏蔽的情况下，你应该始终警惕细节是否平滑甚至遭到破坏。<br>虽然我们不能确定这里是否使用了遮罩，但这很可能是未使用遮罩的 <code>f3kdb</code> 的结果。 <em>sunnighty似乎更常使用 <code>GradFun3</code> 蒙版，这在这个案例中可能有很大帮助。不知道这里发生了什么。但我猜测他们在蒙版遇到了非故意的情况从而产生了问题。</em></p>
<h2 id="9-【译者注】"><a href="#9-【译者注】" class="headerlink" title="9 【译者注】"></a>9 【译者注】</h2><p>本文翻译主要基于<a target="_blank" rel="noopener" href="https://www.deepl.com/translator">DeepL翻译器</a>，在此基础上大量参考<a target="_blank" rel="noopener" href="https://github.com/typing-more/encode_guide/blob/master/%E9%AB%98%E6%B8%85%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97.md">typing-more&#x2F;高清视频转码进阶指南.md</a>，在此表示由衷感谢！</p>
<p>部分名词解释借鉴<a target="_blank" rel="noopener" href="https://vcb-s.nmm-hd.org/">VCB-Studio</a>、<a target="_blank" rel="noopener" href="https://guide.geeking.moe/">Encode Mystery</a>，一并感谢！</p>
<p>对翻译错误或不足的地方欢迎指正；翻译不易，若需转载请指明出处，谢谢配合！</p>
<p>​																															——2021.12.27</p>

                
            </div>
        </div>
    </div>
    
        <footer class="kratos-entry-post-meta">
            <span class="pull-left">
                <time datetime="2023-06-12T13:15:50.626Z" itemprop="datePublished">
                    <a><i class="fa fa-calendar"></i> 2023-06-12</a>
                </time>
                
                
                
            </span>
            
            
                <span class="pull-right">
                    <a class="read-more" href="/%E8%BF%9B%E9%98%B6%E9%AB%98%E6%B8%85%E8%A7%86%E9%A2%91%E5%8E%8B%E5%88%B6%E6%8C%87%E5%8D%97/" title="评论">评论<i class="fa fa-chevron-circle-right"></i></a>
                </span>
            

        </footer>
    
</article>

    



    <div class='text-center pagination'>
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
    </div>






        

            </section>

            
                

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
        <div class="sticky-area">
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/user.svg" alt="ted423" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                21
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                4
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                4
            </span>
        </a>
    </div>
</aside>
            
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类列表</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/3-Code/">3.Code</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Compare/">Compare</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Issue/">Issue</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Compare/" style="font-size: 0.6em;">Compare</a> <a href="/tags/Document/" style="font-size: 0.6em;">Document</a> <a href="/tags/HDR/" style="font-size: 0.6em;">HDR</a> <a href="/tags/Issue/" style="font-size: 0.6em;">Issue</a>
      </div>
  </aside>

            
    </div>
</section>
            

        

                </div>
    </div>
</div>

<footer>
    <div id="footer">
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 FXXS 版权所有.</li>
                            <li>本站已运行<span id="kr-since">Loading...</span></li>
                        </div>
                        <div>
                            <li>自豪地使用 <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a> 主题</li>
                            <li>站点由 ted423 用 <i class="fa fa-heart" style="color:#d43f57"></i> 搭建</li>
                        </div>
                        <!-- 额外的追加注入项 -->
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                <div class="box theme-box" id="theme-toggle">
                    <span class="fa fa-adjust"></span>
                </div>
            </div>
            <div id="gotop-box" class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>


    <div id="kr-donate-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseDonateModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-bitcoin"></i>
            </div>
            <div class="kr-modal-title">打赏</div>
            <button class="kr-modal-close" onclick="krCloseDonateModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-donate-message">打赏提示信息</div>
            <div class="kr-donate-qr" id="kr-donate-qr">
                
            </div>
            <div class="kr-donate-platforms">
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/donate.min.js"></script>




    <div id="kr-share-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseShareModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-share-alt"></i>
            </div>
            <div class="kr-modal-title">分享</div>
            <button class="kr-modal-close" onclick="krCloseShareModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-share-message">分享提示信息</div>
            <div class="kr-share-qr" id="kr-share-qr"></div>
            <div class="kr-share-platforms">
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/share.min.js"></script>



<!-- 额外的追加注入项 -->


        <script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


  <script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>



  <script defer src="/vendors/viewerjs@1.11.6/dist/viewer.min.js"></script>


<script defer src="/js/kr-core.min.js"></script>


  <script defer src="/js/kr-pjax.min.js"></script>


<!-- 额外的追加注入项 -->

  <script src="https://https-ted423-github-io.disqus.com/embed.js"></script>
<script async id="dsq-count-scr" src="https://https-ted423-github-io.disqus.com/count.js"></script>
<script src="/comments/disqus.js"></script>



    </body>
</html>