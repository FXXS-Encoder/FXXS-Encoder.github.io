[{"title":"FFmpeg","date":"2025-09-08T07:18:15.092Z","url":"/2.Tools/FFmpeg/","categories":[["2.Tools","/categories/2-Tools/"]],"content":"版本区别shared: 不包含dll，运行的时候，到相应的dll中调用功能。程序运行过程必须依赖于提供的dll文件。vulkan: Vulkan Support-N: 会是最新的，但不那么stablen4.3.2: Release version LGPL似乎会比GPL少一些功能 ffprobeffprobe &#39;文件&#39; 用于检测文件信息(不过直接看mediainfo就好，而且纯文本输出没有各种GUI看起来那么直观,不过可以用来确认下音轨轨道) ffprobe 无法区分音轨是否带Atmos 范例注意 ffmpeg 的压缩登记跟 flac.exe libflac 不同 ffmpeg -c:a flac -compression_level 12 1.flac -i 1.dts ffmpeg -map 0:1 -c:a flac -compression_level 12 a.flac -i 1.mkv 截图ffmpeg -v quiet -ss 00:23:00 -i file -vcodec png -vframes 1 -pix_fmt rgb24 -y ~/filename.png 切割ffmpeg -ss 4.838 -i &#39;.\\Taylor.Swift.-.Red.Web-DL.1080i.ProRes.mov&#39; -c:v copy -c:a copy Taylor.Swift.-.Red.mov 请注意要自己从帧换算到时间， 下混注意未经仔细调研 OtherDloby E NotesFFmpeg 并不会直接修改音频帧率(这个一般都是视频属性)，通常都是修改延展率，需要自行计算 拆音轨为单轨道(不维护)可能存在问题，有需要还是看 DEEW 的代码 (废弃，Dolby Media Producer Suite需要，不过已经用不到了) 音轨轨道顺序可以在这里确认 ffmpeg -i input.wav -filter_complex &quot;channelsplit&#x3D;channel_layout&#x3D;5.1[FL][FR][FC][LFE][BL][BR]&quot; -map &quot;[FL]&quot; -c:a -map &quot;[FR]&quot; R.wav -map &quot;[FC]&quot; C.wav -map &quot;[LFE]&quot; LFE.wav -map &quot;[BL]&quot; Ls.wav -map &quot;[BR]&quot; Rs.wav 24bit ffmpeg -i input.wav -filter_complex &quot;channelsplit&#x3D;channel_layout&#x3D;5.1[FL][FR][FC][LFE][BL][BR]&quot; -map &quot;[FL]&quot; -c:a pcm_s24le L.wav -map &quot;[FR]&quot; -c:a pcm_s24le R.wav -map &quot;[FC]&quot; -c:a pcm_s24le C.wav -map &quot;[LFE]&quot; -c:a pcm_s24le LFE.wav -map &quot;[BL]&quot; -c:a pcm_s24le Ls.wav -map &quot;[BR]&quot; -c:a pcm_s24le Rs.wav"},{"title":"基础瑕疵介绍","date":"2025-08-26T01:44:41.731Z","url":"/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%91%95%E7%96%B5%E8%AF%B4%E6%98%8E/","tags":[["建设中","/tags/%E5%BB%BA%E8%AE%BE%E4%B8%AD/"]],"categories":[["1.基础知识","/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"content":"伪影(artifact)由于处理、压缩或传输等过程而产生的、原始信号中并不存在的、非预期的、不自然的失真或缺陷。 不当的 aq 或者 psy-rd 会引入，编码器 “无中生有”，创造出一些不存在的噪点或块效应，因为它在拼命避免“过于平滑”。一些缩放算法也会导致伪影。 VCB 的瑕疵说明 "},{"title":"TrueHDD - 开源 TrueHD Atmos 解码器","date":"2025-08-18T00:33:09.049Z","url":"/4.Audio&sub/TrueHD_Atmos/","categories":[["4.Audio&sub","/categories/4-Audio-sub/"]],"content":"直到不久前，在 PC 上解码 TrueHD Atmos 的方案都是使用 Dolby Reference Player，输出的音频已经经过对象音频渲染，只能选择一种固定的声道布局，例如 7.1.4、9.1.6 等。为了获得原始的解码结果，以近期的 TrueHD 解码器作为参考，通过逆向工程重新实现，现已开源。 项目地址：，其中包含中文的使用说明。 在开源后的近一个月时间里根据早期用户反馈进行了部分改进，目前的版本为 0.4.0，可以在 Releases 获取。目前的 CI 包含 Windows &#x2F; Linux (GNU &#x2F; musl) &#x2F; macOS 的 x86_64 &#x2F; arm64 版本，应该能够覆盖大部分 PC 平台。 此外，目前已经与开源的渲染器 Cavernize 进行集成，Windows 用户可以通过 GUI 进行更加自由的音频渲染（在功能上完全替代 Dolby Reference Player，但请注意 Cavern 的目标并不是匹配 Dolby Reference Player 的输出结果）。 相比于 FFmpeg 的实现，主要区别在于： 完整支持 TrueHD (FBA) 解码和对象音频元数据解析，对于 Dolby Atmos 内容的输出结果是原始母版格式 Dolby Atmos Master Format (DAMF)，可以导入 DAW 或直接使用 Dolby 的编码器进行重编码。 没有支持旧 MLP (FBB) 解码，主要是我懒。 包含更加严格的合规测试，主要为 FIFO 方面，由此可以正确处理已经二进制合并后的包含 Seamless Branching 的音轨，以及正确分离原本不应该合并的音轨，产生多个输出。 专用于 TrueHD 的 info 命令，可以获得更详细的属性，后面有例子。 对于重混音轨的用户，可以借此实现音频对象编辑，而不是从前的声道编辑。但请注意这并不一定会减少工作量。由于家用 Dolby Atmos 音频格式需要减少数据量，编码前已经经过了听觉等效的对象编组 (Spatial Coding &#x2F; Clustering)，对于某个声音元素，可能因为其重要性而能完整保留，但也可能会动态地分布于多个音频对象。对于这种情况需要仔细处理，可能需要更多混音技能，尤其是关于 Dolby Atmos 的，才能妥善处理。部分 DAW 可能会对于不标准的 bed 格式发出警告，通常可以通过修改项目配置解决，也可以在解码时使用 --bed-conform 强制输出 7.1.2 bed。除了方便导入之外没有别的作用，并且文件大小会翻倍。 对于影院包场放映用户，--bed-conform 是必须的。使用 Dolby Atmos Conversion Tool 从 DAMF 转换为 IMF IAB 后，再使用  转换为 DCP IAB，即可用于 DCP 封装。 对于重编码用户，正常使用 Dolby Encoding Engine &#x2F; Dolby Media Encoder &#x2F; Dolby Atmos Renderer 的音频编码功能即可。需要注意的是 --warp-mode，这主要影响 5.1 兼容层的后环绕下混方式，如果元数据里不存在此内容，解码时也没有指定一个模式写入 DAMF header (.atmos 文件， 实际是 YAML 格式)，则编码器 &#x2F; 渲染器可能会自己选择一个，造成非预期的结果。几个模式的区别在于： normal &#x2F; 直通渲染：直接从 Atmos 渲染到 5.1，利用渲染器在前后环绕之间做幻象声像，重建声场。 warping &#x2F; 直通渲染（带房间平衡）：直接从 Atmos 渲染到 5.1，通过更新算法减少声像定位带来的梳状滤波问题，并在房间中点到后方保持恒定电平（也就是消除了后半部分的虚拟声像）。这是目前的 Dolby 默认值，但如果想获得更准确的结果，可以使用 normal。 prologiciix &#x2F; Dolby Pro Logic IIx：先渲染到 7.1，再用特定衰减系数下混到 5.1。 loro &#x2F; 标准 (Lo&#x2F;Ro)：先渲染到 7.1，再按系数下混到 5.1。 对于这部分的选择，最好的方式当然是实际听一下原本的 5.1 presentation (使用 --presentation 1 以解码 5.1)。但如果是 independent presentation，则表明这个 5.1 并非 Dolby 下混，而是单独制作的，可以使用 --warp-mode normal 或不指定，在必要 &#x2F; 条件允许的时候可以追加一个 5.1 重编码。 可以使用 info 命令检查 TrueHD 音频的各个 presentation 属性。输出例： 从中可以获得的重要信息例如： 下混关系：2.0 &lt;- 5.1，7.1 &lt;- Atmos，其中 5.1 和 Atmos 两个独立的 presentation。 Trim detection 不为 0 表示有一部分音频从开头被剪切了，这通常是上游（Remux 发布组等）的处理导致的，可能需要检查丢失的部分是否确无必要。 "},{"title":"x265参数解析","date":"2025-08-18T00:33:09.043Z","url":"/2.Tools/x265%E5%8F%82%E6%95%B0/","categories":[["2.Tools","/categories/2-Tools/"]],"content":"参考资料   (可以选版本) 参数解析  请注意，不能确保完全正确 基本设置(不区分源)etc--preset veryslow or slower --no-open-gop --rskip 0 rskip是放弃某些质量用来加速 --high-tier --range limited --aud --repeat-headers --hist-scenecut 判断转场，VCB建议开着，不过目前看来这个参数还处于beta阶段 --no-sao 设计目的是去振铃(光环现象)，但是细节丰富地方会去掉太多细节 --no-early-skip 加速开关，影响的溯块中不同算法的先后顺序，一般不会去开。 --no-strong-intra-smoothing rect &amp; amp--no-rect rect提供更好的分割能力，能找到潜在的匹配块，它很可能被证明是有用的,但它可能不值得。(画面复杂。离子特效多的情况下会考虑开 rect -VCB) --no-amp 类似rect，即使可能稍微有点用 VCB:通常来说，&lt;&#x3D;1080p 下，rect 基本上没什么作用，amp 是几乎完全没作用，但是这俩都是速度黑洞。因此从效率角度建议关闭，或者至少关闭 amp 个人测试中，1080p开了之后，码率低了一点，画面差了一点 crf,qpqp 电脑认为的恒定画质(但一般不进行设置) crf 人眼认为的恒定画质，但是运动时候画质会降低来节省码率 数值越低画质越好。 一般低于等于18可以认为和原画差不多(主观观点) rd (1-6)分析的复杂度，数值越大画质越高，压出来体积越大，5,6非常慢, 默认3. rdoq-levelRDOP [rate-distortion optimized quantization] (率失真优化量化) 默认0,关闭，预设slow时候默认开启。(preset placebo 似乎也还是2) x265最重要的参数，没有之一，开了能有助于保存细节，当然会有更大文件体积。关闭可以提高压缩速度，看起来会轻度模糊。开启掉速度30%以上，推荐舍弃其他参数，也要开启这个。 设成 1 时候 看起来效果最好，但是体积会大30%以上 设成 2 时候 效果略差，体积只会小幅度增加，推荐使用2 tu-intra-depth &lt;1..4&gt; tu-inter-depth &lt;1..4&gt;默认1，开高会小幅增加压缩率，但是特别慢 (preset placebo 似乎就是4) max-tu-size &lt;32|16|8|4&gt;默认32，开低会降低压缩率，并且不会提速，推荐默认 max-merge &lt;1..5&gt;开高小幅度提高压缩率，对速度影响不明显，默认2 (preset placebo 似乎就是5) me ,merangeme 搜索方式，默认hex ，用umh 或star 能小幅度提高压缩率，但是掉速20% merange 搜索范围，默认57，me设成hex时候，对速度影响不大，但是使用umh或star时候，开高掉速严重 umh比star好 dia hex (default) umh star sea full 如果你的视频分辨率低，merange 可以适当降低； 如果你的视频帧率高，merange 也可以适当降低，因为高帧率视频里帧与帧之间变化小。 理论上 24 和 60 你可以给砍半 merange 都没问题。当然了，画面动态大的打斗片，多给点总是没错的。1080p 下 32 足矣，4k 下可以考虑给到像 x265 preset 默认的 57。同样的，开太大可能会降低压缩率，因为大的 merange 搜索范围可能会搜索到错误的参考。-VCB merange 不建议低于32 -Advanced Encoding Guide me 追求快就用 umh，一般只会开 star。sea，full 都是暴力穷举类型的算法，开了纯属冬天太冷想要取暖用的。-VCB subme开高小幅提高压缩率，开低提高压缩速度，5比3慢10% 推荐7,但是会导致锐化 VCB: 动画给4，希望好的线条给5 Advanced Encoding Guide: 推荐5 不过个人测试中，subme 7 会在细节的还原中更接近源，特别是眼睛。  keyint最大IDR间隔 关键帧相关，这个将会影响到点击跳转，开高能提升压缩率(但个人不建议随便动他，720对于一般的24p意味着30秒的时间，60p你可以稍微开高点？) 默认250 min-keyint最小分组帧数，默认23，推荐改成个位数，提高gop准确度。 小幅度提高压缩率，对压缩速度没影响 min-keyint&#x3D;1 的情况对于一些高速切换的场景会因此要强制1秒内一个IDR帧，造成P或者B等参考帧使用效率降低(换场景了参考的意义已经不大了)。 还有就是这样可以避免一些老旧的设备出现硬解的bug。 - by fch1993 rc-lookahead预览帧数，默认20 开高可以提高分组(gop)准确度，小幅度提高压缩率，同时小幅度降速，推荐40 crf模式时，rc-lookahead可以提高cutree的准确度（提高画质) bframes最大b帧数量，推荐16 开高小幅度提高压缩率，默认4，开到8，掉速10% bframes 开高了会小幅降低画质 cutree--no-cutree since this seems to be a poor implementation of mbtree. 目前测试是静态场景表现不错，具体可以看 不建议开，码率分配存在非常大的问题(有一处分配了31M的码率结果效果还不如一半码率的x264) doom9 上2020年有人说&quot;在快速移动的场景中，我一直在努力解决丑陋的扭曲（用条带涂抹看起来有点像运动模糊的东西），最后发现 x265 的 CUTree 是罪魁祸首。 关闭它可以解决它，但是当试图在其他场景中保持相同的整体质量时，比特率会爆炸。 有什么方法可以使 CUTree &#39;不那么激进&#39; 或将其设置为 50% 或某些阈值参数吗？&quot; ref参照帧数量，默认3 开高小幅度提高压缩率，同时小幅度降速， 3和4速度差不多，推荐4 VCB:不过实测 ref 增加在 x265 中作用不明显。建议不超过 6 strong-intra-smoothing推荐在追求还原度的压制的时候关闭，严重欠码压制时开启(部分情况下，aq2 或者降低 aqs 更为优先) 对关键帧进行平滑处理，看起来挺吓人的，实际上效果不明显，推荐用--no-strong-intra-smoothing关闭，保留细节(来源贴吧 连接1 的帖内说明)  相关讨论，与贴吧给出的结论不同 个人测试是开的话画面细节丢失，影响蛮大 可能适合低码压制 目前测试是在低码压制上会降低块效应(不知道这么说对不对，aqs psy-rdoq开高会导致块变得严重。特别是4K，44Mbps仍然有些欠码，因此4K欠码压制的情况下，这种现象会非常严重，见  不过这个对比图没有块现象严重的对比，只是用于说明所需码率，因为一个没注意顺手删了) lookahead-slices设成0有助于提高画质，开高有利于lookahead的并行度， 推荐设成0，对压缩速度无影响 deblock 去色块要调低 默认太高， 推荐最高调到-1,-1以下，调高了会模糊 frame-threads帧线程数量，开高提高cpu利用率，开低有利于小幅度提高压缩率 如果cpu能够满载可以考虑调到2，如果不能满载考虑使用默认值 (默认会自动调整) aq-modeaq 是防止平面过度量化的功能，用被量化程度去进行 qp 值的补偿 -VCB(其实我没看懂) 目前测试在不足码率压制的情况下,aq1可能会导致画面出现一些奇怪的现象，aq2相对画面更好一些，并且不会出现奇妙的画面 不同的 aq-mode 需要的 aqs 可能不一样 关闭 标准自适应量化：简单为复杂区块分配更多码率。 x265默认 进行帧间 aq-variance 计算，允许跨帧进行调整，带自动方差（auto-variance）调整的自适应量化。（推荐） 带自动方差调整和暗场偏置（bias to dark scenes）的自适应量化。 带自动方差调整和更优边缘保留（edge preservation） （会摧毁平面，但会给更多码率线条和纹理和暗场。除非你追求压缩率，喂给编码器的东西也有针对性处理防止出现伪影(artifact)，不然别开 -VCB 注意该意见可能比较适合动画） 带自动方差调整、更优边缘保留和暗场偏置的自适应量化。（仅aMod） --aq-mode 2 会强调动态和高频部分，平面码率会被削（整体视频码率也就低了），开了很容易平面上出瑕疵，所以如果想开，最好喂视频之前就把平面抹抹干净，并且给 0.9 及以上的 strength。-VCB (该意见可能相对动画来说) 《Advanced Encoding Guide》的推荐是 3或4 带上--hevc-aq（原文很可能缺了个标点，有歧义，实际应该是不带--hevc-aq,这个参数会关闭其他 AQ 模式） 不过上面的意见可能比较适合足码压制，想压低码的话可能aq3不太合适，可能下面的--hevc-aq更好 --hevc-aq根据编码单元（coding unit）的空间活动度相对于帧平均活动度，动态调整量化步长。此方法通过子单元的最小方差来表征编码单元的空间复杂度（spatial complexity）。注意：尽管 x265 文档描述较为抽象，实际效果未必显著，且开启时需禁用其他 AQ 模式。 --aq-bias-strength（仅限 aMod 及支持暗场偏置的 AQ 模式） 范围：0.50 至 1.20（数值越低，偏置越弱） 默认值：1.00 根据源决定--colorprim 9 for HDR, 1 for SDR. --colormatrix 9 for HDR, 1 for SDR. --transfer 16 for HDR, 1 for SDR. --hdr10 for HDR. ctu &lt;64|32|16&gt;分块大小，64速度最慢，32其次 ctu 开的越大，平面的涂抹也越严重，速度也越慢，但是有损压缩效率越高， 值得一提的是， x265 的默认 preset，其实是偏向 4k 级别高分辨率视频给的ctu 64 下，cu 的划分会耗费更多计算量，并且 cu 更倾向于变得更大。这使得给 cu 下更大 TU 的 qp 值给的不是很精确，看起来就是糊。-VCB 16适合DVD，32适合1080p,64适合4K,720p用16,x265可能就会直接退出 《Advanced Encoding Guide》中把这个归类为不调的参数，不过实际可能因为他们只用x265压4K或HDR有关。 qcomp运动时候画质 crf开启时候有效 开高提高运动时候画质，开低减少文件体积 推荐0.6-0.7 aq-strength 默认1.0低于1.0首先保留边缘，高于1.0优先保留纹理，这个值也要看aq-mode，噪点多的片可以调低这个值，噪点少的片调高这个值 不了解不要乱调这个 VCB:aq-strength 决定了 aq 的强度，一般来说，Anime 的 aq-strength 不用太高（太高了码率也会浪费）。通常，aq-mode&#x3D;1，aq-strength 给 0.8 比较合理；aq-mode&#x3D;2，aq-strength 给 0.9 左右，aq-mode&#x3D;3，aq-strength 给 0.7 左右。 psy-rd &amp; psy-rdoq都是Psycho-visual options的参数 具体见 这两者都会影响码率(经测试，开高psy-rdoq到5所增加的码率通过crf来给画面反而效果更好) psy-rd 默认 2.0 有些高，建议开到1.5，开高反而降低画质(不过这种仅适用高还原度压制，如果希望节省码率，这个可能要再试试) 目前看来 VCB 似乎建议开高，国外是推荐真人电影(x264)开到1左右，不过4k 可能需要开到2 psy-rd: 它的核心作用是在编码器进行“模式决策”（比如决定一个编码块应该如何分割、使用何种预测方式等）时，引入一个额外的“惩罚项”。这个惩罚项的目标是：阻止编码器为了节省码率而过度简化（模糊化）人眼认为重要的细节和纹理。 高强度的 psy-rd 可能会导致伪影(artifact) psy-rdoq 其实这玩意儿，可以理解为你想保留的细节大小，你想保留的越小，就给更高。-VCB 一些测试见Compare 测试过但是不使用的参数ssim-rd--ssim-rd 会让 x265 在进行“码率-失真优化”（Rate-Distortion Optimization, RDO）时，使用 SSIM (结构相似性) 作为衡量“失真”的标准，而不是默认的 PSNR (峰值信噪比)。其目标是在同等码率下，生成人眼看起来观感更好、纹理和细节保留更自然的视频，但代价是编码速度会显著变慢。 有需要可以主要了解下 PSNR 和 SSIM 实际使用后感觉同码率下没法保留细节。 Pools &amp; NumaCPU 区别 Intel 和 AMD 在 NUMA 的物理实现和拓扑结构上有着显著的不同，这直接影响了它们在操作系统中的表现以及像 x265 这样的软件如何最优地利用它们。 简单来说：AMD EPYC 的架构更“原生 NUMA”，其内部结构更复杂；而 Intel Xeon 的传统架构更“统一”，但通过特定技术也能模拟出更复杂的 NUMA 拓扑。by Gemini 由于其 Chiplet 架构，AMD EPYC 天然就存在内部的 NUMA 边界。BIOS 中有一个关键设置叫 NPS (NUMA Nodes Per Socket)，它决定了如何向操作系统报告 NUMA 节点。 EPYCNPS 设置: NPS1: 将整颗 CPU 报告为 1 个 NUMA 节点。这简化了拓扑，但隐藏了内部延迟差异，性能可能不是最优。 NPS2: 将 CPU 沿内存控制器通道对半分，报告为 2 个 NUMA 节点。 NPS4: 将 CPU 沿内存控制器通道四等分，报告为 4 个 NUMA 节点。这是最能反映其物理架构的模式，能提供最低的本地延迟。 官方文档:  好像也不用设太多，因为 太多了之后一个 Numa x265 会自动设少线程数，一个线程池最多是64个线程 查到的一些讨论  L3 cache as NUMA Domain 当你启用 “L3 cache as NUMA Domain”（或 BIOS 中的 “ACPI SRAT L3 Cache as NUMA Domain”）时，系统确实会将每个 L3 缓存 (通常与各 CCD 或 CCX 关联) 视为独立的 NUMA 节点。这意味着操作系统会识别更多 NUMA 域，而不是简单按照 CPU 插槽来划分。 如果启用该设置，每个 L3 缓存会被报告为一个独立的 NUMA 节点。例如，每个 CCD（独立的核心&#x2F;cache 单元）有一个 L3 缓存，那么每个 CCD 就成为一个 NUMA 节点。举例来说，如果一个处理器有 8 个 CCD，会报告 8 个 NUMA 节点；双路系统则会有 16 个 NUMA 域。 当 未启用 L3 作为 NUMA 域 时，NPS 参数定义系统如何划分 NUMA 域，以及内存交错（interleaving）方式。例如，NPS&#x3D;2 表示每个插槽按左右半边划分为两个 NUMA 域；NPS&#x3D;4 则划分为四个，分别对应每个 Quadrant（象限） 。 当 启用 L3 作为 NUMA 域 时，NPS 不再决定 NUMA 域的数量（由 L3 缓存数决定），而仅控制内存通道的交错方式。例如，一个处理器有 8 条内存通道，如果 NPS&#x3D;1，则所有通道交错；NPS&#x3D;2 或 NPS&#x3D;4 则按照半边或象限分组交错访问 pools注意，这个参数在 GUI 下传递可能出问题，使用的话可能需要纯命令行，见issue，一般 wpp 默认开启 x265 会根据 CPU 自动配置线程数量，目前测试是两个 Numa 线程数翻倍的情况下，压制速度没有区别。 x265 有两种主要的并行方式： 帧级并行（Frame-level Parallelism）：最高效的方式。多个线程同时处理不同的帧。 帧内并行（Intra-frame Parallelism）：如 WPP，多个线程协同处理同一帧的不同部分。 核心逻辑在于：当 x265 检测到只有一个线程池时，它会优先最大化效率更高的帧级并行。 在一个大的、统一的线程池里（比如你的例子，一个 NUMA 节点上有 24 或 32 个核心），调度器可以非常灵活地将不同的帧分配给任意空闲的线程。这种情况下，帧级并行的效率非常高。 而 WPP 本身是有一些同步开销的。为了处理一行 CTU，需要等待上一行处理完某些初始信息。 因此，x265 的开发者做出了一个明智的决定：如果只有一个线程池，就认为帧级并行已经足够，此时禁用 WPP 可以减少不必要的同步开销，从而可能获得微小的性能提升或简化调度逻辑。 pmode &amp; no-pmode (4.1 deprecated)并行决策模式 官方推荐是CPU不饱和才开，编码器将跨多个工作线程分配每个 CU 的分析工作。 --追加说明，--pme、--lookahead-slices 也在4.1中禁用了。 pmode 和 wpp 是设计理念和实际效果上是冲突的，ps，我以前犯蠢不知道"},{"title":"vs-placebo Readme 翻译","date":"2025-08-13T15:26:58.089Z","url":"/2.Tools/placebo/","tags":[["建设中","/tags/%E5%BB%BA%E8%AE%BE%E4%B8%AD/"],["Plugins&Scripts","/tags/Plugins-Scripts/"]],"categories":[["2.Tools","/categories/2-Tools/"]],"content":"这个可能不能使用 intel 的核显跑，不过 AMD Radeon(TM) Graphics 的核显可以。(目测跟显存之类的有关，AMD 核显有 GPU 内存，和共享 GPU 内存，Intel 核显只有共享 GPU 内存) 找到了 Issue  一个基于 libplacebo 的 VapourSynth 插件接口。 placebo.Deband(clip clip[, int planes = 1, int iterations = 1, float threshold = 4.0, float radius = 16.0, float grain = 6.0, int dither = True, int dither_algo = 0]) 输入需要为8或16位整数或32位浮点数。 planes：指定要处理的通道。第 n 位为 1 的通道会被处理。例如要处理所有通道，传递 planes = 1 | 2 | 4 。（这种方式可能有些复杂，但实现起来最简单。） dither：是否对去带状处理后的帧进行抖动或四舍五入到输出位深。仅对8位有效。 详细的 去带状参数和 抖动方法请参见 libplacebo 头文件。 placebo.Tonemap(clip clip[, int src_csp, int dst_csp, int dst_prim, float src_max, float src_min, float dst_max, float dst_min, int dynamic_peak_detection, float smoothing_period, float scen[...]) 执行色彩映射（包括从 HDR 到 SDR 的色调映射，也可以做更多）。要求输入为 RGB48 或 YUVxxxP16。输出为 RGB48 或 YUV444P16，取决于输入色彩空间。 src_csp, dst_csp：参考 tonemap.c 中的 supported_colorspace 获取有效的 src&#x2F;dst 色彩空间。例如, 从 [BT.2020, PQ] (HDR) 到传统 [BT.709, BT.1886] (SDR) 映射，使用 src_csp=1, dst_csp=0。 dst_prim：目标色域。见 pl_color_primaries。 src_max, src_min, dst_max, dst_min：源&#x2F;目标显示亮度，单位为nits（cd&#x2F;m²）。源亮度可由属性推导。 dynamic_peak_detection：启用信号统计以优化HDR色调映射质量。默认启用。 smoothing_period, scene_threshold_low, scene_threshold_high, percentile：峰值检测参数。见这里。 percentile 仅在 v5.264.0+。 gamut_mapping：用于处理超出色域颜色的色域映射函数，包括色调映射造成的溢出。默认值为1（感知方式）。可选值有： 0 clip 裁剪 1 perceptual 感知 2 softclip 软裁剪 3 relative 相对 4 saturation 饱和度 5 absolute 绝对 6 desaturate 去饱和 7 darken 变暗 8 highlight 高光 9 linear 线性 tone_mapping_function, tone_mapping_mode, tone_mapping_param, tone_mapping_crosstalk, metadata： 色彩映射参数。 tone_mapping_function_s：色调映射函数名称，覆盖 tone_mapping_function 数值。 use_dovi：是否使用 Dolby Vision RPU 的 ST2086 元数据。默认为从 Dolby Vision 色调映射时启用。 visualize_lut：显示色调映射 LUT 的 (PQ-PQ) 图。参见 mpv 文档。 show_clipping：色调映射时高亮显示被硬裁剪的像素。 Dolby Vision 支持需要 FFmpeg 5.0 及以上和 git 版 ffms2。 支持的帧属性 PLSceneMax, PLSceneAvg：每场景的动态亮度元数据，单位为 nits（cd&#x2F;m²）。 float[] PLSceneMax：场景峰值亮度。可以按分量（RGB）或单值指定。 float PLSceneAvg：场景平均亮度。 需要 libplacebo v5.246.0 或更高版本，否则忽略。 如果 PLSceneMax 按分量指定，则元数据设置为 scene_max 和 scene_avg。 如果为单一亮度值且 v5.257.0+，则设置为 max_pq_y 和 avg_pq_y。 启用 use_dovi 时，max_pq_y 和 avg_pq_y 将由 Dolby Vision RPU L1 元数据获得。 placebo.Resample(clip clip[, int width, int height, string filter = &quot;ewa_lanczos&quot;, float radius, float clamp, float taper, float blur, float param1, float param2, float src_width, float src_...]) 输入需为8或16位整数或32位浮点数 filter：可选值见头文件（去掉“pl_filter”前缀）。 src_width, src_height：源区域尺寸，默认为 clip 尺寸。 sx, sy：源区域左上角。可用于亚像素移位。 clamp, taper, blur：滤波器配置。 radius, param1, param2：核函数配置。 sigmoidize, linearize：缩放前是否线性化&#x2F;使用 S 型曲线。RGB 默认启用，YCbCr 默认禁用（NCL YCbCr 不能正确线性化，需转换为 RGB）。GRAY 默认禁用（可能是 YCbCr 通道），可手动启用。HDR 视频建议禁用。 sigmoid_center, sigmoid_slope：S 曲线参数。 trc：用于线性化的 传递曲线。 placebo.Shader(clip clip, [string shader, int width, int height, int chroma_loc = 1, int matrix = 2, int trc = 1, string filter = &quot;ewa_lanczos&quot;, float radius, float clamp, float taper, float ...]) 运行 mpv 语法 的 GLSL shader。 输入为 YUVxxxP16，输出为 YUV444P16。 由于 libplacebo&#x2F;mpv 的自定义 shader 特性设计，shader 不是单独运行的，而是注入到 渲染管线 的任意点，最终输出为 RGB。因此需要用户指定输出帧属性，libplacebo 会生成符合要求的图像，仅当实际渲染相应纹理时才运行指定的 shader。 shader：shader 文件路径。 shader_s：shader 字符串内容。（优先使用 shader。） width, height：输出尺寸。缩放 shader 需指定。未被 shader 缩放的通道，将用同 Resample 的参数缩放到输出尺寸。 chroma_loc：用于推断色度偏移的色度位置。见 pl_chroma_location。 matrix：YUV 矩阵。 sigmoidize, linearize, sigmoid_center, sigmoid_slope, trc：用于挂载到 LINEAR 或 SIGMOID 纹理的 shader。 Debugging libplacebo 处理所有滤镜都可以接受 log_level 参数，对应 pl_log_level。默认值为2，仅记录错误信息。 安装如果你使用 Arch，只需执行 在 Linux 上构建： 不建议不用包管理器直接安装到系统。否则只需 DESTDIR= ninja -C build install。 Linux 交叉编译 Windows 版本：有一个基于 mpv-winbuild-cmake 的实验性构建系统：建议在 Arch Linux 下使用，可能会有不同体验（YMMV）。 附录以下是 VS 里保存的视频属性的值的信息，询问了AI，_Transfer 给的时候它就出了问题，所以仅供参考。 获取信息的方式在 进阶视频压制指南 官方文档 官方标准 这些都在官方标准里有定义 NotesDisplay P3 是 DCI-P3 的一个消费级变体。 SMPTE EG 432-1 标准定义的是 Display P3。SMPTE RP 431-2 和 ST 428 标准定义的是 DCI-P3。 _Matrix 值列表Display P3 没有自己专属的 _Matrix (矩阵系数)，它通常借用 BT.709 或 BT.2020 的矩阵。(也就是9)，HDR+ 和 DV 也是 9 0 vs.MATRIX_RGB RGB 用于表示内容已经是 RGB 格式，不需要 YUV&lt;-&gt;RGB 转换。1 vs.MATRIX_BT709 Rec. ITU-R BT.709-6 绝大多数高清 (HD) SDR 内容。例如 1080p 的蓝光碟、网络流媒体等。2 vs.MATRIX_UNSPECIFIED Unspecified 未指定。VapourSynth 会默认当做 BT.709 处理，但这是一个信号，表明源信息可能不完整。3 (Reserved) (保留值) -4 vs.MATRIX_FCC FCC-73.682 美国 NTSC 模拟电视系统（1953年）。非常古老，基本不会遇到。5 vs.MATRIX_BT470_BG Rec. ITU-R BT.470-4 System B, G 欧洲 PAL&#x2F;SECAM 标清 (SD) 模拟电视。用于处理旧的欧洲 DVD 或电视录像。6 vs.MATRIX_SMPTE170M SMPTE-170M (2004) 北美&#x2F;日本 NTSC 标清 (SD) 数字电视和 DVD。与 BT.601 几乎等同。这是最常见的 SD 内容矩阵。7 vs.MATRIX_SMPTE240M SMPTE-240M (1999) 一种早期的、已被淘汰的 HD 标准。非常罕见。8 vs.MATRIX_YCGCO Y&#39;Cg&#39;Co&#39; 一种计算效率更高的色彩空间，主要用于一些特定的编解码器（如 H.264 的无损模式）。不常见。9 vs.MATRIX_BT2020_NCL Rec. ITU-R BT.2020 (Non-Constant Luminance) 所有现代超高清 (UHD) 内容，包括 4K&#x2F;8K 的 HDR10, HLG, Dolby Vision 以及 SDR 内容。这是 UHD 蓝光和流媒体的标准。10 vs.MATRIX_BT2020_CL Rec. ITU-R BT.2020 (Constant Luminance) BT.2020 的恒定亮度版本。主要用于专业制作和中间格式，消费级内容中几乎见不到。11 vs.MATRIX_SMPTE2085 SMPTE ST 2085 一种用于 HDR&#x2F;WCG 的 Y&#39;Dz&#39;Dx&#39; 色彩空间，与 Dolby Vision 的 ICtCp 类似，但应用不广。12 vs.MATRIX_CHROMA_NCL Chromaticity-derived NCL 基于色度推导的非恒定亮度矩阵。用于一些特殊场景，不常见。13 vs.MATRIX_CHROMA_CL Chromaticity-derived CL 基于色度推导的恒定亮度矩阵。不常见。14 vs.MATRIX_ICTCP Rec. ITU-R BT.2100-0 ICtCp Dolby Vision 和其他一些先进 HDR 系统使用的色彩空间。ICtCp 在感知均匀性上优于 Y&#39;CbCr，能更高效地编码颜色。 _Transfer 值列表1 BT.709 Rec.709 标准（SDR常用）2 Unspecified 未指定4 BT.470M 早期模拟制式5 BT.470BG 早期模拟制式6 BT.601 (525&#x2F;625) NTSC&#x2F;PAL&#x2F;SD7 SMPTE 240M 早期HD8 Linear 线性光响应9 Logarithmic (100:1) 10 Logarithmic (316.22777:1) 11 IEC 61966-2-4 (xvYCC) 12 BT.1361 Extended Colour Gamut 13 sRGB (IEC 61966-2-1) 浏览器&#x2F;桌面常用14 BT.2020 10-bit HDR15 BT.2020 12-bit HDR16 SMPTE ST 2084 (PQ) HDR PQ（HDR10&#x2F;Dolby Vision）17 SMPTE ST 428-1 DCI18 ARIB STD-B67 (HLG) HLG（Hybrid Log-Gamma） _Primaries 值列表1 vs.PRIMARIES_BT709 Rec. ITU-R BT.709-6 所有高清 (HD) SDR 内容的标准。例如 1080p 蓝光、大多数网络流媒体SDR内容。也与 sRGB 色域几乎相同。2 vs.PRIMARIES_UNSPECIFIED Unspecified 未指定。VapourSynth 会默认当做 BT.709 处理，但这是一个需要注意的信号，表明源信息可能不完整。3 (Reserved) (保留值) -4 vs.PRIMARIES_BT470_M Rec. ITU-R BT.470-2 System M 用于 NTSC 制式的古老标清 (SD) 模拟电视。非常罕见。5 vs.PRIMARIES_BT470_BG Rec. ITU-R BT.470-4 System B, G 欧洲 PAL&#x2F;SECAM 标清 (SD) 模拟电视。用于处理旧的欧洲 DVD 或电视录像。6 vs.PRIMARIES_SMPTE170M SMPTE-170M (BT.601) 所有标清 (SD) 数字内容，如 DVD、数字电视。这是最常见的 SD 内容色域。7 vs.PRIMARIES_SMPTE240M SMPTE-240M 一种早期的、已被淘汰的 HD 标准。非常罕见。8 vs.PRIMARIES_FILM Generic Film 通用胶片。主要用于一些胶片扫描的数字中间片。9 vs.PRIMARIES_BT2020 Rec. ITU-R BT.2020 超高清 (UHD) 内容的标准色域。所有 4K&#x2F;8K 的 HDR10, HLG 内容都以此为目标色域。这是一个非常广的色域。10 vs.PRIMARIES_ST428 SMPTE ST 428-1 DCI-P3 (数字影院)。这是数字电影院放映的标准色域。它的白点是 D65。11 vs.PRIMARIES_ST431_2 SMPTE RP 431-2 DCI-P3 的另一种变体，主要用于校准。12 vs.PRIMARIES_ST432_1 SMPTE EG 432-1 Display P3。由苹果公司推广，是消费级电子设备 (iPhone, MacBook) 上的 &quot;P3&quot;。它使用 DCI-P3 的原色，但白点是 D65，与 BT.709 相同。 这是你正在处理的视频的核心属性。13 vs.PRIMARIES_EBU3213_E EBU Tech 3213-E JEDEC P22 色域，用于一些旧的 CRT 显示器。非常罕见。 关于 Display P3 如果你的 _Primaries 显示为 9，这说明视频文件自己携带的元数据标签是 BT.2020。_Primaries: 9 对应 vs.PRIMARIES_BT2020。视频的标签说它是 BT.2020，但实际内容是 Display P3。“BT.2020 容器” 概念这背后是行业普遍采用的一种做法，可以理解为 “BT.2020 容器”。BT.2020 色域 是一个大箱子。Display P3 色域 是一个放在大箱子里面的小一点的盒子。为了让所有的物流系统（播放器、电视、处理软件）都能轻松处理，内容制作者（比如苹果）会把他们的小盒子（Display P3 内容）放进标准的大箱子（BT.2020 容器）里，然后在箱子外面贴上“BT.2020”的标签。这样做的好处是兼容性。整个 UHD 生态系统都围绕 BT.2020 标准建立。如果直接发一个标着“Display P3”的特殊包裹，很多系统可能不知道如何处理。 这里需要你手动改成 12"},{"title":"FXXS压制教程 序 FXXS Encode Guide README","date":"2025-08-10T07:29:01.832Z","url":"/README/","categories":[["undefined",""]],"content":"本教程还在建设中，并且存在不准确，瞎写等问题。 在此提醒一下，学习应该不盲从权威，有足够的自学与判断能力。 公开教程寄望于能降低压制学习门槛，促进沟通交流。 讨论群组: 不受限加入，我们非常欢迎新鲜血液的加入，非组内成员也可参与询问及讨论。不会强制征召。 希望入组的童鞋，在有成品后请联系我。 Scrips里的脚本使用环境是Win,没有经过太多的测试 python 脚本 输入目录 这样，里面的文本要自己根据需要修改内容再跑 mkv 的 json封装，要确保输入端的mkv是规则的，否则可能会因为轨道id不对导致封错内容 软件官方文档Python 文档 用于理解vpy写法以及含义 VS文档 x265文档 一些可供参考的其他教程VCB-S建议有了第一步压制作品，会写VS脚本之后再看  AHD 其他人进行的翻译 Irrational Encoding Wizardry &#x2F; Jaded-Encoding-Thaumaturgy名字其实我也没太搞懂   他们还有Discord(英文) discord.gg&#x2F;qxTxVJGtst ~~他们的插件文档位于 Github repo 的 docs 下，但基本没啥用~· 具体使用目测要去Discord里面搜 划掉，他们写了 API  iAvoe这个的教程跟我们的有一些出入，可能跟侧重点有关，建议在压过一些片，有一定的基础之后再看  Encode Mystery 其他组的脚本国外 int 组 Beatrice-Raws 大佬们的 Github         只有一个人 msg7086  | "},{"title":"进阶视频压制指南","date":"2025-08-10T07:29:01.179Z","url":"/6.etc/Advanced.Guide/","tags":[["建设中","/tags/%E5%BB%BA%E8%AE%BE%E4%B8%AD/"]],"categories":[["6.etc","/categories/6-etc/"]],"content":"说明：并非所有内容都是正确的，部分内容仍待完善。 最新的原文地址在 【译者注：本文为《Advanced HD Video Encoding Guide》老版本的翻译，限制于译者压制与翻译水平均有限，翻译可能产生偏差甚至误导，在此表示歉意。如遇不明之处还请查看原文。同时有些内容随着时间变迁用法有些不同，请读者遇到相关问题时查阅相关内容。】【译者再注：由于所有图片所在图床一起随时间而逝，所有附图均由PDF中提取再经由Photoshop拼接，过程中可能造成些许损失，但应该不影响区分。】 VapourSynth 脚本(vpy) 打印视频信息的代码 另外还有视频打印帧信息的函数 awf.FrameInfo,不过这个到具体的页面详细介绍（现在好像还没写） 缩放(Resizing)首先请注意，后面会有一个单独的部分来介绍 降低分辨率(Descaling) 。而在这，我将解释调整大小的方法以及哪种调整器分别适合什么情况。如果你想调整大小，重要的是不要超过必要的长宽比的改变。如果你要缩小尺寸，首先要搞明白宽度和高度应该是多少。如果你想缩小分辨率到720p，首先要裁剪，然后弄清楚你是缩放至720高还是1280宽。如果是前者，你的宽度应该是： 对于后者，你会发现高度的代码与其非常相似： 你也可以使用 awsmfunc 中封装的 cropresize 函数来处理这些计算并调整大小。 现在有多种调整工具可选，其中最主要的有： Point 临近点，也被称为临近采样(nearest neighbor resizing)，是最简单的缩放方式，因为除了放大每个像素或缩小时获取周围每个像素的平均值，并没有真正做任何事情。它产生的结果很糟糕，但在放大时不做任何模糊处理，因此它非常适用于放大检查每个像素的值。它也是自我矛盾的，所以你可以用它放大然后再缩小，得到与开始时相同的结果。 Bilinear 双线性，缩放处理速度非常快，但会导致非常模糊的结果，并有明显的 锯齿(aliasing) 现象。 Bicubic 双立方，缩放处理速度同样很快，但也会导致相当模糊的结果和明显的锯齿。你可以在这里修改参数以获得更清晰的结果，但这将导致更多的锯齿。 Lanczos 缩放速度较慢，但可以得到非常清晰的结果。然而，它会产生了非常明显的振铃(ringing) 伪影(artifact) 。 Blackmanminlobe 一个 lanczos 的改良版（需要通过 fmtconv 来调用它缩放）具有较少的振铃伪影。这种调整工具对于YUV444编码的色度提升绝对值得考虑（稍后会详细介绍）。 Spline 其缩放速度相当慢，但可以得到非常好的结果。有多种 Spline 调整工具可用，Spline16 比 Spline36 快，但效果稍差，而 Spline36 与 Spline64 效果十分相似，所以没有理由使用后者。推荐在缩小分辨率(downscaling)时使用 Spline36。 nnedi3 其调整大小的速度相当慢，而且只能以2的幂数进行 放大像素(upscale) 。它也可以与 Spline36 结合起来，先将其分辨率放大，而后缩小所需的分辨率。结果明显好于前述的内核。 FSRCNNX 是一个用于 mpv 的着色器，可以通过 vs-placebo 插件使用。它提供了远比 nnedi3 更清晰的结果，但需要GPU的支持。如果可以的话，建议使用它来进行放大分辨率。 附录中提供了这些调整工具的效果比较，图16为降低分辨率，图17为放大像素。此外，由于更改 bicubic 的参数将输出非常显着区别的结果，因此在附录图18还包括了对不同参数配置的 bicubic 放大比例的比较示例。为了满足更强的好奇心，我在图19中加入了缩小至原始分辨率后的对比，并且在附录中的图20中展示了同一调整工具先缩小再放大的情况。 虽然这些截图应该可以帮助你对不同缩放方法之间的差异有一个大致的了解，但它们只是单个画面的一小部分。如果你想更好地了解这些调整工具对整体画面的影响，我建议你自己动手使用，在动态中观察它们，并将它们交错在一起(std.Interleave)进行对比。 降低分辨率时不同调整工具之间的差异比放大时要小得多。 但不建议以此为借口，在降低分辨率时因偷懒而随意选择调整工具。 简而言之: 用 core.resize.Spline36 来缩小分辨率。 检查你的源这可能是花费时间最多的地方：检查你的源代码是否有问题。这需要遍历的整个源文件并亲自是否有 色带(banding) 、 锯齿(aliasing) 、 脏线(dirty line) 以及其他可能存在的问题。好消息是，VSEdit 允许你通过CTRL + SHIFT + LEFT/RIGHT键，按自己定义的步进来检查你的源文件。这个步进可以在预览窗口的右下角定义。我建议步进设置在1至3秒间。显然，间隔越短越好，因为你会检查更多的帧。 为了在一个给定的区间应用一个滤镜，请使用如下方法： 滤镜(Filtering)这有几件值得一提的事。首先，大多数蓝光片都是YUV420P8，范围有限(with limited range)。这里的第一组信息是YUV。这意味着我们视频的平面中Y是 亮度(luma) 平面，U和V是 色度(chroma) 平面。 YUV平面下的颜色，本例是4:2:0，指定了我们的平面大小。这方面最常见的三种变化是：4:2:0，这意味着色度平面是亮度平面的一半大小（例如，一个1920×1080的视频将有960×540的色度平面）；4:2:2，这意味着这种情况下的色度平面是水平分辨率的一半；垂直分辨率的全部；4:4:4，这意味着所有平面都是全分辨率。在播放过程中，视频播放器将色度平面放大到与亮度平面相同的大小。所以较小的色度平面并不明显，但在放大像素时，人们肯定能看出其中的差别。为了说明这一点，这里有个由AnoHana提供的例子，分别是在4:2:0与4:4:4下从720p放大至1080p的两种版本： 图1：两倍放大下，左边是YUV420，右边是YUV444。用 fvf.Debic 降低分辨率，然后用 nnedi3_rpow2.nnedi3和 resize.Bilinear 放大像素。 在这种情况下，最差的调整工具（bilinear）被用于色度平面。如果你使用类似 带有 KrigBilateral配置的mpv 时，这应该看起来好得多。另一个例子：《寄生虫》 SDR UHD缩放为1080p 4:2:0与4:4:4的比较。 图2：《寄生虫》（Parasite (2019)） SDR UHD缩小为1080p情况下4:2:0与4:4:4的比较。感谢HyerrDoktyer提供。 下一个要解释的信息是P8。这指的是 位深(Bit depth)，本例中是8-bit。现在大多数视频都存储在8-bit，因为8-bit的 AVC【译者注：H.264】 具有最好的硬件兼容性。 然而，由于8-bit导致位深没有足够的值(0-255)可用，它很容易引入例如 色带(Banding) 之类的错误。更高的位深在这方面没有这么大的问题，且由于其更好的准确性，10-bit实际上更能以较小的文件体积存储视频。然而，10-bit的 AVC 几乎没有硬件兼容性可言，而且需要更长的时间来编码，因此PT用户通常不喜欢它。实际上大多数内容是以10-bit或12-bit制作的。 由于精度的提高，最流行的滤镜处理位深是16-bit。值得注意的是，UHD蓝光将采用YUV420P10，即10-bit。 最后一部分，则要讲述的内容是限制范围(limited range)。在全范围(full range)8-bit中，我们可以用0至255之间的每一个值。可是，电视通常无法显示这些值，因而亮度被限制在16至235、色度被限制在16至240。大多数消费内容（如蓝光盘）也被限制在有限的范围内。假如你给电视一个全范围的视频，它将简单粗暴地将所有16及以下或235&#x2F;240及以上的数值显示为相同效果(make ... the same value)（例如：黑色或白色）。 抖动(Dithering)尽管如果你将以与源文件相同的位深输出，就没有必要在高位深下工作，但为了输出时避免四舍五入的错误，建议在滤镜链的最后使用抖动降低位深，这可能会导致色带的伪影(artifact)（图23是一个例子）。幸运的是，即使你不选择以高位深来编写脚本，大多数插件都可以在内部用高位深工作。由于抖动的速度相当快，而且更高的位深确实能带来更好的精度，所以除了一些为8-bit写的函数稍慢之外，通常没有理由不在更高的位深下工作。 如果你想了解更多关于抖动的信息，维基百科上的内容相当丰富，也有很多值得一读的研究出版物。在这里你只需要明白，只有当压制源和使用滤镜后的片段之间存在实际差异时，你使用的抖动方法才是重要的。由于抖动是对不同位深的四舍五入的一种选择，只有与实际整数的偏移才会有差异。一些算法可能在不同的情况上比其他的更好，因此，有理由使用非标准的算法。例如，如果你想将某个视频的色带去除，并以8-bit的形式输出，但在正确压缩方面存在问题时，你可能想考虑有序抖动，因为众所周知，它在这种情况下的表现略好（尽管它看起来不那么棒）。要做到这一点，请使用以下代码： 同样，这只会影响实际的去色带区域。这在大多数情况下并不推荐，因为有序抖动的效果相当难看，但如果你在压缩去色带区域时遇到困难，这依然值得考虑。显然你应该使用遮罩并调整去色带函数的参数，后面会有更多关于此的内容。 为了向上或向下抖动，你可以使用 fvsfunc14(fvf) 或 mvsfunc15(mvf) 中的 Depth 函数。这两者之间的区别是，fvf 仅使用内置调整工具，而 mvf 不仅可以内置调整工具，而且也支持 fmtconv，它比较慢，但有更多的抖动（和缩放）选项。然而，两者都具有标准的 Filter Lite error_diffusion 抖动类型，所以如果你只是使用默认值，我会推荐 fvf。为了说明优质抖动与劣质抖动之间的区别，在附录中的图21下提供一些例子。 请注意，你可能要放大到相当大的程度才能发现其区别。有些PDF阅读器可能会不正确地显示这些图像。 我建议在大多数情况下使用 Filter Lite（fvf 的默认值 或 mvf.Depth(dither=3) 即 mvf 默认值)。其他如 Ostromoukhov (mvf.Depth(dither=7)), void and cluster (fmtc.bitdepth(dither=8)), standard Bayer ordered (fvf.Depth(dither=&#39;ordered&#39;) 或 mvf.Depth(dither=0)) 有时也会有用。不过，Filter Lite 通常更适用。 去色带(Debanding) &amp; 去色块(Deblocking)去色带(Debanding)最常见的问题。当位深不足和劣化设置导致色彩因为平滑梯度出现可分辨的断层，就是色带现象。 这些可以通过执行类似模糊的操作并限制其输出来修复。 请注意,由于模糊是一个非常具有破坏性的过程,因此建议仅将其应用于视频的必要部分,并使用掩码来进一步限制更改。 关于去色带，需要注意的一点是，你应该尽量使用遮罩，最好是边缘遮罩或类似的东西。详见 遮罩(Masking) 在 VapourSynth 中，有很优秀的工具可以用来修复色带：neo_f3kdb, fvsfunc&#39;s gradfun3(有内置遮罩) and vs-placebo&#39;s placebo.Deband。 neo_f3kdb 这些设置对一些人来说可能是不言自明的，但还是说明一下各参数的作用： src 这显然指你的输入内容。 range 指定了用于计算某场景中色带的像素范围。更高的范围意味着更多的像素被用于计算，也意味着它有更高的性能需求。默认值15通常是足够的。 y 最重要的设置，因为大多数（明显的）色带发生在亮度平面。它规定了在亮度平面上要有多大的差异才会被认为是色带的。你应该从低数值开始，缓慢但有效地提高，直到色带消失。如果设置得太高，很多细节就会被视为色带，从而变得模糊不清。 cb&#x2F;cr 与y相同，但应用于色度平面。然而，色度平面上的色带是很不常见的，所以你通常可以忽略它。 grainy&#x2F;grainc 为了防止带状物再次出现，并抵消平滑度，通常在去色带过程后加入颗粒(grain) 。然而，由于这种假颗粒是相当明显的，建议保守一点添加。另外，你可以使用自定义加噪，这将得到一个更好的输出（见 3.2.10 颗粒化(Graining)） dynamic_grain 默认情况下，f3kdb添加的噪点是静态的。这样压缩效果更好，因为动态显然更少，但它在实拍内容中看起来不正常，所以除非你正在处理动画内容，否则通常建议将其设置为 True。 sample_mode README 有解释，考虑换到 4, 因为它的细节损失可能较少。 GradFun3f3kdb 最受欢迎的替代品是 gradfun3。该函数需要更多资源，参数也不太直观，但在 f3kdb 遇到困难时也很有用。由于有大量参数，本指南仅介绍最重要的参数 很多这些值是用于 fmtconv 位深转换的，因此它的文档可以证明其是有帮助的。GradFun3中的降低分辨率与其他缩小方法没有什么不同，所以我不会讨论这个。其他一些可能感兴趣的参数是： thr 等价于y&#x2F;cb&#x2F;cr。你可能想提高或降低它。 radius 与 f3kdb的range 具有相同的效果。 smode 设置平滑模式。通常最好保持默认值，即双边(bilateral)滤镜。如果你想使用支持CUDA的GPU而不是CPU的话，可以把它设置为5。使用 ref（默认为input clip）作为参考素材。 mask 如果设置为0，则禁用遮罩。否则，它设置了要调用的 std.Maximum和std.Minimum 的次数。 planes 设置需要处理的平面。 mode 设置 fmtconv 中使用的抖动模式。 ampn&#x2F;staticnoise 设置 fmtconv应该添加多少噪点以及噪点是否为静态。对于真人动作内容来说，有必要进行调整。 debug 允许你查看遮罩。 elast是 &quot;软阈值的弹性&quot;。更高的值会在去色带遮罩和源之间做更多的混合。 placebo.Deband这款 Deband 对于 VapourSynth 来说相当新，但它非常擅长修复强带。然而，同样地，它也容易造成不必要的细节损失，因此只应在必要时使用，最好与细节&#x2F;边缘遮罩结合使用。它的（当前）参数： 此功能将来很可能会发生重大变化，因此 README 也非常值得一读。 参数 planes 要进行的平面. 这里的语法不同，请查看 README。简而言之，默认为仅亮度，1 | 2 | 4 为亮度和色度。 iterations 设置 debander 循环。不建议更改此默认值，尽管这在极端情况下很有用。 threshold 设置 debander 的强度，或者说是像素改变时的阈值。您可能不希望设置得比 12 高很多。以 1 为步长增加，如果可能的话进行微调。 radius 与以前的功能相同。与 f3kdb的range 具有相同的效果。 grain 跟 f3kdb 一致, 但做的更好 vs-debanduntest 他们的插件经常会跟进最新的 VS 版本。 建议找他们仓库提供的 Discord 连接进群查询插件语法及用法 example 去色块(Deblocking)解锁主要相当于平滑源，通常在上面再加一个掩码。这里最流行的函数是来自 havsfunc的Deblock_QED。其主要参数是 quant1：块边缘解锁的强度。默认值是24。你可能想显著提高这个值 quant2：区块内部解锁的强度。默认值是26。同样，提高这个值可能被证明是有益的。 其他流行的选项有 deblock.Deblock，它相当强大，但几乎总是有效；dfttest.DFTT，效果较弱，但仍然相当积极；以及 fvf.AutoDeblock，它对解锁MPEG-2源相当有用，可以应用于整个视频。另一种流行的方法是简单的去色带，因为去色块和去色带是非常类比似的。这对AVC蓝光资源来说是一个不错的选择。 example deblock.Deblock 指的 VapourSynth-Deblock Irrational Encoding Wizardry 系列插件位于vs-denoise里的dpir 引用了 vs-mlrt,可能有硬件要求，我这会崩溃 example 修复脏线(Dirty Lines)及不合适的边缘(Borders)另一个非常常见的问题，至少在真人电影的内容中，是脏线。这类问题通常出现在视频的边界上，与周围的行相比，某一行或某一列的像素通常表现出过低的亮度值。通常情况下，这是由于不适当地缩小分辨率，更明显的是在应用边框后的缩小分辨率。脏线也可能发生，因为视频编辑者往往不知道他们是在YUV422下工作的，这意味着他们的竖向像素值不必是偶数；而消费者内容将是YUV420，意味着竖向像素值必须是偶数，导致额外的黑行。 另一种形式的脏线是在黑条上出现色度平面时表现出来的。 通常情况下，这些应该被裁剪掉。然而，相反的情况也可能发生，即具有合法的亮度信息的平面但缺乏色度信息。 有六种常用的滤镜用于修复脏线。 cf的ContinuityFixer ContinuityFixer 的工作原理是将指定的行&#x2F;列与周围范围指定的行&#x2F;列数量进行比较，通过最小二乘法再回归找到新值。其设置如下： 这是假设你使用的是1080p的素材，因为半径的值被设置为源的分辨率所定义的最长的集合。我建议使用一个更低的值，但不要低于3，因为在这一点上，你可能是在复制像素（参见下面的FillBorders）。可能会让大多数新手感到困惑的是，我输入了一个数组，作为要固定的行&#x2F;列的值。这些值表示要应用到三个平面上的值。通常情况下，脏线只会发生在亮度平面上，所以你通常可以把其他两个平面的值保持为0。 请注意，数组并非必须，因此您也可以只输入希望应用修复的行&#x2F;列的数量，所有平面都会被处理。ContinuityFixer 最擅长的一点是去除不规则的东西，比如点。 它也比 bbmod 和 FixBrightnessProtect2 快，但它应该被视为这两者的备选方案。 awsmfunc的bbmod 这是原BalanceBorders 函数的一个修改版。它与 ContinuityFixer 非常相似，但在更高的 模糊值(blur) 和 阈值(thresh) 的情况下会产生更好的效果。如果它没有产生去分的结果，可以改变这些，但是你设置的模糊值越低，这个函数的破坏性就越大。它也比 havsfunc 和 sgvsfunc 中的版本快得多，因为只有必要的像素被处理。 thresh 和 blur 的数组也是Y、U和V的值。建议先试试 blur=999，然后尝试降低这个和 thresh 的值，反复尝试，直到你得到合适的效果。thresh指定了结果可以和输入值相差多少。blur 是过滤器的强度，数值越低越强，数值越大则越弱。如果你设置 blur=1 ，你基本上就等同于复制行。 fb的FillBorders 这个函数几乎就是复制下一列&#x2F;行的内容。虽然这听起来很傻，但当分辨率缩小导致更多的行在底部而不是顶部，并且由于YUV420的偶数的竖向像素值，我们不得不填充一行时，它就会非常有用。 这个函数的一个非常有趣的应用是类似于只对色度平面应用 ContinuityFixer，它可以用在灰色边界或无论应用什么亮度平面修复的修复方法都与边界不匹配他们的环境时。这可以用下面的脚本来完成： 你也可以分离平面并单独处理色度平面，尽管这只是稍微快一点。允许您为fb【译者注：core.fb】指定每个平面值的封装函数是 awsmfunc 中的 FillBorders。 edgefixer的ReferenceFixer 这需要原始版本的edgefixer（cf只是它的一个旧的移植版本，但它使用起来更漂亮，处理过程也没有改变）。我从来没有发现它有什么用处，但从理论上讲，它是很好的。它与一个参考素材进行比较，以调整其边缘固定。 rekt的 rektlvls 这基本上是 FixBrightnessProtect 和 FixBrightness 的合二为一，另外还有一个事实，即不是整个画面都被处理。它的参数非常简单明了，提高调整值可以变亮，降低调整值可以变暗。将 prot_val 设置为0时，它的功能就与 FixBrightness相同，意味着调整值需要改变。 如果你想一次处理多行，你可以输入一个列表（例如，rownum=[0, 1, 2]）。 有一点不应该被忽视的是，对太多的行&#x2F;列应用这些修正（除了 rektlvls 之外）可能会导致最终结果看起来很模糊。正因为如此，我们建议尽可能使用 rektlvls，或只在必要的行上使用亮度修复。如果失败了，最好在使用 ContinuityFixer 之前先试试 bbmod。 值得注意的是，你总是应该在调整大小之前修复脏线，否则做会引入更多的脏线。然而，更需注意的是，如果你在边缘使用 FillBorders 填充了一条黑线，你应该使用调整大小的工具来删除它。例如，要将一个顶部有一条填充线的片段从1920 × 1080调整为1280 × 536时应该这么做： 如果你要处理对角线的边框，正确的做法是使用蒙版覆盖源，用FillBorders 调用合并源。为此举一个例子（来自D-Z0N3压制的作品《你的名字》）： 图5：该示例为《你的名字》（Your Name (2016)）中不恰当地使用边框。D-Z0N3的使用了蒙版，而Geek没有。 因此，Geek缺乏任何类似的纹理，而D-Z0N3则尽可能地保留它。使用 FillBorders 中的镜像模式可能更明智，但事后看来是20&#x2F;20【译者注： “20&#x2F;20视力”称为“完美”视力】。 D-Z0N3使用的代码（16-bit下）： 在附录中的图22下有一个例子，说明为什么要使用蒙版。 为了说明脏线可能是什么样子，这里有一个 ContinuityFixer 和纯色的 FillBorders 对比的例子。 图6：来源于的D-Z0N3的压制作品《无声的声音》（A Slinet Voice (2016)）的脏线修复与过滤。在最上面的三行使用 ContinuityFixer，在最左边的两列使用FillBorders。 当前画面放大15倍。 脏线很难发现。如果你在随机检查不同帧的边界时候不能发现存在脏线，那么可能就没有问题。如果你发现有每边都有小黑线边界，那么可以使用类似下面的脚本： 这个脚本将 threshold 以下的数值（即黑色边框）在大部分黑色背景的中部显示为垂直或水平白线。你可以运用这个函数来浏览并检查你的视频。你也可以尝试使用 blckdtct27，它可以为你扫描视频。 其他类型的可变脏线是一个修复难题(a bitch to fix)，需要手动检查场景。 一个与脏线非常相似的问题是糟糕的边界(bad borders)。在不同场景中（例如IMAX或4:3），黑色边框有时可能不完全是黑色的，或者完全被打乱了。为了解决这个问题，只需将其裁剪并重新添加。你也可能想修复过程中可能出现的脏线： 抗锯齿(Anti-Aliasing)这可能是最常见的问题。如果你想解决这个问题，首先要确定这个问题是由锯齿而不是糟糕的 放大像素(upscaling) 造成的。如果你已经确认，我推荐的工具是 TAAmbk 套件： 尽管GitHub的README内容相当详细，但在这有必要进行一些额外的补充： aatype: (默认值: 1) 这里的值可以是表示亮度平面AA类型的数字，也可以是表示其AA类型的字符串。 我建议使用的是 Eedi3、Nnedi3、Spline64SangNom 和 Nnedi3SangNom。 这两种 SangNom 模式都具有难以置信的破坏性，只有在绝对必要的情况下才应使用。Nnedi3 通常是你最好的选择；它不是很强也不具有破坏性，但往往足够好，而且速度相当快。Eedi3 慢得令人难以置信，但比 Nnedi3 强，且不像 SangNom 模式那样具有破坏性。 aatypeu: (默认值 aatype 一致) 当片段的格式为YUV时，为U平面选择主AA内核。 aatypeu: (默认值 aatype 一致) 当片段的格式为YUV时，为V平面选择主AA内核。 strength: (默认值: 0) 预降(predown)的强度，有效范围是[0, 0. 5]。 在应用主AA核之前，分辨率会先被缩小到 (1- strength)×clip_resolution，然后被主AA核放大至原始分辨率。这可能对那些因放大像素不足而造成严重锯齿的素材有好处。当使用不适合放大像素的AA内核时，自动禁用。如果可能，即不要增加，也不要降低。 preaa: (默认值: 0) 选择 preaa 模式 0: 不使用 1: 垂直 2: 水平 -1: Both 在应用主AA内核之前，先使用 preaa。preaa 基本上是 daa 的一个简化版本。在处理由劣质 反交错(deinterlacing) 引起的残余隔行(residual comb)时相当有用。否则，不要使用它。 cycle: (默认值: 0) 设置主AA内核的循环次数。用于非常非常糟糕的锯齿和3D锯齿。 mtype: (默认值: 1) 选择要使用的边缘遮罩的类型。目前三种遮罩类型分别是： 0：无遮罩 1：Canny遮罩 2：Sobel遮罩 3：Prewitt遮罩 遮罩总是在8-bit下构建。这所有选项都棒，但你最好测试一下，看看哪种最终效果最好。 mclip: (默认值: None) 使用自定义遮罩，而不是由函数内部建立，并且你应该自己处理遮罩的分辨率、位深、格式等问题。如果设置了mclip，脚本将不会构建其他遮罩了。 mthr: 遮罩的大小。你给定的值越小，你将得到越大的遮罩。 mlthresh: (默认值: None) 为 n-pass 的遮罩设置亮度 thresh。使用一个列表或数组来指定luma的部分。 mpand: (默认值: (1,0) ) 使用一个列表或元组来指定掩码扩展和掩码放大的循环。 txtmask: (默认值: 0) 创建一个掩码来保护屏幕上的白色字幕。值是亮度的阈值。有效范围是0-255。当一个区域的亮度值大于阈值，色度值为128±2时，它将被认为是一个字幕。 txtfade: (默认值: 0) 设置淡入淡出的长度(时长？)。用于的淡入淡入淡出字幕。 thin: (默认值: 0) 在应用主AA内核之前，通过aWarpSharp2对该行进行扭曲。 dark: (默认值: 0.0) 在应用主AA内核之前，通过 Toon 使线条变暗。 sharp: (默认值: 0) 在应用主AA内核后，对片段进行锐化。 0: 没有锐化。 1 inf:LSFmod (defaults&#x3D;&#39;old&#39;) 0 1: 类似 Avisynth 的 sharpen() -1 0: LSFmod (defaults&#x3D;&#39;fast&#39;) -1:ContraSharpen 无论哪种类型的锐化，较大的锐化绝对值意味着较大的锐化强度。 aarepair: (默认值: 0) 使用修复来消除由主AA内核引入的伪影(artifact)。根据不同的修复模式，原始素材中的像素将被处理过的素材的3x3邻居中的中位数或平均值所取代。强烈建议在主AA内核包含 SangNom 时使用该修复。更多信息请查看。 但很难让这个工具正常工作。 postaa: (默认值: False) 是否使用 soothe 来对抗锐化带来的混杂现象。 src: (默认值: clip) 引入片段进行锐化、修复、蒙版合并等。 stabilize: (默认值: 0) 通过 MVTools 稳定时间上的变化。值是时间半径。有效范围是[0, 3]。 down8: (默认值: True) 如果你将此设置为 True，引入的片段将先被降低到8-bit，并在应用主AA内核之后回升到原始的位深度。在位深转换中，采用 LimitFilter 来减少损失。 showmask: (默认值: 0) 如果你把它设置为非0数值，则输出遮罩而不是处理过的片段。 0：正常输出 1：只有蒙版 2：粘性蒙版和剪辑 3：交错蒙版和剪辑 -1：只有文本蒙版 opencl: (默认值: False) 是否使用opencl版本的一些插件。目前有三个插件可以使用opencl： TcannyCL EEDI3CL NNEDI3CL 这可能会加快速度，这显然是很好的，因为抗锯齿计算通常是很慢。 opencl_device: (默认值: 0) 选择一个 OpenCL 设备。要知道选择的是哪一个的，请输入： 其他参数： 将被收集到一个特别为 aatype 制作的手册中。 请注意，还有很多非常好的抗锯齿方法，以及许多不同类型的遮罩，你可以使用（例如，其他边缘遮罩，无限接近两种遮罩的结合(clamping one method’s changes to those of another method)等等）。然而，大多数方法都是基于与 TAA 实现的非常相似的方法。 如果你的整个视频都受到锯齿的影响，那么放大像素的效果就很糟糕，这也不是太不可能的。在这种情况下，在决定你是否需要执行抗锯齿操作之前，先降低分辨率或调整大小。 这有一个抗锯齿修复例子（来自《悠哉日常大王》(劇場版 のんのんびより ばけーしょん（2018）)）： 图7：左边为带有锯齿的源，右边为滤镜处理后 在这个例子中，我们进行了以下操作： 降低分辨率(Descale)虽然大多数电影是以2K分辨率制作的，大多数动漫是以720p制作的，但蓝光片几乎都是1080p，UHD蓝光片都是4K。这意味着母版制作公司经常要对画面进行放大。这种操作的结果通常不理想，但幸运的是，有些损伤是可逆的。由于动漫通常以比源图像更高的分辨率发布，而且使用 bilinear 或 bicubic 放大像素非常常见，大多数缩小分辨率软件是为动漫编写的，这也是你需要缩小分辨率的主要场景。真人电影通常不能被缩小分辨率，因为糟糕的专有缩放器（通常是 QTEC 或类似的），因此大多数真人电影压制人员不知道是否需要缩小分辨率或根本不考虑。 所以，如果你对动漫进行编码，一定要确保查看过原画分辨率(check what the source images are)。你可以使用 来查阅原画发行信息 ，通过 getnative 进行截图，或者干脆自己试试。最后一个选项显然是最好的方法，但 getnative 通常也非常好，而且更容易。Anibin，虽然也很有用，但并不总是能得到正确的分辨率。 为了达到缩小分辨率的效果，你应该使用 fvsfunc： 在上面的例子中，我们将使用 bilinear 缩小到720p，并用 Spline36 将色度平面缩小到360p。如果你为一个不关心硬件兼容性的网站&#x2F;团体压制动漫作品，你可能会想将yuv444=true，并相应地改变你的编码设置。 降低分辨率支持使用 bilinear、bicubic 和 spline 放大内核。除了 Debilinear之外，每一种都有自己的参数。对于 Debicubic，这些参数是： b：在0和1之间，这相当于应用了模糊的效果 c：也在0到1之间，这是锐利的效果 最常见的情况是 b&#x3D;1&#x2F;3和c&#x3D;1&#x2F;3 ，这是默认值；b&#x3D;0和c&#x3D;1，这是过度锐化的 bicubic；b&#x3D;1和c&#x3D;0，这是模糊化的 bicubic。不过，介于两者之间的数值也很常见。 同样，Delanczos 也有 taps 选项，使用Spline 放大分辨率的同样可以用 Despline36 和 Despline16 来反转放大分辨率操作。 缩小分辨率后，你很可能想再放大至1080p或2160p。这样做的首选方法是通过 nnedi3，或者更具体地说是使用edi3_rpow2 或 nnedi3_rpow2。 我们在这里做的是 bilinear 放大后再降至720p，然后用 nnedi3 将其升至1440p，再降至1080p，然后与源的色度平面合并。这样做的原因有很多： 大多数人都没有正确地设置视频播放器来使分辨率放大(upscale the footage)。 那些不是很了解情况的人往往认为更高的分辨率&#x3D;更好的质量，因此1080p更受欢迎。 很多PT站点只允许720p和1080p的画面。也许你不想伤害色度平面，或者原始分辨率介于两者之间（810p和900p很常见）时，你更想放大到1080p而不是缩小至720p。 另一件要注意的事是，字幕和其他文字往往是在放大像素后添加的，因此你需要使用一个蒙版，以免破坏这些文字。幸运的是，你可以简单地在降低分辨率的函数名称后添加一个M（DebilinearM），你就会得到一个遮罩。然而，这将大大减慢了缩小分辨率速度，所以你可能想在这里进行场景过滤。 在上述常见的分辨率缩小方法之外，还有一些值得考虑的滤镜，尽管它们的作用实际上都是一样的，那就是对线条艺术(line art)（又称边缘）进行分辨率缩小，并将其重新调整为源分辨率。如果在放大分辨率后添加了大量的抖动，这就特别有用。 DescaleAA：fvsfunc 的一部分，使用一个 Prewitt 遮罩来找到线条艺术并重新将像素放大。 InsaneAA：使用强化的 Sobel 遮罩以及混合使用 eedi3 与 nnedi3。 就个人而言，我不喜欢把它放大回去并坚持使用YUV444编码。然而，如果你想这样做，你也可以考虑尝试编写你自己的遮罩。一个例子是（根据以前的代码）。 为了说明区别，这里有一些放大至源分辨率的例子。请注意，通过视频播放器将YUV444分辨率缩小后的画面放大会更好看。 图8：蓝光源，左边是通过 bicubic 放大函数将720p的画面提升到1080p，右边是用Debilinear 和 nnedi3 重新缩放。 重要的是要注意，这当然也可以用于实景拍摄的画面。一个例子是《权力的游戏》第一季的UHD蓝光片，它是双线性(bilinear)升频的。虽然在截图中并不明显，但在播放过程中的差异是惊人的。 图9：《权力的游戏》（Games of Throne:Seaon 1 (2011)）UHD蓝光源，左边是通过 bilinear 像素放大函数将1080p的画面提升到2160p，右边是用 Debilinear 和 nnedi3 重新缩放。 如果你的视频在每一帧中都有多个源分辨率（即不同的层有不同的分辨率），你可以通过 getnative 输出多个结果来注意到这一点，你最好的办法是通过 Spline36 缩小到最低分辨率。虽然从技术上讲，你可以屏蔽每个图层，将它们全部缩小到它们的源分辨率，然后再将每个图层放大回去，但这太费劲了，不值得这么做。 去振铃(Deringing)术语 &quot;振铃&quot; 可以指大多数边缘伪影(artifact)，其中最常见的是蚊式噪声(mosquito noise) 和 边缘增强伪影(edge enhancement artifacts) 。振铃是低质量视频源中十分常见。然而，由于拍摄设备原因和糟糕的压缩方法，即使是高比特率的音乐会也很容易出现这种情况。为了解决这个问题，建议使用 HQDeringmod 或 EdgeCleaner（来自 scoll）等软件，我建议使用前者。这些方法主要目的是模糊和锐化边缘，然后通过边缘遮罩进行合并。它们简单易用，所以你可以自己阅读和了解它们，并熟悉它们的用途。由于 rgvs.Repair 可能相当激进，如果你使用这些函数，并且默认值不能产生足够好的结果，我建议你尝试修复数值。 图10：左边是源，右边是经 HQDeringmod(mrad=5, msmooth=10, drrep=0) 处理后的。 这是非常暴力的去振铃方式，我一般不推荐。该示例图像是来自One Ok Rock演唱会，码率37 mbps蓝光视频。 去光晕(Dehaloing)光晕如其名：边缘周围的粗而亮的线条。这一问题常出现在没有正确地调整大小后。你可能也会发现，像素缩小(descaling)参数不足或对低质量视频缩小分辨率会产生明显的光晕。为了解决这个问题，你应该使用havsfunc的DeHalo_alpha 或其已蒙版处理的同类产品 FineDehalo。如果使用前者，你必须编写你自己的掩码，因为无掩码的去晕通常会导致糟糕的结果。关于如何写一个简单的去光晕遮罩，请看encode.moe的指南。 由于 FineDehalo 是 DeHalo_alpha 的衍生函数，因此它们共享一些参数。 AviSynth维基上的解释足以帮助了解： 和  。 降噪(Denoising)降噪是一个相当棘手的问题。真人电影压制从不降噪(Live action encoders will never denoise)，而动漫压制往往会降噪过度。你想对动漫进行降噪的主要原因是，它本身不应该有任何噪点，但压制时会引入噪点，而位深转换会引入抖动。前者是不需要的，而后者是需要的。你也可能会遇到像闪回(flashbacks) 过程中遇到明显的颗粒感(grains) 。去除不需要的噪点将有助于压缩码率，并消除一些轻微的抖动&#x2F;颗粒感；这对10-bit来说是很有用的，因为更平滑的视频源可以更好地进行编码并得到很好的效果，而8-bit的效果更为突出，更多的噪点可以防止出现色带等。可是，有时你可能会遇到这样的情况，你必须对压缩以外的内容进行去噪&#x2F;去纹。例如，假设你正在对一部动漫电影进行编码，其中有一个原版动漫剧集的闪回场景。动漫电影通常是1080p制作的，但大多数系列不是。因此，你可能会遇到一个带有大量颗粒的1080p升级版。在这种情况下，你会想把颗粒去掉，重新缩放，并把它合并回来。 颗粒化(Graining)由于颗粒(grain)【译者注：可以理解为有益的噪点】和 抖动(dither) 是最难压缩的东西之一，许多视频源都只包含很少的颗粒，或者已去除明显的颗粒。为了应对这种情况，或者仅压缩没有颗粒的区域，手动添加颗粒往往是有利举措的。在这种没有明显颗粒的情况下，你通常要先移除噪点，然后再重新打上颗粒。这对动画片尤其有利，因为缺乏颗粒通常会使重编码更难保持颜色渐变。由于是人为地添加颗粒，我们可以选择静态颗粒。在动漫中不易被察觉，而且压缩效果更好，因此它通常是动漫内容的最佳选择。然而，这在真人电影内容中往往是相当明显的，因此静态颗粒不常被用于发布在PT的压制作品中。 标准的加噪函数，grain.Add，也是其他函数在用的： 这里的 var 标志着强度。一般不会调得太高。如果你发现自己把它调得太高，它就会变得很明显，以至于你要尝试颗粒与画面相匹配，以保证颗粒不影响画面。 最著名的添加颗粒的函数是 GrainFactory3。这个函数允许你指定 grain.Add 应该如何应用于三个不同的亮度(luma)级别（亮、中、暗）。同时该函数也用 resize.Bicubic 对亮度平面进行缩放，以提高或降低其大小，以及通过函数中 b和 c 参数对其进行锐化，这些参数通过锐化选项来修改。由于你必须修改大小、锐度和阈值参数，所以在这里可能很难匹配。 然而，它可以产生很棒的效果，特别是对于具有更多自然颗粒的实景内容。 自动化程度更高的选择是 adaptive_grain。它的工作原理与 GrainFactory3 相似，但根据整体画面的亮度值和特定区域的亮度，对部分画面应用不同数量的颗粒。由于它没有很多设置项，所以更容易使用，而且对动漫来说效果很好。由于其考虑整个帧画面的平均亮度，因此能产生非常好的效果。 除了这两个函数之外，还有一个叫做 adptvgrnMod32 的组合，它将 GrainFactory3 的锐度和尺寸规格选项添加到 adaptive_grain 中。由于颗粒只被添加到一个（通常比帧小）图像的一个尺寸中，这往往是最快的函数。如果颗粒的大小不会因为不同的卢马等级而改变，就像数字生产的颗粒一样，这可能会导致比前述两个函数更好的结果。 对于那些好奇这可能是什么样子的人来说，请参考图4中《未来的未来》（Mirai (2018)）的去色带例子，因为在那个例子中，adptvgrnMod 被用来做纹路。 色彩校正(Detinting)如果你有一个较好并但偏色的片源和一个较差且无色彩渲染的片源，而你想去掉偏色层(you’d like toremove tint)，你可以通过 timecube 和 Dr.Dre 的颜色匹配工具来实现。首先，在该工具中添加两张参考截图，导出LUT，保存它，并通过以下方式添加它： 图11：左为偏色的源，右为色彩纠正后的。这个例子来自于D-Z0N3压制的《你的名字》（Your name (2016)）。此帧中还进行了抗锯齿处理。 同样，如果你有所谓的 伽马(gamma) 错误，或者更准确地说，双范围(double range) 压缩（将有限范围的压缩完全应用于已经过范围受限处理的片段），只需做以下工作（适用于16-bit）： 图12：左由双范围(double range)处理，右由伽马(gamma)修复处理 通常会要求的使用值为0.88，但其他伽玛值也不是不可以。如果黑色的亮度值是218而不是235，这就是必要的。不要在低位深下进行这种操作，原因如图23所示。如果色度平面也受到影响，则必须单独处理它们： 你也可以使用 awsmfunc中封装的fixlvls 函数来完成所有这些操作。 如果你有一个色彩矩阵不正确的源，你可以用以下方法来解决这个问题 &#39;470bg&#39;就是通常所说的601。调整大小的原因是，矩阵转换发生在 YUV 到 RGB 转换之间，这意味着我们需要提高色度。 我们使用点调整大小，因为它是绝对的。要知道你是否应该这样做，你需要一些参考来源，最好不是网络来源。从技术上讲，你可以识别不好的颜色，并意识到有必要改变矩阵。 图13：使用了TayTO压制的《燃烧》（Burning (2018)）进行矩阵转换的例子。最值得关注的地方是她的粉红色胸罩和背景中的红色。 去硬字幕和图标(Dehardsubbing and Delogoing)虽然这个问题在动画片中特别常见，但它也发生在一些实拍片源中，而且许多音乐视频或音乐会在电视台播放时都有标识，因此值得研究如何删除硬拷贝或标识。对于logo，Delogo 插件非常值得考虑。要使用它，你将需要 Logo 的 .lgd 文件。你可以通过你最喜欢的搜索引擎简单地查找这个，应该会找到一些东西。从那里，用这个插件做什么应该是相当直接的。 最常见的去除硬字幕的方法是比较两个来源，一个有硬字幕，一个没有硬拷贝的参考来源。我推荐的函数是 kagefunc33的hardsubmask 和 hardsubmask_fades。前者只对有黑白字幕的资源有用，而后者可用于标识和移动字幕。两者的重要参数是扩展选项，这意味着对 std.max 的调用。根据你的视频源质量和检测到的数量，可能需要降低这些参数值。 我们也可以用 Delogo 进行类似的操作，以创建一个类似的遮罩： 一旦你准备好你的蒙版，你就可以把你的参考无硬字幕源和主源合并起来。此过程中可能需要使用一些着色处理，因为二者可能有色差。值得注意的是，这样做要远好于将好的视频源（有硬字幕）替换成差的视频源。如果你很懒，通常可以毫无问题地将这些蒙版应用到整个片段中，无需遍历整个视频来寻找硬字幕区域。 遮罩(masking)【译者注：也可以叫做蒙版】这是最复杂的部分，也是动漫编码人员之外的大多数编码人员倾向于忽视的部分。遮罩有助于保护重要的细节不被你的滤镜所破坏。PT压制组使用的最常用的蒙版是二值化蒙版(binarize masks)。 在这种情况下，我假设我们是在16-bit下操作。std.Binarize 在这里所做的是在位深允许范围内将小于5000以下的每个值变为最小值，5000以上的每个值变为最大值。这意味着5000以上的每个像素都将从源素材中复制出来。这通常被称为亮度遮罩(luma mask)，通常用于解决画面暗部色带问题。 我们也可以用其中一个色度平面来做相同的事： 你可能已经注意到了，我进行了同样的二值化处理，但同时调整了蒙版的大小并使其膨胀。调整大小的原因显然是因为色度平面在YUV420中的分辨率较低，但有些人可能对调整工具的选择产生疑惑；使用双线性(bilinear)调整器会导致模糊，这意味着周围的像素也会受到影响，这通常对抗锯齿很有效。出于同样的原因，我增加了一个额外的 std.Inflate，尽管它通常对亮度平面比色度平面更有效。 更有趣和有用的蒙版是边缘蒙版和去烙印的特定蒙版。对于边缘蒙版，VapourSynth 用户有一个很大的优势，因为 kgf.retinex_edgemask 令人难以置信的准确，有着不可思议的结果。这个边缘遮罩获取源图像，使用 retinex 算法来提高黑暗区域的对比度和亮度，然后在 Kirsch 遮罩的基础上叠加一个 TCanny 遮罩。它的两个常见的用途是去色带和抗锯齿。 对于去色带，你通常希望从源文件中获取尽可能多的内容，以避免破坏细节，因此我们在低值处进行二值化，并用std.Maximum 和 std.Inflate 来增强蒙版。我们想用这个遮罩将源文件中的内容添加到去色带处理的片段中。我们可以用很多不同的方法来处理蒙版，比如把超过阈值的东西都乘以某个值 (std.Expr(retinex, &quot;x 7000 &gt; x 10 * x ?&quot;)，只让它最大化和膨胀，让它保持原样，或者你可以做任何想做的操作。 以一种非常不同但又相似的方式，抗锯齿通常只想应用于明显的边缘，因此我们在一个高值上进行二值化。std.Inflate 的调用就十分重要，它可以让我们获得应用抗锯齿的全部特效。在这里，我们想通过我们的遮罩将抗锯齿添加到源文件中。 其他有用的**边缘遮罩(edge mask)**包括： std.Prewitt std.Sobel 通常比Prewitt更准确，但如果不选择 Kirsch 或 Retinex 遮罩，建议同时测试这两种遮罩。 tcanny.TCanny 这基本上是在一个模糊的片段上抛出了一个 Sobel 遮罩。 kgf.kirsch 在明亮的场景中会产生与 retinex_edgemask 几乎相同的结果，因为其被包含其中。处理速度比其他的慢，但因它使用了更多的方法(directions)，会给你带来很好的结果。 所有这些的比较可以在附录中的图24和25下找到。 虽然边缘遮罩对去色带很有帮助，但它们往往也会检测到色带本身的边缘，而且通常相当慢。很好的替代品包括 GradFun3 和 debandmask。 后者非常快，能得到更好的结果，但它经由膨胀处理。对于 GradFun3，你可以使用Frechdachs制作的 Fag3kdb。我建议尽可能使用 debandmask，但在较暗的场景中，边缘遮罩通常被证明能产生更好的结果，所以要做一些测试进行选择。要从 GradFun3 中得到一个蒙版输出，你可以这么做： 图14：GradFun3（左上）、debandmask（右上）、retinex_edgemask（左下）和 retinex_edgemask.std.Maximum().std.Inflate()（右下）的比较 针对那些对使用和不使用遮罩的强力去色带之间的区别感到好奇的人，我们准备了附录中的图26作为参考，对比一个简单的边缘遮罩对去色带的影响。当使用亮度&#x2F;色度遮罩时，请不要忘记测试你是否应该在之前的遮罩上使用适当的边缘遮罩或去色带专用遮罩，因为简单的亮度遮罩会使边缘被破坏。附录中的图27和28有这方面的例子。 现在我们已经介绍了常见的蒙版，让我们继续介绍那些能帮助你操作的蒙版或创建你自己的蒙版。在这我只简单介绍，因为他们的文档写的非常详细。 std.Maximum/Minimum：用这个来放大或缩小你的蒙版，你可能还想应用 coordinates=[0, 1, 2, 3, 4, 5, 6, 7]，使用任何适宜的数值来指定周围像素的权重。 std.Inflate/Deflate：与前面的函数类似，但它不是应用像素的最大值，而是将它们合并，这将使你得到一个轻微的边缘模糊。在大多数蒙版的末尾很有用，这样你可以在蒙版区域之间得到一个轻微的过渡。 std.Expr：众所周知，这是一个非常复杂的函数。通过反向波兰语符号应用逻辑。如果你还不知道，可以去维基百科粗略了解。你可以用它做一些很酷的事情，比如让一些像素变亮，同时保持其他像素不变（而不是像 std.Binarize 那样让它们变暗）：std.Expr(&quot;x 2000 &gt; x 10 * x ?&quot;)。 这将使2000以上的每个值都乘以10，而其他的则保持不变。有一个很好的用例是，在数值之间：std.Expr(&quot;x 10000 &gt; x 15000 &lt; and x &#123;&#125; = x 0 = ?&quot;.format(2**src.format.bits_per_sample - 1))。这使得10000和15000之间的每一个值都是位深所允许的最大值，其余置零，就像 std.Binarize 蒙版做的那样。几乎每一个函数都可以或者已经通过这种方式表达了。 std.MakeDiff 与 std.MergeDiff：字如其名。用法可以是将一些东西应用于降噪的片段，然后将片段合并回来，正如在降噪部分所阐述的那样。 std.Convolution：从本质上讲，对你的像素应用矩阵。其文档对此进行了很好的说明，如果没有理解，请仔细阅读。很多蒙版是通过卷积核定义的。 你可以用它来做很多事情，就像 std.Expr 一样。例如，如果你想平均一个像素周围的所有数值，那么使用 std.Convolution([1, 1, 1, 1, 0, 1, 1, 1, 1])。 std.Transpose转置（即翻转）你的片段。 std.Turn180：旋转180度。 std.BlankClip：生成一帧纯色的画面。你可以用它来替换糟糕的背景，或者在整个影片中添加颗粒感但又不希望片尾字幕充满颗粒感的情况下使用。为了保持电视色彩范围，你可以对8-bit黑色使用 std.BlankClip(src, color=[16, 128, 128])。这个函数在制作基于区域的蒙版时也很有用。 std.Invert：不言而喻。你也可以只交换通过蒙版合并片段，而不是这样做。 std.Limiter：你可以用它将像素限制在某些数值。对维持电视色彩范围很有用（std.Limiter(min=16, max=235)）。 std.Median：这将用其附近的中位值替换每个像素。大部分情况不会用到。 std.StackHorizontal &#x2F; std.StackVertical：将片段上下&#x2F;左右拼叠 std.Merge：这可以让你将两个具有给定权重的片段合并。权重为0将返回第一个片段，而1将返回第二个片段。你需要提供给函数一个片段列表和一个权重列表。下面是如何将第二个片段的色度平面合并到第一个片段的亮度平面中：std.Merge([first, second], [0, 1])。如果没有给出第三个值，第二个值将被应用于第三个平面。 std.MaskedMerge：根据给定的蒙版，将第二个片段与第一个片段合并。 std.ShufflePlanes：从一个片段中提取或合并平面。例如，你可以用 std.ShufflePlanes(src, 0, vs.GRAY) 获得亮度平面。 如果你想只在某个区域应用某个东西，你可以使用封装好的函数 rekt34 或 rekt_fast。后者只将你的函数应用于给定的区域，这就加快了它的速度，对于抗锯齿和类似的慢速慢速滤镜相当有用。关于它的一些封装好的函数已经出世，比如用于抗锯齿的 rektaa。rekt_fast lambda 函数相关，所以你应该输入rekt_fast(src, lambda x: core.f3kdb.Deband(x))，而非 core.f3kdb.Deband(src)。 还有一个非常特别的函数是 std.FrameEval。它允许你对一个片段的每一帧进行评估，并应用一个特定于帧的函数。这很令人困惑，但在 VapourSynth 的文档中有一些不错的例子。现在，除非你有兴趣写一个需要这样做的函数，否则你可能永远不会使用它。然而，许多函数都使用它，包括kgf.adaptive_grain、awf.FrameInfo、fvf.AutoDeblock、TAAmbk等。我能想到的一个例子是，根据帧的类型应用不同的去色带工具来展示这一点： 如果你想了解更多，我建议阅读Irrational Encoding Wizardry GitHub小组的指南 ，并阅读大多数你喜欢的 VapourSynth 和 Python 函数相关手册。几乎所有的优秀压制员都应该使用一些蒙版，或者针对特定的情况开发自己的蒙版。 滤镜顺序以错误的顺序使用滤镜会导致破坏性的或失败的过滤。正因为如此，建议使用以下顺序： 图15：推荐应用每个滤镜的顺序。在某些情况下，降噪可能必须先于调整大小前进行。 脚本范例Mirai (2018): Sword Art Online: The Movie - Ordinal Scale (2017): Sword.Art.Online.The.Movie.Ordinal.Scale.2017.ITA.1080p.BluRay.AC3.x264.D-Z0N3 BTS - Blood, Sweat and Tears (2016) BTS - Blood, Sweat &amp; Tears 2016 1080p ProRes FLAC 2.0 AVC x264 10-bit - A.R.M.Y 对bandmask的快问快答： 边缘遮罩通过寻找梯度大的区域来工作，所以最简单的卷积是$$\\left[ \\begin{matrix} 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; -1 \\ 0 &amp; 0 &amp; 0\\end{matrix} \\right]$$意思是我们要检查左边的像素和右边的像素之间的差异。 我们可以移动减法，通过检查与原始像素的差异来识别没有颗粒的区域。$$\\left[ \\begin{matrix} 0 &amp; 0 &amp; 0\\ 1 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0\\end{matrix} \\right]$$不过，这并不是这里发生的事情；我们是在卷积的多次迭代后进行减法，所以我们得到了更多像素的梯度。然后我们将其二值化，最小化以去除噪声(noise)，然后再次最大化。 其他可供阅读的有趣脚本：  Kaiji episode 1 by blaze077  How to IVTC by eXmendiC  Various scripts by Beatrice\u0002Raws  Various scripts by LightArrowsEXE  Made in Abyss episode 1 by kageru  Something by Nginx from TnP  - Various scripts by Vardë  - Various crowdsourced scripts 论坛和博客文章公开： 降低分辨率：  遮罩：  自适应加噪： Krisch和Retinex的边缘遮罩： 降噪工具：  私藏： 色带遮罩的解析： adptvgrnMod 的噪点参数解析： 自动去色带（不使用 banddtct 的情况下）：  聚焦于**双范围(double range)**压缩： 对何时与如何使用脏线修复的看法（使用ContinuityFixer）： 运用banddtct 与 dirtdtct： x264参数设置来自于AHD指南的参数（需硬件兼容的用斜体字做标注，并有一部分修改）： 通用参数设置： --level 4.1 用于DVXA【译者注：DirectX Video Acceleration】 --b-adapt 2 使用最好的（x264具有的）算法来决定B帧的插入位置。 --min-keyint 通常应该是你的视频的帧率，例如，如果你是编码23.976帧的内容，那么你就使用24帧。这是设置I帧之间的最小间隔。 --vbv-bufsize 78124 --vbv-maxrate 62500 用于DVXA（旧的指南使用较低的值来考虑将编码写入蓝光盘播放的可能性，但这不再需要考虑，因为其他设置破坏了这种兼容性。新的数值是 --level 4.1 可以做到的最大值，如果你的设备因此而损坏，那不是编码的问题，而是你的设备不符合DXVA规格）。 --rc-lookahead 250 如果使用 mbtree，则为60或更高。这设置了x264可以提前多少帧查看，这对 mbtree 来说至关重要。你需要大量的内存来实现这一点。(就我个人而言，我现在只是把它放在250，因为它对内存使用的影响是2GB左右）。如果你在没有 mbtree 的情况下进行编码，并且在你的脚本中有很多 ReplaceFramesSimple 的调用，一定要调低这个值。 --me umh 是你应该去的最低限度。如果你的CPU足够快，你可能需要忍受 tesa 带来的减速。esa 需要和 tesa 相同时长而没有任何好处，所以如果你想放慢你的编码来尝试捕捉更多的运动矢量，就使用 tesa，尽管这种增加并不一定总是值得。这并不是一个你需要测试的设置，但是如果你使用 tesa，你可能会从x264中挤出一些更多的性能。 --direct auto 这将会自动选择预测模式(spatial &#x2F; temporal)。 --subme 10 or 11 （就个人而言我会设置为11，他们的不同在于对编码速度有3-4%的影响）。 --trellis 2 --no-dct-decimate 相反的是dct-decimate是牺牲质量换取速度。把它关掉好了，因为你的电脑很可能足以应付。 --preset veryslow or placebo 尽管我们改变的参数会让 veryslow 变成 placebo，也无所谓了。 受源影响的参数设置： --bitrate / --crf 比特率【译者注：也称为码率】的单位是Kbps（千比特&#x2F;秒），CRF采用浮点数，越低质量越好。这是你掌握的最重要参数；如果码率不足，质量肯定会很次。如果码率过高，就会臃肿不堪(如果人们想下载大文件，他们会得到一个remux)。当然，码率的需求可以根据来源的不同而有很大的不同。 --deblock -3:-3 to 1:1 对于真人电影，大多数人只是坚持使用-3:-3。对于动漫来说，通常取-3:-2和0:0之间的值，两个值之间的偏移量为1是正常的（一般取值为-1:0，0:-1，和-2:-1）。 --aq-mode 1 to 3:1 在每一帧的基础上分配码率，2倾向于将更多的码率分配给前景，并且可以在小范围的帧中分配码率，3是2的修改版，试图将更多的比特分配给帧的暗部。要知道哪种模式最适合，唯一的办法是进行测试。但几乎每一个源最终都是用 aq-mode 3 时看起来最好。 --aq-strength 0.5 to 1.3 0.5至1.3之间的值非常值得尝试。 更高的值有助于（避免？）色块(help with blocking)。更低的值倾向于将更多码率分配至前景，与 aq-mode 2 所做的类似。当使用CRF进行编码时，此参数会极大地影响码率，因此如果您打算使用CRF进行最终编码，那么使用2- pass测试此参数可能是值得的。 --merange 24(能够使用的最低的值) to 64 设置太高（超过128）可能有害，32或48对大多数编码来说都很好。一般来说，对于有大量运动的电影（如动作片），（使用 umh 时）将1080p设为32-48、720p为32有所成效。人物对话场景可以应用24这样的低值。对编码速度的影响是明显的但并不严重。个人而言，在使用 umh 时，我更喜欢将1080p设置为48，720p设置为32，或者使用 tesa 时，1080p为32，720p也为32。 --no-mbtree 我强烈建议在启用和禁用 mbtree 的情况下进行测试，因为通常它会导致两种截然不同的编码结果。宏块树(mbtree) 基本上试图降低块而不是帧的质量，因此只有帧中不重要的部分被分配更低码率。要做到这一点，它需要知道一个块以后被引用的频率，这就是为什么 rc-lookahead 应该被设置为 250。这对有静态背景的视频很有用，比如动画片。或者在那些已经使用了高 qcomp（.75或以上）的视频，宏块树的影响较小。在测试宏块树开启与否哪种合适时，你可能需要重新测试每一个参数设置，特别是qcomp、psy-rd 和 ipratio。 --ipratio 1.15 to 1.40 1.30是最常用的数值。此参数决定I帧和P帧之间比特率的分配比例。 --pbratio 1.05 to 1.30 1.20是最常用的数值。此参数决定P帧和B帧之间的比特率分配比例。这个值应该总比 -ipratio 低0.10左右，所以在测试 -ipratio 的时别忘了降低它。如果你使用 mbtree，这个设置不会有任何影响，因为其由宏块树自身决定。 --psy-rd 0.40:0 to 1.15:0 0.95:0到1.15:0适用于真人电影。第一个数值是 psyrd 强度，第二个是 psy-rellis 强度。这试图使x264不使事情变得模糊，而是保持复杂性。对于动画片来说，(0.40和1.00之间):0.00是通常选用。psy-rellis 通常会引入很多振铃(ringing)，但可以帮助保持抖动。 你可以为真人表演尝试0.00和0.15之间的值，为动画尝试高达0.50的值,如果你提高你的 aq-strength 的话，通常会得到更好的结果。 --bframes 6 to 16 这是设置可以用B帧替换的连续P帧的最大数量。在你的第一次测试运行中使用16，并根据x264日志进行设置: x264 [info]: consecutive B-frames: 1.0% 0.0% 0.0% 0.0% 14.9% 23.8% 13.9% 15.8% 8.9% 9.9% 0.0% 11.9% 0.0% 0.0% 0.0% 0.0% 0.0% 从第一个百分比为0开始计算，选择超过1%的最高数字，在这个例子中是11。(或者就把这个数字保持在16，因为允许更多的 bframes 不会损害你的编码，而且会帮助压缩，对速度的影响并不是那么巨大)。 -ref 设置每个P帧可以使用的前一帧的数量作为参考。如果你不关心硬件兼容性（和&#x2F;或正在进行10-bit编码），将其设置为16。这对性能的影响相当大，但在大多数时候是值得的。计算你可以使用的数字，或者如果你使用本末提供的CLI输入，它将由x264为你计算。始终使用你可以使用的最大值。 最大的--参考值可以按以下方式计算：对于--级别4.1，根据H.264由于每一帧是以YV12格式存储的，或每像素1.5字节，一个1920x1088帧是1920×1088×1.5&#x3D;3133440字节&#x3D;3060千字节。请记住，在进行计算时，将两个维度四舍五入到mod16值，即使你没有进行mod16编码！让我们来计算一下1920x800。 1920 × 800 × 1.5 &#x3D; 2304000字节 &#x3D; 2250千字节。12，288÷2250千字节&#x3D;5.45777778，所以你最多可以使用5个参考帧 注意，这些转换使用基数2，所以1千字节&#x3D;&#x3D;1024字节。如果你把数学弄错了，那也没关系--如果你用的太多，x264会显示一个警告，所以你会知道你是否需要改变它。 --zones 对去色带和区块相当有用，因为这些区域需要较大的比特率来保持透明度。其语法为： --zones 0,100,crf=10/101,200,crf=15 或 --zones 0,100,b=5/101,200,b=10 在这种情况下，b是一个码率系数。你也可以用它来处理那些没有得到足够比特分配的区域。特别常见的区域是较暗的场景或有大量红色的场景。渐变也会受到码率缺失的影响，需要进行分区。也可以在片头时降低码率，以节省一点压制时间。 --output-depth 8 or 10 取决于你想编码的格式 --output-csp i444 仅在编码4:4:4时需要，否则无需此参数。 x265 参数这里的文档已经足够好了，所以我只需要介绍一下推荐值： 与源无关的参数设置： --preset veryslow or slower --no-rect 对于较慢的电脑。有些许可能被证明是有用的，但很可能并不值得。 --no-amp 与 rect 相似，尽管它看起来稍微更有效。 --no-open-gop --no-cutree 因为这似乎是一个很糟糕的mbtree实现（应用）。 --no-rskip rskip 会牺牲一些质量来换取加速，所以对于差点的cpu来说，它值得考虑。 --no-sao 因为 sao 是x265中最愚蠢的实现（设置）之一。 --ctu 64 --min-cu-size 8 --rdoq-level 2 --max-merge 5 --rc-lookahead 60 虽然并不相关，但只要大于 min-keyint。 --ref 好cpu用6，差点的用4。 --bframes 16 或者取决于最终的 bframes 日志输出的值。 --rd 3 or 4 (目前是效果一致的) --subme 5 你也可以把它改成7，但众所周知这会导致锐化。 --merange 57 只要不要低于32，就不会有问题。 --high-tier --range limited --aud --repeat-headers 受源影响（依赖于源）的参数设置: --colorprim X (X代表数值) HDR设为9，SDR设为1。 --colormatrix X (X代表数值) HDR设为9，SDR设为1。 --transfer X (X代表数值) HDR设为16，SDR设为1。 --hdr10 仅HDR需要。 --hdr10-opt 适用于4:2:0 HDR，--no-hdr10-opt 适用于 4:4:4 HDR 和 SDR。 --master-display &quot;G(8500,39850)B(6550,2300)R(35400,14600)WP(15635,16450)L(10000000,20)&quot; L的值取自于源的媒体信息(with the values for L coming from your source’s MediaInfo output)。 --max-cll &quot;711,617&quot; 同样来自于源的媒体信息。 --cbqpoffs 和 --crqpoffs 通常应该在-3和0之间。它设置了应用于亮度和色度平面的比特率之间的偏移量(This sets an offset between the bitrate applied to the luma and the chroma planes)。 --qcomp 0.60 to 0.80 --aq-mode 4, 3, 2, 1 or --hevc-aq 4和3通常是两个最佳的选择。 --aq-strength 0.80 to 1.50 --deblock -4:-4 to 0:0 与x264相同。真正使用时你可以用默认的 -3:-3。 --ipratio and --pbratio 与x264相同。 --psy-rd 0.50 to 2.00 与x264相似。 --psy-rdoq 通常从0.00到2.00不等。 --no-strong-intra-smoothing 用于锐化&#x2F;噪点的内容。对于模糊不清的内容，可以把这个选项打开，因为这是一个额外的模糊，有助于避免色带。 --output-depth 10 10-bit输出。 实验性质的参数（设置）： --scenecut-aware-qp --scenecut-window 550 --max-qp-delta 2 --hist-scenecut --hist-threshold 0.02 测试参数设置首先，你要选择一个较小的视频文件区域作为参考，因为对整个文件进行测试会花费很多时间。推荐的方法是通过使用 awsmfunc的SelectRangeEvery： 这里，第一个数字是各部分之间的偏移量，第二个数字是各部分的长度，偏移数组内为开始和结束的偏移量。 你要使用一个相当长的片段（通常是几千帧），包括黑暗、明亮、静态和动作场景，但是，这些场景应该大致上在整个视频中一样平均分布。 当测试参数时，你应该一直使用2-pass编码，因为许多参数会大大改变 CRF 得到的比特率。对于最终的编码，两者都很好，尽管 CRF 更快一些。 要找出怎么设置是最好的，就需要把它们都与源文件相互比较。你可以通过单独交错或通过 awsmfunc 将文件夹内所有内容进行交错来达成比较。通常还需要给它们贴上标签，这样你就能知道你在看哪个片段。 如果你使用 yuuno，你可以使用下面的 iPython Magic ，通过悬停在预览屏幕上让预览在两个源之间切换 通常情况下，你会想先测试一下码率。只要在几个不同的CRF下编码，并与源画面进行比较，找到与源码无差别的最高CRF值。现在，将该值四舍五入，最好是向下，然后切换到2-pass。对于标准测试，测试qcomp（步进为0.05）、aq-modes、aq-strength（步进为0.05）merange（32、48或64）、psy-rd（步进为0.05）、ipratio&#x2F;pbratio（步进为0.05，并保持两者间0.10的差值），然后deblock（步进为1）。如果你认为 mbtree 有帮助（即你在对动画进行编码），在打开 mbtree 的情况下重新进行这个过程。你可能不会想太多地改变顺序，但当然也可以这样做。 对于x265，测试调整顺序应该是qcomp、aq-mode、aq-strength、psy-rd、psy-rdoq、ipratio 和 pbratio，最后 deblock。 如果你想要提高一点额外的效率，你可以在你最终决定的每个设置的数值周围用较小的步进再次进行测试。建议在你已经对每个设置做了一次测试之后再做，因为它们都会对彼此产生轻微的影响。 一旦你完成了对2-pass设置的测试，就切换回CRF，重复寻找视觉无损的 CRF 值过程。 音频SoX如果你的源音频是高清晰度(hi-res)的（24位或&gt;48kHz），你可能要考虑改变它以节省空间，因为如果转换能够恰当的完成的话，高解析度音频对消费者来说很大程度上只是心理作用。为了做到这一点，我们推荐SoX。如果你想转换为16-bit 48 kHz，你可以使用以下方式： 如果你的源音频的采样率是48kHz的倍数（如96kHz），就使用这个。对于44.1kHz的倍数，你可以简单地把48000换成44100。 我们建议对编码进行这些转换，因为更高的采样率通常比其他任何方法更具破坏性，24-bit和正确处理后的16-bit之间的差异是如此之小，以至于只有在极高的音量下才会注意到。 有损编码OpusOpus，虽然是最高效的编解码器，也是音乐会(Concertos)上首选的有损编解码器，但几乎没有硬件兼容性。这对使用HTPC、台式机、笔记本电脑甚至手机的人来说都不是问题，但试图使用蓝光播放器播放的用户就无法解决了。由于我们不那么关心硬件兼容性，这可能是最简单的方法了。 除了是最有效的编解码器，它也是完全开源的，就像FLAC一样，在每个操作系统上都能完美运行。 为了对 Opus 进行编码，你需要安装 opus-tools，从那里开始，你只需要: 此外，如果你不想使用（公认较低）默认值，你可以指定 -- bitrate，尽管Opus会自动检测它的最佳目标比特率。 qAAC 和 fdkaac作为在效率方面紧随 Opus 之后的 qAAC，也是一个可行的选择。与 Opus 不同，AAC 有更好的硬件兼容性，特别是在立体声方面。它也没有有序章节的问题。然而，qAAC 需要 iTunes，在 Unix 下需要 Wine。为了编码最高质量的 qAAC，你将要输入： -V 指定质量，数字越大越好，最大值是127。 Dolby Digital(DD) 又名AC3硬件兼容性之王是AC-3。由于它是DVD的首选编解码器，所以它在大多数播放设备上有非常好的支持。然而，它的效率比MP3还差。如果你想在家里编码以实现硬件兼容（例如，你想为AHD&#x2F;HDB&#x2F;等压制组工作），推荐的方法是通过 Sound Forge（Windows）或 Dolby Media Producer（OS X）。 为了用 Sound Forge 对 AC-3 进行编码，打开文件（w64格式），等待它建立索引，然后进入另存为选项。从这里，选择Dolby Digital AC-3 Pro。然后，选择以下选项（从AHD的指南中复制）。 Bitstream mode: Main audio service: Complete main Audio coding mode: 3&#x2F;2 (L, C, R, Ls, Rs) with LFE enabled Sample rate: 48 kHz Data rate: 640 kbps Dialog normalization: -32 dB Do not select Save data in Intel byte order Center mix level: -3 dB Surround mix level: -3 dB Do not set copyright bit do not mark as original bitstream Do not include audio production information Do not enable extended bitstream information Do not enable digital de-emphasis Enable DC high-pass flter Enable Bandwidth low-pass flter Enable LFE low-pass flter Do not enable 90-degree phase shift Do not enable 3 dB attenuation Line mode profle: None RF mode profle: None Do not enable RF overmodulation protection 新的E-AC-3编解码器正异军突起。这带来的是对 Atmos 与更多通道的支持。然而，EAC3编码器的唯一缺陷是并不包括对 Atmos 的支持，其效率与AC-3相同，因为它只是在其基础上封装了另一层。 由于这些原因，我们觉得除了说明需要 Dolby Media Producer 外，没有必要详细说明它是如何编码的。 DTS这种编解码器在1080p的PT编码中十分常见。坦率地说，这只是因为臃肿的比特率(bloated bitrate)。DTS 实际上在1509 kbps时比 AC-3 在448 kbps时更糟。就不要用这个了。考虑它的唯一原因是偷懒，因为几乎每个电影源都会有一个DTS核心音轨，可以直接套用。 无损编码FLAC它是免费、开源的，兼容性极佳，压缩效率最佳的。如果你是立体声或单声道，它在硬件兼容性方面应该没有问题。否则，它可能对一些接收器有问题。 TrueHD由于硬件支持较差，这种编解码器不如 DTS-HD MA 流行，但它的压缩率更高一些，特别是在低比特率的情况下，DTS核心的臃肿并不会使比特率膨胀。遗憾的是，由于其较差的硬件兼容性，很多小组坚持再封装一条单独的AC-3兼容音轨。在交响音乐会(Concertos)制作中，我们希望您不要这样做，但我们理解这可能是上传其他地方所必须的，或者仅仅是您为了硬件兼容性所做的妥协。 DTS-HD MA由于更好地支持使用核心(DTS-core)作为后备，这种编解码器在环绕声重合中相当受欢迎。你可以将你的音轨提取为多个wavs，每个通道一个，然后将它们拖入编码套件，并点击大的红色编码按钮来进行编码。在交响音乐会(concertos)中，我们并不关心这种编解码器，我们更喜欢使用 TrueHD 或 FLAC。 混流追加文件有时，你的编码会崩溃，或者你想编辑某个编码的一小部分。在这样的情况下，我们可以 mkvtoolnix 中方便地追加文件。如果你只是想在另一个文件后添加一些东西，只需在 mkvtoolnix 的源文件分区中右击该文件即可。 对于视频内的编辑，首先在结尾处找到适当的I帧，这样你就真正编码够了，然后编码你的片段，在 mkvtoolnix 中打开每个文件，在输出标签中进入分割选项，然后为视频的一部分设置帧。请记住，这里的计数从1开始，而不是像 Python 那样从0开始。对你想添加变化的部分进行这样的处理，然后像以前一样追加。你也可以这样做来创建一个混合视频的Remux。 确保在混音后检查文件包含所有必要的帧，因为如果你不注意的话，很容易导致使用错误的I帧或由于错误的修剪而导致帧数不正确。 无缝衔接推荐阅读这篇文章： 。 在这没什么需要补充的。 推荐的教程和资源 Irrational Encoding Wizardry’s fansubbing guide:  Kageru’s blog:  eXmendiC’s filtering guide:  AHD Guides 贡献者们（以字母表排名） Aicha @ D-Z0N3, NSDAB, REEEEEEEE Anon @ Concertos, NSDAB Q2KTyrant @ Concertos Ryuu @ Concertos, NSDAB Scrooge @ Concertos, COC, FidelityTM xCreamEnte @ EPSiLON, HDBEE, SiGMA 附录 图16：不同降低分辨率函数的效果比较。将源从1080p缩小到720p，然后被裁剪。所有参数都保留默认值。 图17：放大以后的大小。来自于Commie压制的《你的名字》（Your Name (2016)），相较于源进行了裁剪，然后被放大了2倍。 图18：不同参数的双三次(bicubic)放大比较。记住，这些只是视频的小片段，双三次放大总是会导致伪影，特别是锯齿。尖锐的双三次曲线(b&#x3D;0, c&#x3D;1)特别容易产生锯齿伪影。 图19：缩小并放大到原始分辨率的调整器比较。所有内容都被缩小到源分辨率的一半，然后使用nnedi3_rpow2放大回去。所有参数都保留默认值。 图20：缩小并放大到原始分辨率的调整器比较。所有内容都被缩小到源分辨率的一半，然后用相同的调整器放大回去。所有参数都保留默认值。 图21：抖动类型的比较。输入源为8-bit视频，向上抖动并用 f3kdb 去色带，输出为16-bit，然后抖动至8-bit。 图22：一个说明为什么不适当的对角边界fx是个坏主意的例子。上面是源，下面是Geek使用边缘遮罩后的。来自Geek压制的《精灵旅社2》（Hotel Transylvania 2 (2015))。 图23：在16-bit（右)和8-bit（左)分别进行伽马修复(gamma bug fix)的比较 图24：不同**边缘遮罩(edgemask)**的比较。从左上角到右下角：source, Prewitt, Sobel, Kirsch, TCanny，和retinex_edgemask。所有设置都保留默认值。 图25：更精确的边缘遮罩(edgemask)的比较。从左上角到右下角：source, retinex_edgemask, Kirsch, Sobel。请注意，这是在质量极差且场景灯光昏暗的源上进行对比，因此 retinex_edgemask 和 Kirsch 两种遮罩的区别比常规情况更大。 图26：去色带时使用与不使用边缘遮罩(edgemask)的比较。从左上到右下分别是：源，源中裁剪区域标记，裁剪区域，裁剪区域上的遮罩（kgf.retinex_edgemask(src).std. binated(5000).std. maximum ().std.Inflate()），无蒙版去色带（f3kdb.Deband(y=90, grainy=32,grainc=16)），和蒙版去色带。通过平滑级别，伽马值提高了50%。 图27： 一个例子说明为什么简单的 亮度遮罩(luma mask) 往往是不够的。取自1080p的O2STK对《了不起的狐狸爸爸 》（Fantastic Mr. Fox (2009)）进行了编码。O2STK使用了 GradFun3 和一个亮度遮罩。 标记为 Masked 的截图是 f3kdb用RGB截图的简单Sobel遮罩。 图28：来自Geek的《Hotel Transylvania 2》压制作品：另一个例子说明了为什么在没有正确屏蔽的情况下，你应该始终警惕细节是否平滑甚至遭到破坏。虽然我们不能确定这里是否使用了遮罩，但这很可能是未使用遮罩的 f3kdb 的结果。 sunnighty似乎更常使用 GradFun3 蒙版，这在这个案例中可能有很大帮助。不知道这里发生了什么。但我猜测他们在蒙版遇到了非故意的情况从而产生了问题。 【译者注】本文翻译主要基于DeepL翻译器，在此基础上大量参考typing-more&#x2F;高清视频转码进阶指南.md，在此表示由衷感谢！ 部分名词解释借鉴 VCB-Studio、Encode Mystery，一并感谢！ 对翻译错误或不足的地方欢迎指正；翻译不易，若需转载请指明出处，谢谢配合！ ​ ——2021.12.27"},{"title":"压制基础教程（FXXS出品）","date":"2025-08-09T03:42:47.658Z","url":"/%E5%8E%8B%E5%88%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","categories":[["undefined",""]],"content":"源、编码、透明度对比源：源是指高质量可以用于进行压制编码的视频，一般包括蓝光圆盘、高质量的Web（一般4K的SDR）等。压片时应采用 最优质的源 进行压制，提高压制质量。 随着很多老片的BD推出，很多蓝光源是从低分辨率拉到高分辨率，被称为 Upscaled，在压制时应注意复原为原版的分辨率，不要压制过高的分辨率。关于WEB源应谨慎使用，尤其1080p的web-dl一般都为低质量不可以进行二次压制源，如非必要请勿压制，4k的SDR web源目前评价较好，往往好于1080p的BD来源，对于压制1080p的视频可以进行比较使用。 ！！！对于已经编码过的视频禁止二次编码！！！ (通常而言，二次编码违反选择最优质源进行压制的原则。) 编码：编码是指对于高质量来源进行压缩编码，进一步节约体积。编码过程种主要进行片源处理，修复源较为明显常见问题，通常包括脏边、色带、碎块、颜色偏差、伽马矫正等；切除黑边，去除源中16：9比例下的黑色边框；压制空间，主要将源采用更高的压缩方式进行重新编码，通常为有损方式。 透明度(Transparency)：透明度是评价源于编码之间的相似程度的指标。良好的透明度是指在有经验的编码人员下都不能较为明显区分压制作品与源之间的差距。(此条不适用于 Anime 环境，二次元压制组看法不尽相同) 这个概念在外站(指PT)会比较流行 “透明度”指的是编码输出与源视频的匹配程度。一个更“透明”的编码成品会看起来更接近原始视频，而透明度较低的成品则会有明显的压缩瑕疵（compression artifacts）和&#x2F;或失真。实现完美的透明度几乎是不可能的（尤其是在考虑到诸如抖动（dithering）之类的随机变量后）。编码的最终目标之一就是获得“透明”的编码成品，也就是尽可能地接近源视频。 一个“透明度”较高的视频通常意味着码率很高，通常高于源视频码率的50%。比较直观的说明是，当我觉高码给9000kbps(x265)的时候，外站压制给的20Mbps(x264)。 而对于我们组，我们并没有硬性要求，你可以基于透明度压制，也可以适当的控制码率。 根据I、P、B帧的功能，在编码过程中，编码器一般会尊重I帧内容，哪怕再劣质的压制，都不会对其进行明显的转换；而针对p帧，编码器可以转化为B帧进行编码节约空间，对于B帧进行重新编码。因此透明度应该从源与压制中P-&gt;B以及B-&gt;B的转换质量对比评判的压制质量。 码率：码率是视频质量的基石，在编码一样，参数不乱给的情况下，不存在任何魔法能做到低码吊打高码。大部分视频压制参数或压制脚本的调整主要是为了码率分配以及视觉上的优化。如果你的目标是学习魔法的话，再次提醒，不存在这种东西，也注意不要在这块浪费精力。如果你想学习压制，你需要做的是根据视频画面给到足够的码率。再再次提醒，如果你之前没接触过相关信息，那么请忘掉你现有的对压制的任何观点，因为大部分都是错的。 Bloating：称为臃肿，是指实现在相同透明度情况下，码率较高。根据压制较为广泛接受的规则，当压制作品太过接近源的码率也被认为 Bloating，数值如下表：(x265建议更小的比例) 1080p 720p 576p 480p 原盘码率比例 75% 50% x264 与 x265在获取比 VapourSynth 更容易找到的 x264 和 x265 编码器前，你也可以选择使用它们的修改版。 最主流 x264 的修改版是 tmod 。值得注意的改进包括 淡化补偿(fade-compensate) ，在 宏块树(mbtree) 开启的情况下对淡入淡出进行编码，以及更多的 自适应量化(aq-mode) 选项。而如果你希望在转码时更加精确地控制，毫无疑问你应该尝试使用 tmod 并捆绑使用它提供的aq-mode，这样你就能够从中榨取出更高的质量，从而在保护噪点的同时不至于破坏线条。 x265的优势在于它能够存储HDR信息，而且效率高得多，特别是类似低码率动漫这样的简单内容。 最主流的 x265 修改版则是 yukki ，相比 x264 的修改版它却没有那么让人印象深刻。所有这一切都包括一些外观上的变化，比如更准确的预计完成时间。 8-bit 与 10-bitx264 8-bit，x265 10-bit。对于x264，8-bit有更多的硬件兼容性（10-bit几乎没有），而且速度明显更快。然而，10-bit x264通常能够节省相当多的空间，同时仍然比x265快。此外，10-bit编码在保留梯度方面要好得多（也就是说，你不必担心色带再次出现），这使得它在编码无噪点内容（比如动漫）方面非常受欢迎。 参数x264参数(1080p)注意事项，level 4.1 不支持 1080p@60fps，，4.2 ptp 会提示 DXVA: Incompatible，这主要涉及一个早期设备的硬解兼容性问题，比较直观的解释就是 6年前的 firefly-rk3288 的开发板都支持 2160p@60fps 的 H264 硬解。 而 x265 吃了后出的红利，基本不用担心这块，不过也有逗逼不懂喜欢瞎设 level-idc,遇到这种的你知道他是菜逼就行了。 (crf可以用18)ref说明 480p ref&#x3D;16 576p ref&#x3D;14 720p ref&#x3D;9(-12) 1080p ref&#x3D;5 ref开太高的话，ptp会提示 DXVA: Incompatible 请注意ref的计算，分辨率切黑边会导致 ref 可设置值下降，留空会自动计算 ref计算方法(机翻)： 对于 --level 4.1，根据 H.264 标准，最大 DPB（解码图片缓冲区）大小为 12,288 千字节。由于每个帧都以 YV12 格式存储，即每像素 1.5 字节，因此 1920x1088 帧为1920 × 1088 × 1.5 &#x3D; 3133440 字节 &#x3D; 3060 千字节。12,288 ÷ 3060 千字节 &#x3D; 4.01568627，因此您最多可以使用 4 个参考帧。请记住，在进行计算时，将两个维度向上舍入为 mod16 值，即使您没有对 mod16 进行编码！让我们对 1920x800 进行计算。1920 × 800 × 1.5 &#x3D; 2304000 字节 &#x3D; 2250 千字节。12,288 ÷ 2250 千字节 &#x3D; 5.45777778，因此最多可 以使用 5 个参考帧。请注意，这些转换使用基数 2，1 千字节 &#x3D;&#x3D; 1024 字节。如果计算错误，也没关系 - 如果使用太多，x264 将显示警告，你会知道是否需要更改它。 x265 1080p 非HDR参数(仅供参考) x265的HDR参数(仅供参考,HDR参数需要计算，不能直接使用) 其中的HDR参数应根据源进行计算设置 压制环境构建全套软件打包(请联系相关人员获取) 便携版压制软件带集成环境  (私有，需要申请权限) VS集成环境(其他人维护，脚本可能不太全，ffms2等版本存在已知issue)  vapoursynth-classic 老版本维护(组内成员请勿使用) 压制软件 通常建议及时更新工具版本。 编码器使用压制工具大部分核心都是x264和x265(x265如无必要不在重复)。本人推荐压制软件功能越为简单越好，比如适合新手的Simple x264&#x2F;x265 Launcher或纯命令行（CLI）。Simple x264&#x2F;x265 Launcher下载安装即可使用，本教程将以此为基础进行讲解。工具需要简单的设置，推荐log文件保存等设置，根据个人习惯修改。 VapourSynth官方文档 VapourSynth是基于python编写新一代的视频处理工具，解决了许多AVS遗留的问题，显著提高了运行速度。 Python : 安装VS之前必须装好Python环境，不同VS版本要求的Python版本不同，下载安装前请先看好所需要的Python版本。安装时候必须选择 Add Python to PATH !! VapourSynth : VapourSynth的主体安装程序，安装过程推荐安装所有推荐内容。除了安装位置外推荐使用默认设置。安装完后只包括主程序，以及官方的自带的插件，VS使用过程需要大量的插件以及脚本：主要分为 Script(.py)脚本 和 Plugins(.dll)插件 两个部分。安装插件脚本，需要将对应文件放入对应目录，目录在官方文档内有详细介绍。在Windows下官方提供了方便的下载管理。下文对于使用到部分将会介绍。 请注意脚本主要是 Python 环境，Python 版本兼容，通过 import 加载，而dll加载与VS本身，是需要考虑系统兼容，通过 core.XXX 加载，很多插件没有 Release Linux 版本，所以 Linux 环境可能会有部分插件需要自己想办法编译或者没法编译。 口语环境里，很多人会把脚本也叫成插件，但自己注意区分，以免造成混淆 VS 最新提供了制作便携版的脚本，但需要注意，升级会需要一些手动操作，如 python 的 vs 包无法卸载。如果是个人使用搭建，建议用安装包 VapourSynth 文档中列出了放置插件的路径。 Windows 的推荐路径&lt;AppData&gt;\\VapourSynth\\plugins32 或 &lt;AppData&gt;\\VapourSynth\\plugins64。Unix 用户可以创建一个配置文件来指定路径。 VapourSynth的Python脚本应该放在你的Python site-packages文件夹中。在 Arch Linux上，位于 /usr/lib64/Python3.*/sitepackages/。Windows 用户可以在本地AppData文件夹【译者注：即C:\\Users\\&lt;用户名&gt;\\AppData\\Local】中找到这个文件夹。 需要注意的是 Python 自身也会有个 site-packages 文件夹，注意不要放错位置或者混放，可能会造成不知道加载了什么东西的问题 VSRepoGUI ：官方提供了方便的下载管理插件以及脚本的GUI界面，下载解压后点开后即可使用，推荐放在VS的安装目录内。 通过软件可以查看对应的VS安装信息和脚本插件的所在位置，同时可以实现对插件的脚本安装、更新和卸载，软件插件安装位置，再右上角可以快速点开。在Windows下推荐本软件进行维护插件和脚本。 VapourSynth 编辑器 VapourSynth Editor 推荐用YomikoR的mod版本 Yuuno VapourSynth Preview AvsPmod(长期不更新) VapourSynth Editor ：VS Editor是目前较为广泛使用的VS编辑器(目前会使用Mod版本)。下载后，直接解压即可使用。第一次使用时候，需要配置VapourSynth文件的位置。VS plugins paths 可以是用VSRepoGUI中的路径进行查看。 Yuuno 是 Jupyter 记事本的一个扩展，允许你编辑和导出 VapourSynth 脚本。你可以通过以下代码来安装。 注意你需要安装 Jupyter 或 Jupyter Lab。 VapourSynth Preview 需要一个单独的文本编辑器或 IDE 来编写脚本，这使得它对那些不喜欢 VSEdit 中内置编辑器的人来说非常有用。AvsPmod是用于 AviSynth 的编辑器，但它也支持 VapourSynth。 它们都有各自的优点和缺点，但对于新手来说，我更推荐 VSEdit 进行本地编辑，而希望在服务器上也能够写脚本的用户，更推荐 Yuuno。这是因为 Jupyter 只需要少量配置就可以远程使用。建议 Yuuno 用户试试使用 Jupyter Lab 替代 Jupyter。 此处举例两者最大的差别： VSEdit 不需要保持浏览器开启 内置基准和编码工具 通过CTRL + SHIFT + 方向键轻松浏览视频 更稳定 几乎无需二次开发 大多数PT用户在使用它，因此它可能更容易获得帮助与支持 VapourSynth 特有的语法高亮及输入建议 允许你存储片段和模板 Yuuno 非常易于远程使用 可以通过 iPython magic 轻松导出 更好的比较工具，通过使用%%vspreview clipa --diff clipb ⇒ 实现鼠标悬停即可预览更改效果 程序不太成熟，因此更可能发生崩溃 允许你在一个 Jupyter 编辑器中处理和导出多个脚本 常用其他软件 Mediainfo :媒体信息检查软件，查看片源以及压制信息使用。 MKVToolNix: mkv混流软件，也能实现以下基本的视频分割。 SubtitleEdit: 字幕编辑软，可以实现ORC等功能。 DGDemux: Demux 软件，目前作为默认标准的Demux软件 eac3to: 存在已知Issue音轨转码编辑软件，也可实现Demux等功能。推荐使用eac3to with UsEac3to版本，并应包含一些对应的其他转换格式插件。 BDinfo: 蓝光原盘信息检测分析软件。 VLC: 能播放蓝光菜单，辅助确认音轨字幕章节信息 其他请参考 软件列表 基础部分软件直接使用或者安装即可。AVS和VS为两种方向，推荐选VS AVS相关教程Archive 压制步骤压制源分析要想做一个较为高质量作品，应采用最好的来源进行压制。HDR电影来源较为单一，4k的原盘和Remux资源为主，版本较少能选择不多。SDR目前可用压制版本较多，各个发行商的在不同时期也发行过不同蓝光版本，随着web的兴起，AZ和NF也都发布了较高码率的4k的sdr版本，所以在SDR压制时，需要对于来源进行对比，选取最为高质量的来源进行压制。对于蓝光原盘与remux两者相同时候，推荐使用Remux的更为方便。 对于原盘使用 BDInfo 检查原盘信息，查看原盘主要视频对应播放列表。对于复杂原盘，可能出现多版本混合的情况，需要确定所需要版本对应的MPLS，并确定原盘的主要码率 。在压制前推荐进行分离提取(Demux)后再进行压制。 分离提取(Demux)与音频转换见Demux&amp;Remux以及Audio 输入脚本编写压制前一般需要对片源就行处理，一般包括去除黑边、修复脏边脏线、去除片源的一些问题等，并且在压制时一般需要进行部分压制测试，也需使用脚本进行实现。本节将对介绍压制中的最基本脚本的编写，分为VS和AVS两个部分。编写脚本使用对应的编辑器较为方便。以及基础例子如下 AVS例子 VS例子 Tips： 1.修复脏边脏线以及去色带等属于进阶部分，将单独介绍 VS由C++编写的核心库和允许创建视频脚本的Python模块组成,脚本部分作为Python模块实现，因此脚本完全使用Python语法 看这里以便于理解vpy写法以及含义 Python 文档 VS文档 其中最前面的 就是 python 的 模块&#x2F;modules 的 导入&#x2F;import 片源载入(Index a video)载入片源需要使用对应的解码器 可用的索引器可供考虑 bestsource最准确但最慢的索引器。 lsmas速度快，基本可靠。 ffms2最新版本与 lsmas 相当，甚至可能更快。 DGIndexNV 在技术上也是您可以使用的，但最新版本存在错误，并且仅限于 Nvidia GPU。 AVS语法 VS语法 Tips: 1.右键可以直接选择插入文件完整路径。 2.首次执行载入预览会卡死，需要等待一定时间。 切除边缘avs语法 VS语法 Tips: 1.Crop切割方式只能以偶数方式切割，奇数切割属于进阶内容 2.切割奇数边需要使用下节介绍的resize方法 变换大小AVS语法 VS语法 抽取测试压制前使用脚本一般间断抽取共约5k~10K帧进行参数测试，需要在脚本进行抽取。 AVS语法 VS语法 压制测试在压制前应该进行参数测试，以便获取较高的压制质量，一般需要确定合理码率大小(crf)以及对于码率分配参数(ap-mode、ap-s、qcomp)以及psy等重要参数进行测试。使用抽取测试代码，大约抽取6k帧进行参数测试，送入Simple-x264进行测试。 压制参数配置使用Simple进行压制，其设置如下所示。在设置界面记得开始log自动保存！！！ CRF测试CRF测试主要确定合适码率，根据压制目标，确定合理的码率。推荐测试起始CRF为17，根据范围码率以0.5步进进行CRF测试。 合理码率评判方式追求体积压制效果受码率影响很大，在追求体积时，很容易造成欠码的问题。所以要设置合理的码率范围，防止出现因为码率不足导致的质量问题。需要主要检查需要码率较高的场景，例如，复杂的场景和暗的场景。 主要辨别问题有： 是否新产生了新的block 复杂的场景的细节是否丢失 是否压出明显的色带 保证与原盘相似透明度前景无损失，背景没有明显损失 其他参数 本部分十分建议进行，但是对于一些压制组不是强制要求。可以编写脚本进行批量测试 确定合理的码率后，切换2-pass方式使用预计码率，采用单一变量方式进行参数测试，每次测试只改变一个参数，每个参数推荐测试范围如下： 参数 真人类型 步进 qcomp 最终CRF测试在新参数下，进行最终使用的crf测试。 压制对比脚本编写avs语法 VS语法 下面的代码大部分已经不能在最新的VS里使用，仅作参考，请使用 awf 以及 Scrips 里的 snap 正式压制将压制脚本中的测试抽帧代码注释掉，进行正式压制。 清晰度越高需要的时间越长，推荐使用较低的分辨率入门 封装封装是将所有素材合成一个mkv的视频文件，封装是一个很简单的工作，没有技术难点，但是封装的好坏会对压制作品评价很为重要，封装主要是认真。这里主要介绍被广泛接受的封装细节，不同压制组对这个有具体的细节要求。 一般封装主要注意以及下内容： 视频、音轨和字幕是否匹配 音轨和字幕是否设置了正确的语言标签 需要标准命名的音轨是否正确 章节信息和标题是否添加并正确命名 正确命名文件标题 文件标题并不是文件名！！！一般主要为IMDB的英文标题并可以添加小组信息 "},{"title":"AV1","date":"2025-08-05T07:57:16.180Z","url":"/2.Tools/AV1/","tags":[["建设中","/tags/%E5%BB%BA%E8%AE%BE%E4%B8%AD/"],["Notes","/tags/Notes/"]],"categories":[["2.Tools","/categories/2-Tools/"]],"content":"鉴于 AV1 最初是为网络应用而设计的编解码器，它的优势不在于实现（完美的）透明度，而在于生成视觉上悦目的编码成品——即在文件体积很小的情况下，只有最轻微的可感知瑕疵。 by JET 以下都是笔记 大部分基于原版的参数都是预设就好，一般只要 preset 就行，似乎 preset 4 的效果比 preset 2 要好，速度还快。 --preset 2 是（在推荐范围内）最慢的预设，它以极小的速度损失换来了出色的效率提升。使用比 2 更慢的预设被认为是进入了“安慰剂”领域（即收效甚微），并且还有人担心更慢的预设会导致画面更模糊。 --preset 4 的速度则明显更快，而且有报告称其最终成品的保真度比预设 2 更高。它通常被认为是效速比（效率与速度的权衡）更佳的选择。最好的做法是，用你自己的常用内容来对这两种预设进行测试（理想情况下使用小的测试样本），然后决定你更偏好哪一个。 --preset 3 则处在 2 和 4 之间一个颇为尴尬的中间位置，没有什么特别的理由能让人放弃另外两者而选择它。顺便一提，预设 5 及以上更适用于实时应用场景，因此不在本文的讨论范围之内。by JET 胶片颗粒合成(FGS) 大量噪点的片可以开 --film-grain 14 ，效果比 8 要好，8的话会遗留很多横纹，而14的情况下，虽然画面很多噪点没了，但细节保留的更好一些，见下妻物语压制。 内置的的颗粒合成功能有集成的降噪步骤 (--film-grain-denoise)，但效果很糟糕，所以最好让它保持禁用状态（这也是默认设置）。 即使在无需考虑保留颗粒的情况下（例如，处理比较干净的源视频时），我们仍然强烈推荐使用 FGS，因为它能带来强制抖动（forced dithering）的好处。您可能很熟悉，x26x 系列编码器在高 CRF 值下往往会导致色彩渐变（gradients）效果不佳（甚至产生色带）。在 AV1 编码中，通过使用 400 或更高的光子噪声 ISO，或者 4 或更高的胶片颗粒强度，您可以在一定程度上避免这个问题。较低的设置值并不能稳定地解决这类抖动问题。by JET svt-av1的 evb 效果不错，--enable-variance-boost 1 --variance-boost-strength 3 --variance-octile 4,但目前感觉同码率透明度是不如 x265 和 x264。(似乎--variance-octile不建议修改) JET中说的，还未进行测试 --tile-columns 1 --tile-rows 0: at 1080p and above.--tile-columns 2 --tile-rows 0: at 4K and above. 如果您的源视频采用 PQ 传输特性，请记得去掉 --luminance-qp-bias 25 这个参数。 "},{"title":"KNLMeansCL 在使用 Intel 比较新的核显驱动下有问题","date":"2025-07-24T03:32:24.420Z","url":"/2.Tools/KNLMeansCL_Issue/","tags":[["Plugins&Scripts","/tags/Plugins-Scripts/"]],"categories":[["2.Tools","/categories/2-Tools/"]],"content":"好像是从 2024年9月13号 开始的驱动(32.0.101.6078)都有问题，具体版本并不确定。但 2025 到现在的驱动似乎都有问题。 最后换到了 Intel-UHD-Graphics-Driver_83MGG_WIN64_31.0.101.4502_A00(2023年10月8号) 才解决。 intel 12代 - 14代 的核显都是 Intel(R) UHD Graphics 770，驱动都是同样的。但是 intel 官方没再提供老驱动了，我是戴尔官网下载的。 但是注意 2024 2025 有很多 CVE 哈。使用有风险  Update 测试 U7 的核显没有问题(但是这个 CPU SVT-AV1 会崩溃)，原因不明 BTW 11 代开始的驱动程序都是同一个更新包。"},{"title":"Language tag 列表","date":"2025-04-23T06:22:31.797Z","url":"/6.etc/Language_tag/","categories":[["6.etc","/categories/6-etc/"]],"content":"Windows 给出的  下面那个有 pdf 可以下载，也就是上面那个文档下载下来 Israel Science"},{"title":"QTGMC 去交错","date":"2025-04-11T01:53:39.434Z","url":"/2.Tools/QTGMC/","tags":[["建设中","/tags/%E5%BB%BA%E8%AE%BE%E4%B8%AD/"],["Plugins&Scripts","/tags/Plugins-Scripts/"]],"categories":[["2.Tools","/categories/2-Tools/"]],"content":"翻译自 avisynth 文档 基础大多数用户仅需使用预设选项。&quot;预设&quot;功能会为指定编码速度选择合理配置。可选预设包括： &quot;Placebo&quot;（实验性） • &quot;Very Slow&quot;（极慢） • &quot;Slower&quot;（较慢） • &quot;Slow&quot;（慢速） • &quot;Medium&quot;（中等） • &quot;Fast&quot;（快速） • &quot;Faster&quot;（更快） • &quot;Very Fast&quot;（极快） • &quot;Super Fast&quot;（超快） • &quot;Ultra Fast&quot;（终极速） • &quot;Draft&quot;（草稿）默认预设为&quot;Slower&quot;（较慢）。请勿盲目追求最慢设置，其画质提升可能微乎其微却需耗费大量时间。特别提示：高清素材使用极端设置效果提升有限。高清（HD）素材的处理速度比标清（SD）慢6到8倍。 核心参数设置要点提示：最实用的参数是TR2，用于控制输出画面的平滑度。 TR0 (1,2) 用于生成运动搜索画面的时间二项式平滑半径。通常：2&#x3D;画质优先，1&#x3D;速度优先 TR1 (1,2) 对插值生成的初始输出画面应用的时间二项式平滑半径。通常：2&#x3D;画质优先，1&#x3D;速度优先 TR2 (0,1,2,3) 用于最终画面稳定&#x2F;降噪的时间线性平滑半径。数值越高，输出画面越平滑 Rep0 (int) 修复运动搜索画面（0&#x3D;关闭）：修正因TR0时间平滑导致的非预期模糊 Rep1 (int) 修复初始输出画面（0&#x3D;关闭）：修正因TR1时间平滑导致的非预期模糊 Rep2 (int) 修复最终输出画面（0&#x3D;关闭）：修正因TR2时间平滑导致的非预期模糊（若未启用Rep1，也会修复TR1导致的模糊） RepChroma (bool) 修复模式是否影响色度。默认值：True（启用） RepX语法说明： 第一位数字（0-5）：控制可消除的细密闪烁线条的最大宽度（1像素至约3像素） 第二位数字（0-3）：控制在检测到的线条边缘略微恢复细节 若仅输入单数字，则视为第一位数字（例如 &quot;5&quot; 等同于 &quot;50&quot;） 算法原理详解核心流程： 对源素材片段进行 Bob 处理(场分离)。对 Bob 处理(场分离)后的结果进行时域平滑以消除闪烁 (shimmer)，然后分析其运动。 更精确地对源素材片段进行插值（例如使用 NNEDI3）。利用上一步的运动分析结果，通过运动补偿对这个插值结果进行时域平滑处理。这样可以在保留细节的同时消除闪烁。对结果进行重新锐化以抵消可能产生的模糊。 最后进行一次轻度的时域平滑，以优化最终效果（在视频处理语境下，通常指去除残留的噪点、瑕疵或不稳定因素，使画面更纯净。） 阶段说明： 阶段0 &amp; 1：使用二项式平滑（类高斯分布）消除去隔行闪烁，对应参数TR0（运动分析阶段）和TR1（初始输出阶段） 阶段2：使用线性平滑进行最终优化，对应参数TR2 技术要点： TR0&#x2F;TR1建议≥1以确保消闪效果，TR0&#x3D;2可提升运动匹配精度 TR1&#x2F;TR2值越大画面越稳定且降噪更强，但会牺牲细节并可能加剧运动分析错误导致的伪影 锐化参数可部分补偿平滑导致的模糊 消闪原理算法专攻&quot;场分离闪烁&quot;（隔行信号插值产生的水平线闪烁）。修复模块Rep0&#x2F;Rep1&#x2F;Rep2通过只允许水平方向的修正变化，有效防止时间平滑导致的运动模糊。 运动分析参数要点提示：预设已优化参数组合，非必要请勿修改。调整前请详阅MVTools2文档 参数 取值范围 说明 SrchClipPP 0-3 运动搜索画面预过滤：0&#x3D;无，1&#x3D;简易模糊，2&#x3D;高斯模糊，3&#x3D;高斯模糊+边缘柔化 SubPel 1&#x2F;2&#x2F;4 运动分析亚像素精度：1&#x3D;整像素，2&#x3D;1&#x2F;2像素，4&#x3D;1&#x2F;4像素 SubPelInterp 0-2 亚像素插值算法：0&#x3D;双线性（柔化），1&#x3D;双立方（锐利），2&#x3D;维纳（极锐） Blocksize 4-32 运动匹配块尺寸 Overlap 0-块尺寸&#x2F;2 运动分析块重叠量（提升块边缘平滑度但增加计算量） Search 0-5 运动匹配搜索算法（详见MVTools2文档） PelSearch - 最细亚像素层级的搜索参数 ChromaMotion bool 是否分析色度运动（关闭可提速但可能误判） Lambda 0+ 运动矢量场一致性系数（需按公式缩放） LSAD 0+ 复杂运动区域降低一致性需求参数 PNew 0+ 新运动矢量选择惩罚系数 GlobalMotion bool 是否估计全局（摄像机）运动辅助分析 默认参数组合： TrueMotion&#x3D;false时：Lambda&#x3D;(1000*块尺寸²)&#x2F;64, LSAD&#x3D;400, PNew&#x3D;25 TrueMotion&#x3D;true时：Lambda&#x3D;(100*块尺寸²)&#x2F;64, LSAD&#x3D;1200, PNew&#x3D;50 插值参数要点提示：预设已优化插值方案，推荐使用NNEDI3系算法 参数 说明 EdiMode 插值算法：可选NNEDI3（推荐）、EEDI3、Yadif等 NNSize NNEDI3预测区域尺寸（非线性质级关系，详见NNEDI3文档） NNeurons NNEDI神经元数量（0-4，值越大质量越优） EdiMaxD EEDI系算法的空间搜索距离 EdiThreads 多线程数（0&#x3D;自动&#x3D;逻辑处理器数） 示例配置： 锐化参数要点提示：建议始终根据实际效果调整Sharpness参数（默认1.0偏锐，使用源匹配时默认0.2） 参数 说明 Sharpness 锐化强度（0.0为原始画面） SLMode 锐化限制模式：0&#x3D;关闭，[1&#x2F;3&#x3D;空间限制]，[2&#x2F;4&#x3D;时间限制] SLRad 限制半径（时间模式仅支持0&#x2F;1&#x2F;3） SOvs 时间限制模式下允许的过冲量（微量过锐化许可） SVThin 单像素线细化强度（修复插值导致的线条膨胀） 技术细节： 时间限制模式（SLMode&#x3D;2&#x2F;4）防过锐效果更强但更吃性能 后期限制模式（SLMode&#x3D;3&#x2F;4）可保留更多锐度但可能产生伪影 Sbb参数可混合锐化前后画面提升细节保真度 源匹配 &#x2F; 无损 (Source Match &#x2F; Lossless)注意：此功能的效果既微妙又精确，仅用于追求极致细节。请先确保您能够分辨出这些极致的细节。 核心要点 (Key Points): 源匹配 (Source-match) 通过额外的处理来创建保真度更高的输出。 通过设置 SourceMatch &#x3D; 1, 2 或 3 来启用。数值越高，速度越慢，但精度也越高。 可与 无损 (Lossless) 设置（尤其是 Lossless&#x3D;2）结合使用，以获取更多细节。 使用 MatchPreset（类似于 Preset）来调整速度。 该功能会保留源中的瑕疵 (artefacts)，因此最适合用于高质量的源素材。 默认情况下，Sharpness（锐度）会变为 0.2，且锐度限制 (SLMode) 会被关闭，因此请谨慎调整锐度。 快速入门 (Quickstart): 以下模板的质量依次提高，但处理速度也依次变慢。请根据需要选择预设，但请注意，那些处理速度非常快的预设并不适合（与此功能搭配使用）。默认 Sharpness 为 0.2，但您可能希望稍微将其调高。 对于干净的源素材，设置 TR2&#x3D;1。 如果需要更强的降噪效果，设置 TR2&#x3D;2 或 TR2&#x3D;3（速度更慢），或者使用（其他的）噪点处理功能。"},{"title":"软件列表","date":"2025-04-08T14:35:16.276Z","url":"/2.Tools/Collection/","categories":[["2.Tools","/categories/2-Tools/"]],"content":"A collection of Encode tools and scripts. Codec Name Description Document x264 x264 codec x264-tMod x264 t_mod codec(默认使用) x265 x265 codec Doc x265-Yuuki x265-Yuuki 长期未更新 x265-Mod-by-Patman x265 codec SVT-AV1 AV1 codec Doc AOM-AV1 AV1 codec vvenc VVC codec ffmpeg Web Only, Contain SVT-AV1(not the newest code)Win(BtbN); Win(GyanD) Web Github Doc qaac 是基于 Apple 编码器的命令行 AAC&#x2F;ALAC 编码器前端。开源 Wiki flac exe较少使用，通常用的是lib Doc opus 2019年发布最后一版 1.3.1 Doc eac3to&amp;UsEac3to(GUI) UsEac3to GUI 作者:tebasuna51eac3to 作者:madshi (老版本) 新版本 Wiki VS etc其他的可以参考下 Readme 里的大佬们的仓库 Name Description etc VS Official Web \\ VS Github VS Doc VapourSynth Editor Modified by YomikoR 原版长期未更新，并且存在一些不足,故只放mod版 VapourSynth Editor 2 Untest vapoursynth-classic Untest，旨在维护旧版API的一个版本 tool-pack Untest，类似Mediatool的一个项目，不过我一直好奇里面打包了GPL的东西能不能这么发布 Other Tool Name Description etc OKEGui Untest，平时习惯先封装一个，然后通过样板json批量生成再用mkvmerge命令行批量封装 VSGUI Untest，类似于MEGUI的VS版本 Subtitle Name Description etc subtitleedit 支持ass转srt Aegisub Aegisub 在 ass 方面会比较专业 有很多其他版本，没再维护被移除 subtitle_tonemap adjust brightness to PGS subtitle sushi automatic shifter based audio stream ttml2srt convert ttml to srt YTSubConverter convert ytt to ass(or reverse) vtt2ass convert vtt to ass srt2ass convert srt to ass Subrenamer Rename subtitles for BDRip SubRenamer 番剧字幕文件自动化一键批量重命名（改名）工具 Dolby Name Description mlp Dovi TrueHD demuxer deew DDP maker mp4dovi Dovi in mp4 files Scripts Name Description EasyCompare compare snapshot Chapter Name Description ChapterTool chapter create tool chapter_converter convert chapter file formats Player Name Description mpv-config mpv pack Hevc Video Extensions From Device Manufacturer hevc extension for Windows Dolby Vision Extensions dovi extension for Windows "},{"title":"Demux & Remux 操作","date":"2025-03-31T13:59:00.133Z","url":"/2.Tools/Demux&Remux/","categories":[["2.Tools","/categories/2-Tools/"]],"content":"通常建议在 Demux &amp; Remux 之前进行扫盘，mkvtoolnix 以及 dgdemux 都可以进行。 主要判断信息有 是否是肉酱盘 是否默认的 mpls 是正确的影片（有些盘会坑人） mpls 是否包含了无效的mt2s(这种会导致操作失败)，这种情况，需要 dgdemux,然后勾选 &quot;skip first&#x2F;last M2TS&quot; 部分剧集原盘 dgdemux 需要开启 &quot;strict playlist times&quot; mkvtoolnix 可以自动处理，useac3to 等其他软件会产生包含长时间黑屏的文件出来。(m2ts本身包含，mlps中做了切割处理) Demux作为音轨处理的前置步骤(部分原盘只有DGDemux能正常处理)，目前获取的信息是再TrueHD方面 MakeMKV &gt;&#x3D; 1.15.4 &#x3D; mlp &gt; DGDemux (具体见 mlp 的 Readme)。 或许考虑使用mlp来专门处理肉酱TrueHD盘 一些肉酱盘 mkvtoolnix,eac3to,会有 glitching 的问题见issue(并不确认eac3to最新版是否解决了问题)。 目前发现肉酱盘的PCM也会出问题，ffmpeg报&#39; Invalid PCM packet, data has size 2 but at least a size of 4 was expected&#39;，使用 Dgdemux 之后正常转换 一些 mpls 会作为 m2ts 的 index,m2ts 本身前后会包含一些 garbage，见issue,目前 DGDemux 可以通过勾选 &#39;strict playlist&#39; 来正确处理。 mkvtoolnix也会进行处理，但音轨出现了一些问题。 mkvtoolnix 本身有切割和合并功能，但这一块有问题，并且不会修复(mkvmerge can only cut in front of key frames. That&#39;s an intentional limitation, not a bug.)，Issue in codeberg 故有切割合并需求还是使用 ffmpeg(命令行) DVD对于DVD，你可能需要使用MakeMKV，目前的其他软件对DVD都支持不太好，例如mkvtoolnix认不到章节以及字幕轨 常见的Demux软件有 UsEac3to&#x2F;eac3to DGDemux(现在作为默认的标准软件) tsMuxer FFmpeg gMKVExtractGUI&#x2F;mkvextract 其中UsEac3to功能非常多，内含了转码功能，但其长期未更新，在部分音轨上可能出现问题。 其中eac3to可以检测到坏帧并进行输出，故可以用来判断原盘是否有问题 前3者支持BD&#x2F;mpls的demux(你可以选用现成的Remux来避免原盘带来的各种问题),不过DGDemux支持原盘，tsMuxer的mkv很多轨道都不认后3者开源免费多平台(有Linux版本) DGDemux有Linux版本，不过没有GUI tsMuxer拆出的turehd是包含ac3核心的，FFmpeg不认(不能拿来制作DDP) 选择正确的mpls不像二次元原盘可能一个m2ts就一集，乱七八糟的原盘mpls可能发生各种情况。建议关注下以及观察加载 m2ts 的规律。 一般可以看获取原盘处的BDinfo。 还有个比较便捷的办法,就是stream里看最大的m2ts，记住名字，然后通过文本编辑器打开mpls看这个m2ts出现在哪。(不过在有DGDemux的情况下，直接在里面看就好了) mkvextract一般建议用GUI,除非你用Linux Examples mkvextract inpu.mkv tracks 1:audio.thd(需要自己确定轨道ID以及后缀) Extracting both chapters and tags in their respective XML formats at the same time: mkvextract movie.mkv chapters movie-chapters.xml tags movie-tags.xml Extracting a couple of tracks and their respective timestamps at the same time: Extracting chapters in the Ogg&#x2F;OGM format and re-encoding a text subtitle track to another character set: mkvextract &quot;My Movie.mkv&quot; chapters --simple &quot;My Chapters.txt&quot; tracks -c MS-ANSI &quot;2:My Subtitles.srt&quot; 关于字幕的一些范例 FFmpeg如无必要，不建议使用，需要自己判断音轨深度，默认是拆16bit 其他见FFmpeg"},{"title":"x265 HDR 参数计算方法","date":"2025-01-13T00:25:31.208Z","url":"/3.Code/x265%20HDR%20%E5%8F%82%E6%95%B0%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","categories":[["3.Code","/categories/3-Code/"]],"content":"HDR 压制参数为 --master-display &quot;G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(10000000,1)&quot; --max-cll=1000,400 首先，不同的色彩空间有不同的G B R WP 数据 通常，不同的片会有不同的L 数据 以及 max-cll Mediainfo范例 BT.2020 Olympus Has Fallen 2013 Display P3 会比较多 G B R WP 数据看Mediainfo里的Mastering display color pri Venom 2018 movie mediainfo : In this case master-display&#x3D;G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(40000000,50) and max-cll&#x3D;3903,1076 About Maximum Content Light Level and Maximum Frame-Average Light Level ... If those not present -&gt; max-cll&#x3D;0,0 测试用临时Code 前置参数 --level-idc 5.1 --ctu 64 --rd 4 --subme 7 --ref 6 --me 3 --qg-size 8 --weightb --no-rect --no-amp --rskip 0 --aud --range limited --repeat-headers --tu-intra-depth 4 --tu-inter-depth 4 --range limited --no-open-gop --no-sao --no-early-skip --min-keyint=1 --rc-lookahead 100 --no-cutree --bframes 16 --vbv-bufsize 160000 --vbv-maxrate 160000 --colorprim bt709 --transfer bt709 --colormatrix bt709 --deblock -3:-3 --no-strong-intra-smoothing --ipratio 1.3 --pbratio 1.2 --qcomp 0.65 --hevc-aq --aq-strength 1 --psy-rd 1.00 --psy-rdoq 1.00 --hist-scenecut --cbqpoffs -2 --crqpoffs -2 --hrd --hdr-opt --colorprim bt2020 --colormatrix bt2020nc --transfer smpte2084 --chromaloc 2 DoVi P8压制 请注意你可能需要自己修改RPU的路径 var refresh = function () { document.getElementById(\"result\").textContent = document.getElementById('x265').textContent; var mediainfo = document.getElementById(\"HDR\").value.replaceAll(\"\\\\\\\"\", \"|\").replaceAll(\"\\\\\", \"|\"); if (mediainfo) { var whole = JSON.parse(mediainfo); var track = whole.media.track; var hevc = track.filter(function (video) { return video[\"@type\"] === \"Video\"; })[0]; if (hevc.MasteringDisplay_ColorPrimaries == \"Display P3\") document.getElementById(\"result\").textContent += '--master-display \"G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)'; else if (hevc.MasteringDisplay_ColorPrimaries == \"BT.2020\") document.getElementById(\"result\").textContent += '--master-display \"G(8500,39850)B(6550,2300)R(35400,14600)WP(15635,16450)'; var Luminance = hevc.MasteringDisplay_Luminance.replaceAll( \" cd/m2\", \"\" ).match(/\\d\\.?\\d*/g); var max = Luminance[1] * 10000, min = Luminance[0] * 10000; document.getElementById(\"result\").textContent += \"L(\" + max + \",\" + min + ')\"'; if (hevc.MaxCLL) document.getElementById(\"result\").textContent += \" --max-cll=\" + hevc.MaxCLL.replace(\" cd/m2\", \"\") + \",\" + hevc.MaxFALL.replace(\" cd/m2\", \"\"); if (document.getElementById('DoVi').checked) document.getElementById(\"result\").textContent += \" --dolby-vision-profile 8.1 --dolby-vision-rpu \\\"RPU.bin\\\"\"; } }; refresh(); "},{"title":"Rules","date":"2025-01-11T07:17:28.909Z","url":"/5.Upload/Rules/","categories":[["undefined",""]],"content":"该规则只对MNHD，mUHD生效，对于个人组xxx@tag，可以有自己的写法，但强烈建议统一标准风格。 目前还是笔记状态 音轨 1.0&#x2F;2.0统一使用FLAC(除非源为有损)，如原始音轨为24bit,码率较高，可以转换为16bit使用，不得使用有损编码。(主要有损编码经常给过高码率，AC3也只有16bit，DD2.0 640k很多都比无损码率还高) 1080p当音轨为多声道时，应使用DDP，除演唱会（或类似性质）以外，不得使用无损音轨（有需要的人让他去收原版原盘） 最好开始淘汰DD&#x2F;AC3 命名规则 统一规则 统一大小写 标题以及副标题应该尽可能的包含所有变种称呼（以豆瓣为准），标题如超长可略去港台译名。 转载可使用来源文件名标准作为副标题，不用参考下列规则，尊重原始发布者的规则，但如有重大错误，需重命名发布 不可出现全角字符，不可出现ASCII以外的字符，除&quot;.&quot;以外的其他标点符号以及特殊符号不可出现 对于&quot;&amp;&quot;,请写成and，然后标题里写带&quot;&amp;&quot;的名字作为搜索命中补充，如&quot;Kapoor &amp; Sons 2006&quot;应写为&quot;Kapoor and Sons 2006&quot;,标题里写&quot;【卡普尔和儿子们&#x2F;Kapoor &amp; Sons&#x2F;卡普尔和他的孩子们】&quot;(不过由于实际测试中豆瓣自动带出&quot;【卡普尔家的儿子们&#x2F;Kapoor &amp; Sons - Since 1921&#x2F;卡普尔和他的孩子们&#x2F;卡普尔和儿子们】&quot;,所以不用特别处理) 除&quot;-&quot;外，其他标点和空格一起替换写为&quot;.&quot;，如&quot;Open Season 4: Scared Silly 2016&quot;写为&quot;Open.Season.4.Scared.Silly.2015&quot;,&quot;Yu-Gi-Oh!: The Dark Side of Dimensions 2016&quot;写为&quot;Yu-Gi-Oh.The.Dark.Side.of.Dimensions.2016&quot; 英文名应尽量与IMDb保持一致(除去包含符号)，对于欧洲其他非英文国家的电影，不可只使用源语言名称命名，可带上源语言名称 AKA 英文名，可以参考皮，如 La nuit américaine AKA Day for Night 1973 对于有多个英文名的，只保留IMDb使用的即可，其他应出现在标题中 对于日韩电影，IMDb里使用罗马音或者韩文拼音(?)作为标题的，必须使用源语言名称 AKA 英文名 如Ah-ga-ssi AKA The Handmaiden 2016、Tegami AKA The Letters 2006 对于日韩电影，如IMDb使用了英文名，则只使用IMDb英文名即可，源语言名称以及罗马音等应该都全部出现在标题和副标题中，以源语言为主，日文不要繁转简（除非豆瓣有，这种情况下应该两种都写），如冰果/冰菓/氷菓 对于豆瓣没有的，可以参考TMDB 年代以IMDb为准 DDP&#x2F;DD+统一为DDP，音轨声道连写，中间不要有空格，DDP7.1（&quot;+&quot;作为运算符可能会有奇妙的化学反应，故DDP较好） 音轨名只有DD5.1可以省略，FLAC1.0&#x2F;2.0可以省略声道，Atmos 和 DTS-X可以省略声道 标题【名称一&#x2F;名称二】后面可以随便写 （包含国粤音轨应该标注，不包含中字应该标注） （&quot;&#x2F;&quot;的前后不应该包含空格） 副标题副标题应尽量与文件名除&quot;.&quot;外保持一致(但可以增加AKA)，标题不可带&quot;.&quot; 文件名文件名必须将所有空格转换为&quot;.&quot; Movie x265压制必须为10bit，但由于以前有一些8bit压制，目前要求写上，以后Trump完所有8bit压制后可以省略，带HDR的现可以省略10bit。 HDR type理论可以写在Source后的任何地方，我们组通常写在x265后方 对于UHD压制，如为SDR，可以标上以作提示 WEBName Year Source Resolution Rip-type Video-codec Audio-Tag (因为WEB的源码与压制难以区分，故压制统一标注为WEBRip,另WEBRip还会被录制使用) Long Shot 2019 WEB-DL 2160p H.265&#x2F;HEVC&#x2F;H265 HDR DDP5.1-PHOENiX 0.5 mm 2014 WEBRip 1080p x265 10bit DDP5.1 MNHD-tag Blu-ray EncodeName Year Source Resolution Video-encode Audio MNHD-Tag Goodfellas 1990 BluRay 1080p x265 10bit DTS5.1-tag TV Show Season&#x2F;Mini-Series:Episode(File Name) 尽量避免数字连写，好看一些 也要避免集标题后直接接BluRay 尽量保证整个剧集，命名风格统一 对于迷你剧，尽管只有一季，也建议标S01，集数S01E01 Name S##E## Episode-Name(包含) Resolution Source Video-encode Audio-Tag Agatha.Christies.Poirot.S02E01.Peril.at.End.House.1080p.BluRay.x265.10bit.DD2.0.MNHD-tag Name S##E## Source Resolution Video-encode Audio-Tag Agatha.Christies.Poirot.S02E01.BluRay.1080p.x265.10bit.DD2.0.MNHD-tag SeasonName S## Source Resolution Year Video-encode Audio-Tag(由于剧集很多会跨年，故建议省略年份) The Romanoffs S01 2018 AMZN WEBRip 2160p x265 HDR DD+5.1-TrollUHD Pack可以尽量简写，Video-encode、Audio都可以不写 REPACK&#x2F;PROPER&#x2F;RERIP 不做字幕的Repack，建议提供修正后的可更改的文本类型字幕到公网即可 写在MNHD&#x2F;mUHD前面，未重新压制写REPACK，重压写RERIP，更换更好的源重压为PROPER PROPER在注明源具体版本的情况下可以省略，但需在标题中注明 REPACK、REPACK2、REPACK3 etc PROPER、PROPER2、PROPER3 etc RERIP、RERIP2、RERIP3 etc 版本是继承的 如 REPACK、PROPER2、RERip3 对于PROPER省略的，重置计数器"},{"title":"使用DEEW制作DDP/EAC3音轨教程","date":"2025-01-11T05:48:46.358Z","url":"/4.Audio&sub/%E4%BD%BF%E7%94%A8DEEW%E5%88%B6%E4%BD%9CDDP%E9%9F%B3%E8%BD%A8%E6%95%99%E7%A8%8B/","categories":[["4.Audio&sub","/categories/4-Audio-sub/"]],"content":"摆脱搭建MacOS环境困难以及Dolby Encode Suite单线程制作缓慢的烦恼，在Windows&#x2F;Linux下通过命令行直接制作。 本文主要讲解Windows下的搭建，Linux下流程类似，自行摸索。 可能因其更新本教程内容会有所滞后，遇到区别时请以上游的README为准。 环境准备 DEEW FFmpeg：从 gyan.dev 下载 | 从 Github 下载 推荐使用 winget，记得安装到全局。 Dolby Encoding Engine with Dolby AC-4 x64 (+license) Dolby Encoding Engine Wrapper使用deew 支持输入音轨以及带有音轨的 mkv(mp4 不太清楚) 按住Shift键并右键空白区域，选择 在 Windows终端 中打开 &#x2F; 在此处打开 Powershell 窗口，输入 确认正常返回版本号即可开始制作。 举例 以我们需要制作的DDP5.1及DDP7.1举例 以THD5.1为输入源 制作DDP5.1@1024kbps &#x2F; 768kbps 以DTS7.1为输入源 制作DDP7.1@1536kbps &#x2F; 1024kbps 完成后将在运行目录下找到与输入名称相同的.ec3文件，制作完成。 补充范例拓展，有需要的类推 以REMUX为输入源 将第一条音轨按默认设置制作 以 D:\\DDP\\demux 内所有 .flac 音频为输入源 批量生成动态范围为 film_standard 的DDP 并输出至 D:\\DDP\\done 完成后将在 D:\\DDP\\done 下找到与输入名称相同的.ec3文件，制作完成。 以w64为输入源 制作DD2.0@448kbps 完成后将在 deew-main 下找到与输入名称相同的.ac3文件，制作完成。 特别感谢pcroland 所有对DEE无限制使用做出贡献的人"},{"title":"常见报错","date":"2025-01-10T07:48:29.624Z","url":"/6.etc/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","categories":[["6.etc","/categories/6-etc/"]],"content":"x265 crash 注意检查CPU指令集，默认使用的是AVX2,有部分CPU不支持，LIKE E5-2690 0 这种情况下弄个CPU-Z看看就知道了 另外还有错误的参数可能会导致问题 压制程序退出生成文件被占用或不可写入会导致报错，例如 vs 预览会导致文件被占用。 Dgdemux 不显示界面DGDemux.ini 里有一行 Window_Position 删掉就好了，或者整个ini删掉也行 大小核调度问题管理员模式运行cmd，输入 高级电源设置里&quot;异类线程调度策略&quot;改成&quot;所有处理器&quot;"},{"title":"Progressive segmented frame","date":"2025-01-10T07:48:28.892Z","url":"/6.etc/PsF/","categories":[["6.etc","/categories/6-etc/"]],"content":"写作 interlace, 实际是为了塞p的视频 "},{"title":"对比","date":"2025-01-10T07:48:28.572Z","url":"/6.etc/Compare/","tags":[["Compare","/tags/Compare/"]],"categories":[["6.etc","/categories/6-etc/"]],"content":"psy-rd &amp; psy-rdoq第一次的对比图，当时发现 psy-rdoq 的提高会大幅度增加码率，psy-rd调高起了反效果，故淘汰 加了一组psy-rd 1.5 psy-rdoq 5 的 然后发现画面反而好了些 然后再加了一个通常参数 crf开到 19 码率差不多的 结论有问题调crf就完了，psy-rd 开到2,高码下会起反作用。(主要之前看人说高码要开2，如果18Mbps都不算高码的话当我没说)rdoq 开高也不太有必要，画面会有些浮肿 --crf 20.0 --psy-rd 1.50 --psy-rdoq 1 16053.14 kb&#x2F;s --crf 20.0 --psy-rd 2 --psy-rdoq 1.00 16477.59 kb&#x2F;s --crf 20.0 --psy-rd 2 --psy-rdoq 5.00 18741.22 kb&#x2F;s --crf 20 --psy-rd 1.5 --psy-rdoq 5.00 18293.03 kb&#x2F;s --crf 19 --psy-rd 1.50 --psy-rdoq 1.00 18464.78 kb&#x2F;s 调低 psy-rd 到 0.5 的对比"},{"title":"字幕相关","date":"2025-01-10T07:48:27.816Z","url":"/4.Audio&sub/%E5%AD%97%E5%B9%95%E5%88%B6%E4%BD%9C/","categories":[["4.Audio&sub","/categories/4-Audio-sub/"]],"content":"本篇内容都作为 Optional 字幕调轴一般来说不少字幕都可以通过平移来解决不同步问题。但还有相当多的会因为源的帧率不同导致同步问题。 此时应确认原字幕匹配的视频文件的帧率，以及目标视频文件的视频帧率 以 Blonde and Blonder 2007 举例，现有的都是DVD的字幕，需要制作1080p AMZN web(25fps)的字幕。 DVD是NTSC的，也就是传说中的5烂2 Attention NTSC 的相关事项建议查下资料以作了解。虽然DVD源是29.970 fps，但实际应使用压制处理后的分辨率23.976 fps。 然后对字幕做帧率转换，大部分的字幕软件都支持，除此之外还可以使用Potplayer 范例 对于 Blonde and Blonder 2007 的字幕，帧率由 23.976 fps 转为 25 fps,之后整体向前平移 12s 即可匹配 字幕轴替换有些情况下帧率调整没法解决问题，这种情况下可以完全的调轴(还有些可能就是制作字幕的人造成了一些错误) 比如你有一个轴不对的中文字幕，找到一条完全匹配的英文字幕。 你可以使用 Sutittle Edit 的 point sync via other subtitle 功能 还可以打开拥有正确时间轴的字幕，选所有行，右键，Column, delete text, 然后从其他字幕导入文本，最好再检查下有没有错行 精调Sutittle Edit 不但可以加载画面，甚至可以读取音轨波形，可以通过听以及观察波形来精调。 就是应该会有点累 双语合并使用srtedit即可，可以自己点点点研究一下就行。 注意事项 Sutittle Edit 处理ass会导致一些样式丢失 HDR字幕(包括srt)白颜色下会过亮(与软件可能也有一定关系)，请注意转换成暗色 "},{"title":"Dloby E 音轨说明","date":"2025-01-10T07:48:26.979Z","url":"/4.Audio&sub/DlobyE/","categories":[["4.Audio&sub","/categories/4-Audio-sub/"]],"content":"这个音轨主要目前没有任何封装工具支持。 FEED 源里把这个格式外面包了一层 PCM 使用，直接的话，是没有任何本地播放器支持的。 处理办法见这里  命令行摘抄 ffmpeg 支持解码 Dloby E，之后我弄了 deew 处理。只不过算有损转有损。但毕竟没法直接封装"},{"title":"2.0/1.0 音轨比较说明","date":"2025-01-10T07:48:26.250Z","url":"/4.Audio&sub/2.01.0%E9%9F%B3%E8%BD%A8%E8%AF%B4%E6%98%8E/","categories":[["4.Audio&sub","/categories/4-Audio-sub/"]],"content":"一般来说2.0是存在24bit音轨的，但是如potplayer默认就会转换成16bit输出。并且24bit音轨通常非常大，在flac格式下，接近16bit的两倍(不过存在假24bit音轨) 另外DTS 2.0(core,不是DTS-HD MA 2.0)为有损，24bit的DTS 码率(768kbps) &gt; 16 bit Flac(测试的是448 kb&#x2F;s) 后者只是某部影片转换的出来的参考值 （实际中不要这么操作，因为这里是有损算法转无损算法，不做down16的情况码率一般会上升） 通常压制2.0&#x2F;1.0只建议使用Flac,如感觉flac码率过高，可以转为16bit 相反DD&#x2F;AC3因为压缩效率差，并且因为是固定码率转换，码率给低了效果差，高了很可能比flac还要大(特别是以前有不少AC3 2.0 给640kbps的) AAC的话，参考下面那些情况，AAC的每条轨道并不建议超过100kbps，200kpbs在某些情况下已经接近flac 以The Asphalt Jungle 1950说明(注意这是1轨道) 原盘 Remux (24bit FLAC) Encode(16bit FLAC) 下面是16bit 2.0音轨的码率 以Jin.Bi.Tong.AKA.The.Kid.with.The.Golden.Arm.1979.1080p.Blu-ray.Remux.AVC.DTS-HD.MA.2.0-KRaLiMaRKo举例 转换为WAV&#x2F;PCM (PCM为raw数据，WAV为未经任何压缩的音频格式，PCM因为未封装，故看不到mediainfo信息) PCM体积933 MB (978,888,704 字节) 与WAV一致 转换为FLAC 用qaac转换 (-V 99) "},{"title":"常见的组合操作","date":"2025-01-10T07:48:26.246Z","url":"/3.Code/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C/","categories":[["3.Code","/categories/3-Code/"]],"content":"连接已挂 因为平时注意力不集中，所以这些可能是碎片化的，有空可能会整理。另外人菜，请批判性的理解 （水平问题，自己的脚本就不放出来了）  22行开始 对(luma平面 - Y)先降噪。然后STPresso对噪点进行处理之后再打回来。 对帧的一些操作 "},{"title":"Linux工具","date":"2025-01-10T07:48:24.003Z","url":"/2.Tools/Linux/","categories":[["2.Tools","/categories/2-Tools/"]],"content":"主要提供一些可以在 Linux 下使用的工具，但实际很少完全在 Linux 下工作，所以仅供参考 尝试过在 Linux 下面跑，但前置工作太长，一些实际在用的可能比较推荐 Arch，不过如果你日常使用 Linux 时间少于一天一小时的话，不建议你花精力在这上面。 InfoBDInfo 当前的 pre-release版本已经可以在 Linux 下面跑了 BDInfoCLI-ng docker run --rm -it -v &lt;BD_PATH&gt;:/mnt/bd -v &lt;REPORT_DEST&gt;:/mnt/report zoffline/bdinfocli-ng /mnt/bd /mnt/report (iso需要挂载后再扫) Demux&#x2F;RemuxtsMuxer mkvtoolnix注意章节编辑器名称模板改成英文 Chapter &lt;NUM:2&gt; DGDemux EncodeFFmpeg OthercutP.py OracleLinux&#x2F;RHEL系不过很多插件需要自己编辑，下面只是无意义的笔记 "},{"title":"封装格式(MP4/MKV…)、编码格式(H.264/H.265/AC3/AAC…)、编码器(x265/x264/SVT-AV1)","date":"2025-01-10T07:47:05.817Z","url":"/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E3%80%81%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/","categories":[["1.基础知识","/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"content":"参考   容器(Container)又名封装格式，或者格式(Format)，多媒体容器（Multimedia Container），常见的封装格式(MP4&#x2F;MKV…)、而 H.264&#x2F;H.265&#x2F;AC3&#x2F;AAC 属于编码方式 \\ 编码格式(Codec)，MP4以及MKV(封装格式)里封装的视频流以及音频流可以使用相同的编码格式 同一编码格式可以有很多不一样的编码器实现，每个编码器可能会各有特点，如 AAC 有 FAAC&#x2F;FDK-AAC&#x2F;QAAC&#x2F;NeroAAC&#x2F;FFMpeg-AAC 这些开源编码器，还有一些闭源编码器。另外还有 x265&#x2F;x264就是 常用的视频编码器，也是我们常用的压制工具。 一些需要注意的flac - Free Lossless Audio Codec - 自由无损音频压缩编码flac既是编码格式也是封装格式(flac用同样的名字做了容器名(即同时是封装格式的名字),) m4am4a(封装格式,仅有音频的MPEG-4&#x2F;mp4文件会使用.m4a扩展名)可以使用ALAC(Apple Lossless Audio Codec)编码也可以使用AAC(Advanced Audio Coding)编码。 mp3MP3(formally MPEG-1 Audio Layer III or MPEG-2 Audio Layer III) 是由MPEG-1(封装容器)与一个以MPEG-1Audio Layer III encoding编码过的音轨所组成。 wav 相关WAV属于封装格式，封装的PCM属于原始音频数据，完全未经压缩的编码方式 PCM - 脉冲编码调制（Pulse Code Modulation）是一种模拟信号的数字化方法。它是最常用、最简单的波形编码方式。 LPCM 是一种特定类型的 PCM，虽然‎‎PCM‎‎是一个更通用的术语，但它通常用于描述编码为LPCM的数据。‎ BWF（广播声波格式） 后缀也用wav,作为WAV的后继者，是由欧洲广播联盟(European Broadcasting Union)创建的一种标准音频格式。BWF has more data regarding the file. 但音轨质量没有区别 RF64(后缀通常会写w64以作区分)(multichannel audio file) WAV 文件格式的扩展，其文件大小可大于 4GB。 It has been specified by the European Broadcasting Union. It has been accepted as the ITU recommendation ITU-R BS.2088. H.265 相关H.265&#x2F;HEVC 是编码 H.265是标准，HEVC是胜出者，也叫 MPEG-H Part 2 有部分人认为 H.265 在交流中用于指代非 x265 的 HEVC商业编码器(个人认为非标准，并且无定义，属于口语化内容，仅供参考) 并且部分站点要求 Web-dl 标题必须写 H.265，不能使用HEVC，而原盘&#x2F;Remux只允许写HEVC。（个人认为属于区域规则，不建议作为标准理解） x265是开源免费编码器，另外还有一些商业的编码器，例如视骏,NVENC qaacqaac 是基于 Apple 编码器的命令行 AAC&#x2F;ALAC 编码器前端。 从 1.00 开始，qaac 直接使用 CoreAudioToolbox.dll。 因此，不再需要安装 QuickTime。 但是，需要 Apple 应用程序支持。 支持 AAC-LC、AAC-HE、ALAC 编码。一般我们制作出来的是LC (qaac开放源代码，似乎是Copyleft的并且没有任何限制) 封装格式 媒体容器(Media container)比较常见的MP4，MKV，RMVB，TS，FLV，AVI等很多，各种封装格式支持的编码是不一样的。 MKV vs MP4，主要的区别在于： MKV支持封装FLAC作为音频，MP4则不支持。但是MP4也可以封装无损音轨(比如说ALAC，虽然普遍认为ALAC的效率不如FLAC优秀) MKV支持封装ASS&#x2F;SSA格式的字幕，MP4则不支持。一般字幕组制作的字幕是ASS格式，所以内封字幕多见于MKV格式 MP4作为工业标准，在视频编辑软件和播放设备上的兼容性一般好于MKV。这也是vcb-s那些为移动设备优化的视频基本上选择MP4封装的原因。 还有一些过时的封装格式，比如RM、AVI等等。 编码格式(codec)通常mediainfo需要封装格式才能显示比较完整的信息，如.pcm .aac .hevc不能显示时长等信息。.hevc在播放器中是无法使用进度条的。 LPCM(Linear pulse-code modulation) 一般也会叫PCM，但是一种特定类型的 PCM，其跟PCM(Pulse Code Modulation)有区别，其量化级别是线性均匀的。 H.26X系列：由ITU（国际电信联盟）主导，包括H.261、H.262、H.263、H.264、H.265。 H.264：H.264&#x2F;MPEG-4第十部分，或称AVC（Advanced Video Coding，高级视频编码），是一种视频压缩标准，一种被广泛使用的高精度视频的录制、压缩和发布格式。 H.265：高效率视频编码（High Efficiency Video Coding，简称HEVC）是一种视频压缩标准，H.264&#x2F;MPEG-4 AVC的继任者。HEVC不仅提升图像质量，同时也能达到H.264&#x2F;MPEG-4 AVC两倍的压缩率 （等同于同样画面质量下码率减少50%），可支持4K分辨率甚至超高画质电视，最高分辨率可达8192×4320（8K分辨率），这是目前发展的趋势。 MPEG系列：由ISO（国际标准组织机构）下属的MPEG（运动图象专家组）主导，视频编码方面主要有： MPEG-1第二部分：主要使用在VCD上，有些在线视频也使用这种格式，该编解码器的质量大致上和原有的VHS录像带相当。 MPEG-2第二部分：等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（Cable Distribution Systems）中。 MPEG-4第二部分：可以使用在网络传输、广播和媒体存储上，比起MPEG-2和第一版的H.263，它的压缩性能有所提高。 MPEG-4第十部分：技术上和ITU-TH.264是相同的标准，二者合作，诞生了H.264&#x2F;AVC标准，ITU-T将其命名为H.264，而ISO&#x2F;IEC称它为MPEG-4高级视频编码（Advanced Video Coding，AVC）。 AVS（Audio Video coding Standard）：我国自主知识产权的信源编码标准，是《信息技术先进音视频编码》系列标准的简称，目前已完成两代AVS标准的制定。 第一代AVS标准包括国家标准《信息技术先进音视频编码第2部分：视频》（简称AVS1）和《信息技术先进音视频编码第16部分：广播电视视频》（简称AVS+）。AVS+的压缩效率与国际同类标准H.264&#x2F;AVC最高档次（High Profile）相当。 第二代AVS标准，简称AVS2，首要应用目标是超高清晰度视频，支持超高分辨率（4K以上）、高动态范围视频的高效压缩。AVS2的压缩效率比上一代标准AVS+和H.264&#x2F;AVC提高了一倍，超过国际同类型标准HEVC&#x2F;H.265。 其他系列，如，VP8、VP9（Google 主导），RealVideo（RealNetworks推出）等编码方式，在互联网视频使用较少，此处不再介绍。 转码视频转码（Video Transcoding）是指将已经压缩编码的视频码流转换成另一个视频码流，以适应不同的网络带宽、不同的终端处理能力和不同的用户需求。转码本质上是一个先解码、再编码的过程，因此转换前后的码流可能遵循相同的视频编码标准，也可能不遵循相同的视频编码标准。 转封装(Remux)转封装指的是将视频或音频的封装格式进行转换，如将AVI的视频转换为MP4，其间并不会进行音视频的编码和解码工作，而是直接将视频和音频压缩码流从一种封装格式文件中获取出来然后打包成另一种封装格式的文件。相比转码，转封装有两大特点： 处理速度极快。音视频编解码过程十分复杂，占据了转码的绝大部分时间。转封装不需要进行编码和解码，节约了大量的处理时间。音视频质量无损。没有解码（解压缩）和编码（压缩）过程，所以不会有音视频的压缩损伤。转封装后的文件与原始文件的分辨率、码率等几乎一致，故播放时也称其为“原画”。(部分封装格式会有无损压缩算法，like While muxing sup into MKV there can be &quot;zlib&quot; compression used) 分离(Demux)Extract 将编码格式从封装格式中拆出来 无损压缩以及有损压缩首先PCM和LPCM属于未经压缩的格式，不称为无损压缩。(但叫无损应该也没啥错) 日常中的无损较为口语化，需要理解其意思。通常说的无损格式指的算法无损，并不意味着生成的文件必定无损，一些音轨降位深或降频会造成损失。也会有一些有损转无损的非常规操作。 通常说原盘以及Remux无损，原盘一般是能找到的最优质的源，但其编码格式都属于有损，从母带(口语化)出来进行有损压缩再发布。而Remux主要为视频轨道以及主要音频轨道的无损提取或转换。(不过会有Hybird) 音频DTS(指公司)的音轨的压缩率非常差，并且他们以此作为宣传，认为这样能提高解码效率，音质会更好。 DTS-HD MA 是无损 DTS-HD HRA 是有损 两者同样带核心(DTS core，通常 DTS 会指 DTS core，不过有些我也不知道指的啥)。 其编码器同时包含了DTS Digital（DTS的有损音频格式）的编码核心以便在播放器不兼容DTS-HD MA或DTS-HD HRA（DTS-HD High Resolution Audio）时切换成DTS Digital（DTS Digital一般会以255Kbps的恒定码率进行编码，与DTS-HD MA&#x2F;HRA音频放置在同一流中，格式名称为DTS-HD Core） 有损音频AC3是作为影视业的工业标准。但其发布时间非常早。（略早于MP3） DTSDTS core 768被认为是不如AC3 640的。 这种编解码器在1080p的PT编码中十分常见。坦率地说，这只是因为臃肿的比特率(bloated bitrate)。DTS 实际上在1509 kbps时比 AC-3 在448 kbps时更糟。就不要用这个了。考虑它的唯一原因是偷懒，因为几乎每个电影源都会有一个DTS核心音轨，可以直接套用。 -by 《Advanced Encoding Guide》(我觉得有点夸张，我很讨厌dts) AC3它的效率比MP3还差 -by 《Advanced Encoding Guide》 杜比实验室采用了 MDCT 算法以及感知编码原理来开发 AC-3 音频格式以满足影院需求。 AC-3 格式于 1991 年作为杜比数字标准发布。 AC-3 (Audio Codec 3, Advanced Codec 3, Acoustic Coder 3. [不同于Adaptive Transform Acoustic Coding 3&#x2F;ATRAC3，是索尼研发的另一种格式]) Dolby Digital Surround EX 杜比数字环绕EX（Dolby Digital Surround EX），是杜比实验室和Lucasfilm THX在1999年5月面世的星球大战首部曲：威胁潜伏电影中合作的产品。在考虑经济效益和向下兼容性，在左环绕和右环绕中间，加插了后环绕声道，形成6.1输出。它使用了矩阵编码，这是一条独立分离声道，情形就像前置左右声道和中置声道的关系一样。所以它能在标准的5.1设备上输出5.1，又能同时支持杜比数字环绕EX的器材上输出6.1。在星球大战系列中使用了这技术。不少DVD支持杜比数字环绕EX的输出。 Dolby Digital EX 杜比数字EX（Dolby Digital EX）是杜比数字环绕EX的民用版本。杜比数字EX类似杜比早期的Pro-Logic技术，集成了矩阵技术，在立体声音轨上加入一中置和一后置声道。杜比数字EX在5.1杜比数字的基础上加入后置声道，创出6.1或7.1的声道输出。但是，这技术并不能视为真正的6.1或7.1编码，与它的竞争对手DTS-ES格式不同，它并不能提供完整独立分离的6条或7条音轨。 Dolby Digital Plus&#x2F;DDP&#x2F;EAC3目前本组的首选格式(1.0&#x2F;2.0除外，一般建议制作时带EX) 杜比数字Plus（Dolby Digital Plus）又称为E-AC-3，是基于AC3的基础进行加强的编码系统。它把最高比特率提升至6 Mbps，支持14声道（13.1），增强的编码技术能够减少压缩对杂讯（artifact）。无法兼容于Dolby Digital器材，但是Dolby Digital Plus解码器可以将Dolby Digital Plus转码成Dolby Digital 通过光纤&#x2F;同轴输出。Dolby Digital Plus 是HD DVD和蓝光影碟的必选音频格式。在蓝光播放器中，Dolby Digital Plus是主音轨（Primary Audio）的可选格式，第二音轨（Secondary Audio）必选格式。 AACAAC在低码下更有优势。（但Opus做的更好） 因为AAC是一个庞大家族，他们共分为9种规格，以适应不同场合的需要，也正是由于AAC的规格（Profile）繁多，导致普通电脑用户感觉十分困扰： MPEG-2 AAC LC低复杂度规格（Low Complexity） MPEG-2 AAC Main主规格 MPEG-2 AAC SSR可变采样率规格（Scaleable Sample Rate） MPEG-4 AAC LC低复杂度规格（Low Complexity），现在的手机比较常见的MP4文件中的音频部分就包括了该规格音频档案 MPEG-4 AAC Main主规格 MPEG-4 AAC SSR可变采样率规格（Scaleable Sample Rate） MPEG-4 AAC LTP长时期预测规格（Long Term Predicition） MPEG-4 AAC LD低延迟规格（Low Delay） MPEG-4 AAC HE高效率规格（High Efficiency） 上述的规格中，主规格（Main）包含了除增益控制之外的全部功能，其音质最好，而低复杂度规格（LC）则是比较简单，没有了增益控制，但提高了编码效率，至“SSR”对“LC”规格大体是相同，但是多了增益的控制功能，另外，MPEG-4 AAC&#x2F;LTP&#x2F;LD&#x2F;HE，都是用在低比特率下编码，特别是“HE”是有Nero AAC编码器支持，是近来常用的一种编码器，不过通常来说，Main规格和LC规格的音质相差不大，因此目前使用最多的AAC规格多数是“LC”规格，因为要考虑手机目前的存储器能力未达合理水准。 MPEG-4 AAC LC（Low Complexity）是最常用的规格，我们叫“低复杂度规格”，我们简称“LC-AAC”，这种规格在中等码率的编码效率以及音质方面，都能找到平衡点。所谓中等码率，就是指：96kbps-192kbps之间的码率。因此，如果要使用LC-AAC规格，请尽可能把码率控制在之前说的那个区间内。 ffmpeg里 Based on quality produced from high to low: libopus &gt; libvorbis &gt;&#x3D; libfdk_aac &gt; aac &gt; libmp3lame &gt;&#x3D; eac3&#x2F;ac3 &gt; libtwolame &gt; vorbis &gt; mp2 &gt; wmav2&#x2F;wmav1 一些有损音频测试引用 blog.nannan.cool 里说的一些话&quot;同一编码格式可以有很多不一样的编码器实现，每个编码器都有自己的特点，音质也不相同。举个例子，光是AAC编码格式就有 FAAC&#x2F;FDK-AAC&#x2F;QAAC&#x2F;NeroAAC&#x2F;FFMpeg-AAC 五种不同的开源编码器，更别提闭源的编解码器了。不同的编码器有自己的侧重点，尽管差异不像不同格式那么巨大，同码率下的听感也有出入（低码率下尤其明显）。多项盲听测试指出AAC编码器中最好的是 QAAC ，其次是 FDK-AAC。&quot; &quot;总的来说，对于 MP3 ，因为它实在是不擅长对付高频信息，要能做到听感无损，那么最好使用不低于 192Kbps 的码率进行编码；对于 AAC （LC-AAC）来说，建议至少使用 160Kbps 以上，最好也要到 192Kbps；对于 Opus，得益于最新的心理声学模型，在 128Kbps 下就能够获得可听的音质了，如果还是不放心的话可以提到 160Kbps。不过从上面的对比中可以看出，不同歌曲对于码率的需求是不同的，而且差异一点也不小。因此出现一首歌 128K 就够了，另一首歌 160K 还是不够用也是很正常的。如果需要编码的歌较少，大可以逐一进行尝试，但如果是批量编码的话，可以直接套用上面的推荐码率。&quot; 双盲:   "},{"title":"基本概念","date":"2025-01-10T07:47:04.909Z","url":"/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","categories":[["1.基础知识","/categories/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"content":"视频格式本文大部分参考以及直接引用  视频的基础参数分辨率视频是由连续的图像构成的。每一张图像，我们称为一 帧(frame) 。图像则是由像素(pixel)构成的。一张图像有多少像素，称为这个图像的 分辨率。比如说1920×1080的图像，说明它是由横纵1920×1080个像素点构成。视频的分辨率就是每一帧图像的分辨率。 帧率一个视频，每一秒由多少图像构成，称为这个视频的 帧率(frame-rate) 。常见的帧率有24000&#x2F;1001&#x3D;23.976, 30000&#x2F;1001&#x3D;29.970, 60000&#x2F;1001&#x3D;59.940, 25.000, 50.000等等。这个数字是一秒钟内闪过的图像的数量。比如23.976，就是1001秒内，有24000张图像。视频的帧率是可以是恒定的(cfr, Const Frame-Rate)，也可以是变化的(vfr, Variable Frame-Rate) 码率码率 的定义是视频文件体积除以时间。单位一般是Kbps(Kbit&#x2F;s)或者Mbps(Mbit&#x2F;s)。注意1B(Byte)&#x3D;8b(bit)。所以一个24分钟，900MB的视频： 体积：900MB &#x3D; 900MByte &#x3D; 7200Mbit 时间：24min &#x3D; 1440s 码率：7200&#x2F;1440 &#x3D; 5000 Kbps &#x3D; 5Mbps 当视频文件的时间基本相同的时候（比如现在一集番大概是24分钟），码率和体积基本上是等价的，都是用来描述视频大小的参数。长度分辨率都相同的文件，体积不同，实际上就是码率不同。 码率也可以解读为单位时间内，用来记录视频的数据总量。码率越高的视频，意味着用来记录视频的数据量越多，潜在的解读就是视频可以拥有更好的质量。（注意，仅仅是潜在，后文我们会分析为什么高码率不一定等于高画质） 码率控制方法码率控制是指视频编码中决定输出码率的过程，常用的码率控制方法有： VBR(Variable Bitrate)动态比特率，也就是没有固定的比特率，音视频压缩软件在压缩时根据音视频数据的复杂程度即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式。 相对于CBR来说适用场景：VBR适用于那些对带宽和编码速度不太限制，但是对质量有很高要求的场景。特别是在运动的复杂场景下也可以保持比较高的清晰度且输出质量比较稳定，适合对延时不敏感的点播，录播或者存储系统。特点： 码率不稳定，质量基本稳定且非常高； 编码速度一般比较慢，点播、下载和存储系统可以优先使用，不适合低延时、直播系统； 这种模型完全不考虑输出的视频带宽，为了质量，需要多少码率就占用多少，也不太考虑编码速度； CQP(Constant QP)应该算编码器实现VBR的方式固定QP，最简单的码率控制方式，每帧图像都按照一个特定的QP来编码，每帧编码后的数据量有多大是未知的，既不是码率优先模型也不是质量优先模型，不过是实现最简单的模型； 适用场景：一般不建议使用这种方式，因为这种方式不考虑编码内容的复杂性，用相同的压缩比处理每一帧。出来的视频质量和码率都不固定。个人觉得只有那种非常简单的场景，比如静止不变的场景运动量很小的场景可以尝试用，一遇到复杂场景，码率波动就非常大。或者在算法研究或者验证可以使用。 特点： 瞬时码率会随场景复杂度波动； 编码速度快，调控最简单,每帧的QP值相同； CRF(Constant Rate Factor)应该算编码器实现VBR的方式恒定码率系数。把某一个”视觉质量”作为输出目标。通过降低那些耗费码率但是又难以用肉眼察觉的帧（高速运动或者纹理丰富）的质量提升那些静态帧的码率来达到此目的。 特点：帧间QP变化，帧内宏块的QP变化，输出码率未知，各帧输出的视觉质量基本恒定，这种方式相当于固定质量模式+限制码率峰值的方式。 适用场景：适用于对视频质量有一定要求的场合，CRF值可以简单理解为对视频质量期望的一个输出固定值，希望无论是在运动复杂场景下还是在静止简单情况下，都希望有一个稳定的主观视频质量可以选择该模式，该模式是视频质量优先模型。视频质量可以简单理解为视频的清晰度，像素的细腻程度和视频的流畅度。 特点： 与恒定QP类似，但追求主观感知到的质量恒定，瞬时码率也会随场景复杂度波动，视频帧之间或者内部宏块之间的QP值都不一样； 对于快速运动或细节丰富的场景会适当增大量化失真（因为人眼不敏感），反之对于静止或平坦区域则减少量化失真； CBR(Constant Bitrate)固定比特率，指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，而且视频质量相对于VBR和ABR不会有明显的提高。 特点： 码率稳定，但是质量不稳定，带宽有效利用率不高，特别当该值设置不合理，在复杂运动场景下，画面非常模糊，非常影响观看体验； 但是输出视频码率基本稳定，便于计算视频体积大小； ABR(Average Bitrate)平均比特率，是VBR的一种插值参数。LAME针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR在指定的文件大小内，以每50帧（30帧约1秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以做为VBR和CBR的一种折衷选择。 ABR在一定的时间范围内达到设定的码率，但是局部码率峰值可以超过设定的码率，平均码率恒定。ABR是VBR的改良版，能确保输出平均码率在合理范围，且在这个范围内，还是动态根据复杂度编码， 适用场景：ABR在直播和低延时系统用的比较多特点： 视频质量整体可控，同时兼顾了视频码率和速度，是一个折中方案，实际用的比较多； 使用过程一般要让调用方设置，最低码率、最高码率和平均码率，这些值要尽可能设置合理点； 图像的表示方法RGB模型光的三原色是红(Red)、绿(Green)、蓝(Blue)。现代的显示器技术就是通过组合不同强度的三原色，来达成任何一种可见光的颜色。图像储存中，通过记录每个像素红绿蓝强度，来记录图像的方法，称为RGB模型 (RGB Model) 常见的图片格式中，PNG和BMP这两种就是基于RGB模型的。 比如说原图： 分别只显示R G B通道的强度，效果如下： 三个通道下，信息量和细节程度不一定是均匀分布的。比如说可以注意南小鸟脸上的红晕，在3个平面上的区分程度就不同——红色平面下几乎无从区分，造成区别的主要是绿色和蓝色的平面。外围白色的脸颊，三色都近乎饱和；但是红晕部分，只有红色饱和，绿色和蓝色不饱和。这是造成红色凸显的原因。 YUV模型除了RGB模型，还有一种广泛采用的模型，称为YUV模型，又被称为亮度-色度模型（Luma-Chroma）。它是通过数学转换，将RGB三个通道，转换为一个代表亮度的通道(Y,又称为Luma)，和两个代表色度的通道(UV，并成为Chroma)。 YUV模型干的是类似的事儿。通过对RGB数据的合理转换，得到另一种表示方式。YUV模型下，还有不同的实现方式。举个用的比较多的YCbCr模型：它把RGB转换成一个亮度(Y)，和 蓝色色度(Cb) 以及 红色色度(Cr)。转换背后复杂的公式大家不需要了解，只需要看看效果： 只有亮度通道： 只有蓝色色度： 只有红色色度： 在图像视频的加工与储存中，YUV格式一般更受欢迎，理由如下： 人眼对亮度的敏感度远高于色度，因此人眼看到的有效信息主要来自于亮度。YUV模型可以将绝大多数的有效信息分配到Y通道。UV通道相对记录的信息少的多。相对于RGB模型较为平均的分配，YUV模型将多数有效信息集中在Y通道，不但减少了冗余信息量，还为压缩提供了便利 保持了对黑白显示设备的向下兼容 图像编辑中，调节亮度和颜色饱和度，在YUV模型下更方便。 几乎所有的视频格式，以及广泛使用的JPEG图像格式，都是基于YCbCr模型的。播放的时候，播放器需要将YCbCr的信息，通过计算，转换为RGB。这个步骤称为渲染（Rendering） 每个通道的记录，通常是用整数来表示。比如RGB24，就是RGB各8个bit，用0~255 (8bit的二进制数范围)来表示某个颜色的强弱。YUV模型也不例外，也是用整数来表示每个通道的高低。 色深色深(bit-depth)，就是我们通常说的8bit和10bit，是指每个通道的精度。8bit就是每个通道用一个8bit整数(0~255)代表，10bit就是用10bit整数(0~1023)来显示。16bit则是0~65535 (注意，上文的表述是不严谨的，视频在编码的时候，并非一定能用到0~255的所有范围，而是可能有所保留，只用到一部分，比如16~235。这我们就不详细展开了) 你的显示器是8bit的，代表它能显示RGB每个通道0~255所有强度。但是视频的色深是YUV的色深，播放的时候，YUV需要通过计算转换到RGB。因此，10bit的高精度是间接的，它使得运算过程中精度增加，以让最后的颜色更细腻。 如何理解8bit显示器，播放10bit是有必要的呢： 一个圆的半径是12.33m, 求它的面积，保留两位小数。 半径的精度给定两位小数，结果也要求两位小数，那么圆周率精度需要给多高呢？也只要两位小数么？ 取pi&#x3D;3.14, 面积算出来是477.37平方米 取pi&#x3D;3.1416，面积算出来是477.61平方米 取pi精度足够高，面积算出来是477.61平方米。所以取pi&#x3D;3.1416是足够的，但是3.14就不够了。 换言之，即便最终输出的精度要求较低，也不意味着参与运算的数字，以及运算过程，可以保持较低的精度。在最终输出是8bit RGB的前提下，10bit YUV比起8bit YUV依旧具有精度优势的原因就在这里。事实上，8bit YUV转换后，覆盖的精度大概相当于8bit RGB的26%，而10bit转换后的精度大约可以覆盖97%——你想让你家8bit显示器发挥97%的细腻度么？看10bit吧。 8bit精度不足，主要表现在亮度较低的区域，容易形成色带 注意这图右边那一圈圈跟波浪一样的效果。这就是颜色精度不足的表现。 10bit的优势不只在于显示精度的提高，在提高视频压缩率，减少失真方面，相对8bit也有优势。这方面就不展开了。 帧、帧的类型V电影是由多个“图片”连续播放组成的，每个“图片”被称为帧，电影单位时间内播放的帧的数目称为帧率，常见帧率数值有：23.97、24、29.97等等 相邻连续帧主要部分基本相同，画面中只有部分内容发生运动改变，因此可以对于相似帧只保存变换的内容，用于储存节约空间。 根据帧储存性质，可以分为3类： I帧(Intracoded帧):此帧是一个独立的帧，它不使用其前后的帧中的任何信息。一般作为参考帧的基础架构，储存完整的帧信息，占用空间较大。 P帧（Predicted帧）:P帧又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的空间。 B帧（Bi-predictive帧）:B帧又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。 不同编码根据自己算法，对于一个视频进行压缩编码，不同的编码方式，对于不同帧处理方式不同，有着自己的标准。 GOP（关键帧间隔）GOP（Group of Pictures）是一组以 MPEG 编码的影片或视讯串流内部的连续图像，以 I 帧开头，到下一个 I 帧结束。一个 GOP 包含如下图像类型： I 帧（Intra Coded Picture）：又称帧内编码帧，为关键帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I 帧，每个 GOP 由I 帧开始。P 帧（Predictive Coded Picture）：又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感。B 帧（Bidirectionally Predictive Coded Pictures）：又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。GOP值表示关键帧的间隔（即两个关键帧之间的帧数），也就是两个IDR帧之间的距离，一个帧组的最大帧数。一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善视频质量，但会同时增加带宽和网络负载。GOP值（帧数）除以帧率即为时间间隔，如阿里云视频点播默认的GOP值为250帧，帧率为25fps，则时间间隔为10秒。 GOP值需要控制在合理范围，以平衡视频质量、文件大小（网络带宽）和seek效果（拖动、快进的响应速度）等： 加大GOP值有利于减小视频文件大小，但也不宜设置过大，太大则会导致GOP后部帧的画面失真，影响视频质量。GOP值也是影响视频seek响应速度的关键因素，seek时播放器需要定位到离指定位置最近的前一个关键帧，如果GOP太大意味着距离指定位置可能越远（需要解码的预测帧就越多）、seek响应的时间（缓冲时间）也越长。由于P、B帧的复杂度大于I帧，GOP值过大，过多的P、B帧会影响编码效率，使编码效率降低。但如果设置过小的GOP值，则需要提高视频的输出码率，以确保画面质量不会降低，故会增加网络带宽。 IDR 帧对齐IDR帧（Instantaneous Decoding Refresh Picture），即时解码刷新帧，是 I 帧的一种。与普通 I 帧的区别在于，一个 IDR 帧之后的所有帧都不能引用该 IDR 帧之前的帧的内容；相反，对于普通的 I 帧，其后的 P 帧和 B 帧可以引用该普通 I 帧之前的其他 I 帧。在编码和解码中为了方便，将首个I帧和其他I帧区别开，称为IDR，这样就方便控制编码和解码流程。 IDR帧的作用是立刻刷新，使错误不致传播，从IDR帧开始，重新算一个新的序列开始编码。而普通I帧不具有随机访问的能力，这个功能是由IDR承担。视频播放时，播放器一般都支持随机seek（拖动）到指定位置，而播放器直接选择到指定位置附近的 IDR 帧进行播放最为便捷，因为可以明确知道该 IDR 帧之后的所有帧都不会引用其之前的其他 I 帧，从而避免较为复杂的反向解析。 在对同一个视频进行多码率转码时，如果指定 IDR 帧对齐（IDR Frame Alignment），则意味着所有输出视频的 IDR 帧在时间点、帧内容方面都保持精确同步，此时播放器便可实现多码率视频平滑切换，从而不会出现较为明显的切换卡顿。 色度半采样在YUV模型的应用中，Y和UV的重要性是不等同的。图像视频的实际储存和传输中，通常将Y以全分辨率记录，UV以减半甚至1&#x2F;4的分辨率记录。这个手段被称为色度半采样(Chroma Sub-Sampling)。色度半采样可以有效减少传输带宽，和加大UV平面的压缩率，但是不可避免的会损失UV平面的有效信息。 我们平常的视频，最常见的是420采样。配合YUV格式，常常被写作yuv420。这种采样是Y保留全部，UV只以(1&#x2F;2) x (1&#x2F;2)的分辨率记录。比如说1920×1080的视频，其实只有亮度平面是1920×1080。两个色度平面都只有960×540的分辨率。 当然了，你也可以选择不做缩减。这种称为444采样，或者yuv444。YUV三个平面全是满分辨率。 在做YUV-&gt;RGB的时候，首先需要将缩水的UV分辨率拉升到Y的分辨率（madVR中允许自定义算法，在Chroma Upscaling当中），然后再转换到RGB。做RGB-&gt;YUV的转换，也是先转换到444（YUV的分辨率相同），再将UV分辨率降低。 一般能拿到的片源，包括所有蓝光原盘，都是420采样的。所以成品一般也保留420采样。所以yuv420就表示这个视频是420采样的yuv格式。 将420做成444格式，需要自己手动将UV分辨率拉升2×2倍。在今天madVR等渲染器可以很好地拉升UV平面的情况下，这种做法无异于毫无必要的拉升DVD做成伪高清。 当然了，有时候也需要在444&#x2F;RGB平面下做处理和修复，常见的比如视频本身RGB平面不重叠（比如摩卡少女樱），这种修复过程首先要将UV分辨率拉升，然后转RGB，做完修复再转回YUV。修复后的结果相当于全新构图，这种情况下保留444格式就是有理由，有必要的。 H264格式编码444格式，需要High 4:4:4 Predictive Profile（简称Hi444pp）。所以看到Hi444pp&#x2F;yuv444 之类的标示，你就需要去找压制者的陈述，为什么他要做这么个拉升。如果找不到有效的理由，你应该默认作者是在瞎做。 清晰度与画质简述经常看到的说法：“这个视频清晰度是1080p的”。其实看过上文你就应该知道，1080p只是视频的分辨率，它不能直接代表清晰度——比如说，我可以把一个480p的dvd视频拉升到1080p，那又怎样呢？它的清晰度难道就提高了么？ 视频的画质，是由以下几点共同决定的 源的画质。 俗话说的好，上梁不正下梁歪。如果源的画质本身很差，那么再如何折腾都别指望画质好到哪去。所以压制者往往会选择更好的源进行压制——举个栗子，BDRip一般都比TVRip来的好，哪怕是720p。蓝光也分销售地区，一般日本销售的日版，画质上比美版、台版、港版啥的都来得好，所以同样是BDRip，选取更好的源，就能做到画质上优先一步。 播放条件。 观众是否用了足矣支持高画质播放的硬件和软件。这就是为啥我们在发布Rip的同时大力普及好的播放器；有时候一个好的播放器胜过多少在制作方面的精力投入。 码率投入vs编码复杂度。 视频的时间和空间复杂度，并称为编码复杂度。编码复杂度高的视频，往往细节多，动态高（比如《魔法少女小圆剧场版 叛逆的物语》），这样的视频天生需要较高的码率去维持一个优秀的观看效果。 相反，有些视频编码复杂度低（比如《请问今天要来点兔子么》，动态少，线条细节柔和），这种视频就是比较节省码率的。 码率分配的效率和合理度。 同样多的码率，能起到怎样好的效果，被称为效率。比如H264就比之前的RealVideo效率高；10bit比8bit效率高；编码器先进，参数设置的比较合理，编码器各种高端参数全开（通常以编码时间作为代价），码率效率就高。 合理度就是码率在时空分配方面合理与否，合理的分配，给观众的观看效果就比较统一协调。 码率分配的效率和合理度，是对制作者的要求，要求制作者对片源分析，参数设置有比较到位的理解。 码率分配和合理度做的好，就常常能做出低码率高画质的良心作品。 编码前的预处理。预处理分三种： 客观修复。强调修复片源固有的瑕疵，比如锯齿，色带，晕轮等等。 主观调整，强调将片源调整的更适合人眼观看，比如适度的锐化，调色（有时候你是可以通过科学方法判定片源的颜色有问题，然后针对的做修复的）。 移除无效高频信息，比如降噪，避免码率浪费在无效的噪点上 预处理做的好，往往能达到画质上超越片源，或是在几乎不牺牲清晰度的前提下，节省码率开销。 但是预处理是一把双刃剑，优化的同时，可能引入副效果。降噪、抗锯齿、去晕轮等操作会不可避免的损失一些有效细节（或多或少，取决于制作者水准）；主观调整很可能 会引入副效果（比如过度锐化会导致锯齿和晕轮），或是变成了作者的自我满足，形成对观众的欺骗。 综上，一个优秀的画质，是由片源、制作者、观看者共同决定的；码率高低也只是部分因素，并非决定性的效果。"},{"date":"2025-08-14T03:31:17.323Z","url":"/Scrips/Readme.html","categories":[["undefined",""]],"content":"这里的脚本 flac.bat、opus.bat、cutPicture.py 都需要使用ffmpeg,请确保其位于同级目录或者环境变量中。 cutPicture.py 来自 ，但有很大的修改。 会需要使用 ffprobe、oxipng，并且如路径或文件名包含全角字符，可能会没法使用"}]